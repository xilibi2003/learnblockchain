<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>深入浅出区块链</title>
  
  <subtitle>系统学习区块链技术</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://learnblockchain.cn/"/>
  <updated>2018-01-22T08:33:54.881Z</updated>
  <id>https://learnblockchain.cn/</id>
  
  <author>
    <name>Tiny熊</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>一步步教你开发、部署第一个去中心化应用(Dapp) - 宠物商店</title>
    <link href="https://learnblockchain.cn/2018/01/12/first-dapp/"/>
    <id>https://learnblockchain.cn/2018/01/12/first-dapp/</id>
    <published>2018-01-12T14:36:39.000Z</published>
    <updated>2018-01-22T08:33:54.881Z</updated>
    
    <content type="html"><![CDATA[<p>今天我们来编写一个完整的去中心化（区块链）应用（Dapps）, 本文可以和<a href="https://learnblockchain.cn/2017/11/24/init-env/">编写智能合约</a>结合起来看。</p><a id="more"></a><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>阅读本文前，你应该对以太坊、智能合约有所了解，如果你还不了解，建议你先看<a href="https://learnblockchain.cn/2017/11/20/whatiseth/">以太坊是什么</a><br>除此之外，你最好还了解一些HTML及JavaScript知识。</p><p>本文通过实例教大家来开发去中心化应用，应用效果如图：<br><img src="https://learnblockchain.cn/images/Petshop.jpg" alt=""></p><p>从本文，你可以学习到：</p><ul><li>搭建智能合约开发环境</li><li>创建Truffle项目</li><li>编写智能合约</li><li>编译和部署智能合约到区块链</li><li>如何通过Web3和智能合约交互</li><li>MetaMask 的使用</li></ul><p><a href="https://xiaozhuanlan.com/blockchaincore" target="_blank" rel="noopener">小专栏</a>用户在教程结尾处可以下载完整的Dapp代码。</p><h2 id="项目背景"><a href="#项目背景" class="headerlink" title="项目背景"></a>项目背景</h2><p>Pete有一个宠物店，有16只宠物，他想开发一个去中心化应用，让大家来领养宠物。<br>在truffle box中，已经提供了pet-shop的网站部分的代码，我们只需要编写合约及交互部分。</p><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><ol><li>安装<a href="https://nodejs.org/en/download/" target="_blank" rel="noopener">Node</a></li><li>安装 Truffle ：<code>npm install -g truffle</code></li><li>安装<a href="http://truffleframework.com/ganache/" target="_blank" rel="noopener">Ganache</a></li></ol><blockquote><p>Ganache（或Ganache CLI）已经取代了 testrpc。</p></blockquote><h2 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h2><ol><li><p>建立项目目录并进入</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> mkdir pet-shop-tutorial</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="built_in">cd</span> pet-shop-tutorial</span></span><br></pre></td></tr></table></figure></li><li><p>使用truffle unbox 创建项目</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"> &gt;</span><span class="bash"> truffle unbox pet-shop</span></span><br><span class="line"> Downloading...</span><br><span class="line"> Unpacking...</span><br><span class="line"> Setting up...</span><br><span class="line"> Unbox successful. Sweet!</span><br><span class="line"></span><br><span class="line">Commands:</span><br><span class="line"></span><br><span class="line">  Compile:        truffle compile</span><br><span class="line">  Migrate:        truffle migrate</span><br><span class="line">  Test contracts: truffle test</span><br><span class="line">  Run dev server: npm run dev</span><br></pre></td></tr></table></figure></li></ol><p>这一步需要等待一会</p><blockquote><p>也可以使用truffle init 来创建一个全新的项目。</p></blockquote><h2 id="项目目录结构"><a href="#项目目录结构" class="headerlink" title="项目目录结构"></a>项目目录结构</h2><p><code>contracts/</code>  智能合约的文件夹，所有的智能合约文件都放置在这里，里面包含一个重要的合约Migrations.sol（稍后再讲）<br><code>migrations/</code> 用来处理部署（迁移）智能合约 ，迁移是一个额外特别的合约用来保存合约的变化。<br><code>test/</code> 智能合约测试用例文件夹<br><code>truffle.js/</code> 配置文件</p><p>其他代码可以暂时不用管</p><h2 id="编写智能合约"><a href="#编写智能合约" class="headerlink" title="编写智能合约"></a>编写智能合约</h2><p>智能合约承担着分布式应用的后台逻辑和存储。智能合约使用solidity编写，可阅读<br><a href="https://learnblockchain.cn/categories/ethereum/Solidity/">solidity系列文章</a></p><p>在contracts目录下，添加合约文件Adoption.sol<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.17</span>;</span><br><span class="line"></span><br><span class="line">contract Adoption &#123;</span><br><span class="line"></span><br><span class="line">  address[<span class="number">16</span>] public adopters;  <span class="comment">// 保存领养者的地址</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 领养宠物</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">adopt</span>(<span class="params">uint petId</span>) <span class="title">public</span> <span class="title">returns</span> (<span class="params">uint</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">require</span>(petId &gt;= <span class="number">0</span> &amp;&amp; petId &lt;= <span class="number">15</span>);  <span class="comment">// 确保id在数组长度内</span></span><br><span class="line"></span><br><span class="line">    adopters[petId] = msg.sender;        <span class="comment">// 保存调用这地址 </span></span><br><span class="line">    <span class="keyword">return</span> petId;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回领养者</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">getAdopters</span>(<span class="params"></span>) <span class="title">public</span> <span class="title">view</span> <span class="title">returns</span> (<span class="params">address[<span class="number">16</span>]</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> adopters;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="编译部署智能合约"><a href="#编译部署智能合约" class="headerlink" title="编译部署智能合约"></a>编译部署智能合约</h2><p>Truffle集成了一个开发者控制台，可用来生成一个开发链用来测试和部署智能合约。</p><h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><p>Solidity是编译型语言，需要把可读的Solidity代码编译为EVM字节码才能运行。<br>dapp的根目录pet-shop-tutorial下，<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> truffle compile</span></span><br></pre></td></tr></table></figure></p><p>输出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Compiling ./contracts/Adoption.sol...</span><br><span class="line">Writing artifacts to ./build/contracts</span><br></pre></td></tr></table></figure></p><h3 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h3><p>编译之后，就可以部署到区块链上。<br>在migrations文件夹下已经有一个1_initial_migration.js部署脚本，用来部署Migrations.sol合约。<br>Migrations.sol 用来确保不会部署相同的合约。</p><p>现在我们来创建一个自己的部署脚本<code>2_deploy_contracts.js</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var Adoption = artifacts.require(&quot;Adoption&quot;);</span><br><span class="line"></span><br><span class="line">module.exports = function(deployer) &#123;</span><br><span class="line">  deployer.deploy(Adoption);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在执行部署之前，需要确保有一个区块链运行, 可以使用<br><a href="http://truffleframework.com/ganache/" target="_blank" rel="noopener">Ganache</a>来开启一个私链来进行开发测试，默认会在7545端口上运行一个开发链。<br>Ganache 启动之后是这样：<br><img src="https://learnblockchain.cn/images/ganache-initial.png" alt=""></p><p>接下来执行部署命令:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; truffle  migrate</span><br></pre></td></tr></table></figure></p><p>执行后，有一下类似的输出，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Using network &apos;develop&apos;.</span><br><span class="line"></span><br><span class="line">Running migration: 1_initial_migration.js</span><br><span class="line">  Deploying Migrations...</span><br><span class="line">  ... 0x3076b7dac65afc44ec51508bf6f2b6894f833f0f9560ecad2d6d41ed98a4679f</span><br><span class="line">  Migrations: 0x8cdaf0cd259887258bc13a92c0a6da92698644c0</span><br><span class="line">Saving successful migration to network...</span><br><span class="line">  ... 0xd7bc86d31bee32fa3988f1c1eabce403a1b5d570340a3a9cdba53a472ee8c956</span><br><span class="line">Saving artifacts...</span><br><span class="line">Running migration: 2_deploy_contracts.js</span><br><span class="line">  Deploying Adoption...</span><br><span class="line">  ... 0x2c6ab4471c225b5473f2079ee42ca1356007e51d5bb57eb80bfeb406acc35cd4</span><br><span class="line">  Adoption: 0x345ca3e014aaf5dca488057592ee47305d9b3e10</span><br><span class="line">Saving successful migration to network...</span><br><span class="line">  ... 0xf36163615f41ef7ed8f4a8f192149a0bf633fe1a2398ce001bf44c43dc7bdda0</span><br><span class="line">Saving artifacts...</span><br></pre></td></tr></table></figure></p><p>在打开的Ganache里可以看到区块链状态的变化，现在产生了4个区块。<br><img src="https://learnblockchain.cn/images/ganache-migrated.png" alt=""><br>这时说明已经智能合约已经部署好了。</p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>现在我们来测试一下智能合约，测试用例可以用 JavaScript or Solidity来编写，这里使用Solidity。</p><p>在<code>test</code>目录下新建一个<code>TestAdoption.sol</code>，编写测试合约<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.17</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"truffle/Assert.sol"</span>;   <span class="comment">// 引入的断言</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">"truffle/DeployedAddresses.sol"</span>;  <span class="comment">// 用来获取被测试合约的地址</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">"../contracts/Adoption.sol"</span>;      <span class="comment">// 被测试合约</span></span><br><span class="line"></span><br><span class="line">contract TestAdoption &#123;</span><br><span class="line">  Adoption adoption = Adoption(DeployedAddresses.Adoption());</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 领养测试用例</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">testUserCanAdoptPet</span>(<span class="params"></span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">    uint returnedId = adoption.adopt(<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    uint expected = <span class="number">8</span>;</span><br><span class="line">    Assert.equal(returnedId, expected, <span class="string">"Adoption of pet ID 8 should be recorded."</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 宠物所有者测试用例</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">testGetAdopterAddressByPetId</span>(<span class="params"></span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 期望领养者的地址就是本合约地址，因为交易是由测试合约发起交易，</span></span><br><span class="line">    address expected = <span class="keyword">this</span>;</span><br><span class="line">    address adopter = adoption.adopters(<span class="number">8</span>);</span><br><span class="line">    Assert.equal(adopter, expected, <span class="string">"Owner of pet ID 8 should be recorded."</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试所有领养者</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">testGetAdopterAddressByPetIdInArray</span>(<span class="params"></span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 领养者的地址就是本合约地址</span></span><br><span class="line">    address expected = <span class="keyword">this</span>;</span><br><span class="line">    address[<span class="number">16</span>] memory adopters = adoption.getAdopters();</span><br><span class="line">    Assert.equal(adopters[<span class="number">8</span>], expected, <span class="string">"Owner of pet ID 8 should be recorded."</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Assert.sol 及 DeployedAddresses.sol是Truffle框架提供，在test目录下并不提供truffle目录。</p><p>TestAdoption合约中添加adopt的测试用例</p><h3 id="运行测试用例"><a href="#运行测试用例" class="headerlink" title="运行测试用例"></a>运行测试用例</h3><p>在终端中，执行<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">truffle <span class="built_in">test</span></span><br></pre></td></tr></table></figure></p><p>如果测试通过，则终端输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Using network &apos;develop&apos;.</span><br><span class="line"></span><br><span class="line">Compiling ./contracts/Adoption.sol...</span><br><span class="line">Compiling ./test/TestAdoption.sol...</span><br><span class="line">Compiling truffle/Assert.sol...</span><br><span class="line">Compiling truffle/DeployedAddresses.sol...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  TestAdoption</span><br><span class="line">    ✓ testUserCanAdoptPet (62ms)</span><br><span class="line">    ✓ testGetAdopterAddressByPetId (53ms)</span><br><span class="line">    ✓ testGetAdopterAddressByPetIdInArray (73ms)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  3 passing (554ms)</span><br></pre></td></tr></table></figure></p><h2 id="创建用户接口和智能合约交互"><a href="#创建用户接口和智能合约交互" class="headerlink" title="创建用户接口和智能合约交互"></a>创建用户接口和智能合约交互</h2><p>我们已经编写和部署及测试好了我们的合约，接下我们为合约编写UI，让合约真正可以用起来。</p><p>在Truffle Box <code>pet-shop</code>里，已经包含了应用的前端代码，代码在<code>src/</code>文件夹下。</p><p>在编辑器中打开<code>src/js/app.js</code><br>可以看到用来管理整个应用的App对象，init函数加载宠物信息，就初始化<a href="https://github.com/ethereum/web3.js/" target="_blank" rel="noopener">web3</a>.<br>web3是一个实现了与以太坊节点通信的库，我们利用web3来和合约进行交互。</p><h3 id="初始化web3"><a href="#初始化web3" class="headerlink" title="初始化web3"></a>初始化web3</h3><p>接下来，我们来编辑app.js修改initWeb3():<br>删除注释，修改为：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">initWeb3: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Is there an injected web3 instance?</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> web3 !== <span class="string">'undefined'</span>) &#123;</span><br><span class="line">    App.web3Provider = web3.currentProvider;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// If no injected web3 instance is detected, fall back to Ganache</span></span><br><span class="line">    App.web3Provider = <span class="keyword">new</span> Web3.providers.HttpProvider(<span class="string">'http://localhost:7545'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  web3 = <span class="keyword">new</span> Web3(App.web3Provider);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> App.initContract();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>代码中优先使用<a href="https://github.com/ethereum/mist" target="_blank" rel="noopener">Mist</a> 或 <a href="https://metamask.io/" target="_blank" rel="noopener">MetaMask</a>提供的web3实例，如果没有则从本地环境创建一个。</p><h3 id="实例化合约"><a href="#实例化合约" class="headerlink" title="实例化合约"></a>实例化合约</h3><p>使用truffle-contract会帮我们保存合约部署的信息，就不需要我们手动修改合约地址，修改initContract()代码如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">initContract: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 加载Adoption.json，保存了Adoption的ABI（接口说明）信息及部署后的网络(地址)信息，它在编译合约的时候生成ABI，在部署的时候追加网络信息</span></span><br><span class="line">  $.getJSON(<span class="string">'Adoption.json'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 用Adoption.json数据创建一个可交互的TruffleContract合约实例。</span></span><br><span class="line">    <span class="keyword">var</span> AdoptionArtifact = data;</span><br><span class="line">    App.contracts.Adoption = TruffleContract(AdoptionArtifact);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set the provider for our contract</span></span><br><span class="line">    App.contracts.Adoption.setProvider(App.web3Provider);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Use our contract to retrieve and mark the adopted pets</span></span><br><span class="line">    <span class="keyword">return</span> App.markAdopted();</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> App.bindEvents();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="处理领养"><a href="#处理领养" class="headerlink" title="处理领养"></a>处理领养</h3><p>修改markAdopted()代码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">markAdopted: <span class="function"><span class="keyword">function</span>(<span class="params">adopters, account</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> adoptionInstance;</span><br><span class="line"></span><br><span class="line">  App.contracts.Adoption.deployed().then(<span class="function"><span class="keyword">function</span>(<span class="params">instance</span>) </span>&#123;</span><br><span class="line">    adoptionInstance = instance;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用合约的getAdopters(), 用call读取信息不用消耗gas</span></span><br><span class="line">    <span class="keyword">return</span> adoptionInstance.getAdopters.call();</span><br><span class="line">  &#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">adopters</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; adopters.length; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (adopters[i] !== <span class="string">'0x0000000000000000000000000000000000000000'</span>) &#123;</span><br><span class="line">        $(<span class="string">'.panel-pet'</span>).eq(i).find(<span class="string">'button'</span>).text(<span class="string">'Success'</span>).attr(<span class="string">'disabled'</span>, <span class="literal">true</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err.message);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>修改handleAdopt()代码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">handleAdopt: <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  event.preventDefault();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> petId = <span class="built_in">parseInt</span>($(event.target).data(<span class="string">'id'</span>));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> adoptionInstance;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取用户账号</span></span><br><span class="line">  web3.eth.getAccounts(<span class="function"><span class="keyword">function</span>(<span class="params">error, accounts</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (error) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(error);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">var</span> account = accounts[<span class="number">0</span>];</span><br><span class="line">  </span><br><span class="line">    App.contracts.Adoption.deployed().then(<span class="function"><span class="keyword">function</span>(<span class="params">instance</span>) </span>&#123;</span><br><span class="line">      adoptionInstance = instance;</span><br><span class="line">  </span><br><span class="line">      <span class="comment">// 发送交易领养宠物</span></span><br><span class="line">      <span class="keyword">return</span> adoptionInstance.adopt(petId, &#123;<span class="attr">from</span>: account&#125;);</span><br><span class="line">    &#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">result</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> App.markAdopted();</span><br><span class="line">    &#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(err.message);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="在浏览器中运行"><a href="#在浏览器中运行" class="headerlink" title="在浏览器中运行"></a>在浏览器中运行</h2><h3 id="安装-MetaMask"><a href="#安装-MetaMask" class="headerlink" title="安装 MetaMask"></a>安装 MetaMask</h3><p>MetaMask 是一款插件形式的以太坊轻客户端，开发过程中使用MetaMask和我们的dapp进行交互是个很好的选择，通过此<a href="https://metamask.io/" target="_blank" rel="noopener">链接</a>安装，安装完成后，浏览器工具条会显示一个小狐狸图标。</p><h3 id="配置钱包"><a href="#配置钱包" class="headerlink" title="配置钱包"></a>配置钱包</h3><p>在接受隐私说明后，会出现页面如下：<br><img src="https://learnblockchain.cn/images/metamask-initial.png" alt=""></p><p>这里我们通过还原一个Ganache为我们创建好的钱包，作为我们的开发测试钱包。点击页面的<strong> Import Existing DEN</strong>，输入Ganache显示的助记词。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">candy maple cake sugar pudding cream honey rich smooth crumble sweet treat</span><br></pre></td></tr></table></figure></p><p>然后自己想要的密码，点击OK。<br>如图：<br><img src="https://learnblockchain.cn/images/metamask-seed.png" alt=""></p><h3 id="连接开发区块链网络"><a href="#连接开发区块链网络" class="headerlink" title="连接开发区块链网络"></a>连接开发区块链网络</h3><p>默认连接的是以太坊主网（左上角显示），选择<strong>Custom RPC</strong>，添加一个网络：<strong><a href="http://127.0.0.1:7545" target="_blank" rel="noopener">http://127.0.0.1:7545</a></strong>，点返回后，显示如下：<br><img src="/images/metamask-account1.png" alt=""><br>这是左上角显示为<strong>Private Network</strong>，账号是Ganache中默认的第一个账号。</p><p>至此MetaMask的安装，配置已经完成。</p><h3 id="安装和配置lite-server"><a href="#安装和配置lite-server" class="headerlink" title="安装和配置lite-server"></a>安装和配置lite-server</h3><p>接下来需要本地的web 服务器提供服务的访问， Truffle Box <strong>pet-shop</strong>里提供了一个<strong>lite-server</strong>可以直接使用，我们看看它是如何工作的。<br><strong>bs-config.json</strong>指示了lite-server的工作目录。<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"server"</span>: &#123;</span><br><span class="line">    <span class="attr">"baseDir"</span>: [<span class="string">"./src"</span>, <span class="string">"./build/contracts"</span>]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>./src 是网站文件目录<br>./build/contracts 是合约输出目录</p><p>以此同时，在package.json文件的scripts中添加了dev命令：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">"scripts": &#123;</span><br><span class="line">  "dev": "lite-server",</span><br><span class="line">  "test": "echo \"Error: no test specified\" &amp;&amp; exit 1"</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></p><p>当运行npm run dev的时候，就会启动lite-server</p><h3 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; npm run dev</span><br></pre></td></tr></table></figure><p>会自动打开浏览器显示我们的dapp，如本文的第一张图。<br>现在领养一直宠物看看，当我们点击<strong>Adopt</strong>时，MetaMask会提示我们交易的确认，如图：</p><p><img src="https://learnblockchain.cn/images/metamask-transactionconfirm.png" alt=""></p><p>点击Submit确认后，就可以看到成功领养了这次宠物。</p><p>在MetaMask中，也可以看到交易的清单：<br><img src="https://learnblockchain.cn/images/metamask-transactionsuccess.png" alt=""></p><p>好了，恭喜你，即将成为一名去中心化式应用开发者的你已经成为迈出了坚实的一步。<br>如果学习中遇到问题，欢迎来我的<strong><a href="https://t.xiaomiquan.com/RfAu7uj" target="_blank" rel="noopener">知识星球</a></strong>交流。</p><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul><li><a href="http://truffleframework.com/tutorials/pet-shop" target="_blank" rel="noopener">Truffle手册</a></li></ul><p><a href="https://learnblockchain.cn/">深入浅出区块链</a> - 系统学习区块链，打造最好的区块链技术博客。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天我们来编写一个完整的去中心化（区块链）应用（Dapps）, 本文可以和&lt;a href=&quot;https://learnblockchain.cn/2017/11/24/init-env/&quot;&gt;编写智能合约&lt;/a&gt;结合起来看。&lt;/p&gt;
    
    </summary>
    
      <category term="以太坊" scheme="https://learnblockchain.cn/categories/ethereum/"/>
    
      <category term="Dapp" scheme="https://learnblockchain.cn/categories/ethereum/Dapp/"/>
    
    
      <category term="Dapp入门" scheme="https://learnblockchain.cn/tags/Dapp%E5%85%A5%E9%97%A8/"/>
    
      <category term="以太坊概念" scheme="https://learnblockchain.cn/tags/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%A6%82%E5%BF%B5/"/>
    
  </entry>
  
  <entry>
    <title>一步步教你创建自己的数字货币（代币）进行ICO</title>
    <link href="https://learnblockchain.cn/2018/01/12/create_token/"/>
    <id>https://learnblockchain.cn/2018/01/12/create_token/</id>
    <published>2018-01-12T14:36:39.000Z</published>
    <updated>2018-01-22T08:33:39.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文从技术角度详细介绍如何基于以太坊ERC20创建代币的流程.</p><a id="more"></a><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>本文所讲的代币是使用以太坊智能合约创建，阅读本文前，你应该对以太坊、智能合约有所了解，如果你还不了解，建议你先看<a href="https://learnblockchain.cn/2017/11/20/whatiseth/">以太坊是什么</a></p><h2 id="代币Token"><a href="#代币Token" class="headerlink" title="代币Token"></a>代币Token</h2><p>如果不那么追求精确的定义，代币就是数字货币，比特币、以太币就是一个代币。<br>利用以太坊的智能合约可以轻松编写出属于自己的代币，代币可以代表任何可以交易的东西，如：积分、财产、证书等等。<br>因此不管是出于商业，还是学习很多人想创建一个自己的代币，先贴一个图看看创建的代币是什么样子。<br><img src="https://learnblockchain.cn/images/token_info.jpeg" alt=""></p><p>今天我们就来详细讲一讲怎样创建一个这样的代币。</p><h3 id="ERC20-Token"><a href="#ERC20-Token" class="headerlink" title="ERC20 Token"></a>ERC20 Token</h3><p>也许你经常看到ERC20和代币一同出现， ERC20是以太坊定义的一个<a href="https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md" target="_blank" rel="noopener">代币标准</a>。<br>要求我们在实现代币的时候必须要遵守的协议，如指定代币名称、总量、实现代币交易函数等，只有支持了协议才能被以太坊钱包支持。<br>其接口如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">contract ERC20Interface &#123;</span><br><span class="line"></span><br><span class="line">    string public constant name = <span class="string">"Token Name"</span>;</span><br><span class="line">    string public constant symbol = <span class="string">"SYM"</span>;</span><br><span class="line">    uint8 public constant decimals = <span class="number">18</span>;  <span class="comment">// 18 is the most common number of decimal places</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">totalSupply</span>(<span class="params"></span>) <span class="title">public</span> <span class="title">constant</span> <span class="title">returns</span> (<span class="params">uint</span>);</span></span><br><span class="line"><span class="function">    <span class="title">function</span> <span class="title">balanceOf</span>(<span class="params">address tokenOwner</span>) <span class="title">public</span> <span class="title">constant</span> <span class="title">returns</span> (<span class="params">uint balance</span>);</span></span><br><span class="line"><span class="function">    <span class="title">function</span> <span class="title">allowance</span>(<span class="params">address tokenOwner, address spender</span>) <span class="title">public</span> <span class="title">constant</span> <span class="title">returns</span> (<span class="params">uint remaining</span>);</span></span><br><span class="line"><span class="function">    <span class="title">function</span> <span class="title">transfer</span>(<span class="params">address to, uint tokens</span>) <span class="title">public</span> <span class="title">returns</span> (<span class="params">bool success</span>);</span></span><br><span class="line"><span class="function">    <span class="title">function</span> <span class="title">approve</span>(<span class="params">address spender, uint tokens</span>) <span class="title">public</span> <span class="title">returns</span> (<span class="params">bool success</span>);</span></span><br><span class="line"><span class="function">    <span class="title">function</span> <span class="title">transferFrom</span>(<span class="params">address from, address to, uint tokens</span>) <span class="title">public</span> <span class="title">returns</span> (<span class="params">bool success</span>);</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="title">event</span> <span class="title">Transfer</span>(<span class="params">address indexed from, address indexed to, uint tokens</span>);</span></span><br><span class="line"><span class="function">    <span class="title">event</span> <span class="title">Approval</span>(<span class="params">address indexed tokenOwner, address indexed spender, uint tokens</span>);</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure><p>简单说明一下：<br>name ：  代币名称<br>symbol： 代币符号<br>decimals： 代币小数点位数，代币的最小单位， 18表示我们可以拥有 .0000000000000000001单位个代币。<br>totalSupply() : 发行代币总量。<br>balanceOf(): 查看对应账号的代币余额。<br>transfer(): 实现代币交易，用于给用户发送代币（从我们的账户里）。<br>transferFrom():  实现代币用户之间的交易。<br>allowance(): 控制代币的交易，如可交易账号及资产。<br>approve():  允许用户可花费的代币数。</p><h2 id="编写代币合约代码"><a href="#编写代币合约代码" class="headerlink" title="编写代币合约代码"></a>编写代币合约代码</h2><p>代币合约代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.16</span>;</span><br><span class="line"></span><br><span class="line">interface tokenRecipient &#123; <span class="function"><span class="keyword">function</span> <span class="title">receiveApproval</span>(<span class="params">address _from, uint256 _value, address _token, bytes _extraData</span>) <span class="title">public</span>; &#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">contract</span> <span class="title">TokenERC20</span> </span>&#123;</span><br><span class="line">    string public name;</span><br><span class="line">    string public symbol;</span><br><span class="line">    uint8 public decimals = <span class="number">18</span>;  <span class="comment">// 18 是建议的默认值</span></span><br><span class="line">    uint256 public totalSupply;</span><br><span class="line"></span><br><span class="line">    mapping (<span class="function"><span class="params">address</span> =&gt;</span> uint256) public balanceOf;  <span class="comment">// </span></span><br><span class="line">    mapping (<span class="function"><span class="params">address</span> =&gt;</span> mapping (<span class="function"><span class="params">address</span> =&gt;</span> uint256)) public allowance;</span><br><span class="line"></span><br><span class="line">    event Transfer(address indexed <span class="keyword">from</span>, address indexed to, uint256 value);</span><br><span class="line"></span><br><span class="line">    event Burn(address indexed <span class="keyword">from</span>, uint256 value);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">TokenERC20</span>(<span class="params">uint256 initialSupply, string tokenName, string tokenSymbol</span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">        totalSupply = initialSupply * <span class="number">10</span> ** uint256(decimals);</span><br><span class="line">        balanceOf[msg.sender] = totalSupply;</span><br><span class="line">        name = tokenName;</span><br><span class="line">        symbol = tokenSymbol;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">_transfer</span>(<span class="params">address _from, address _to, uint _value</span>) <span class="title">internal</span> </span>&#123;</span><br><span class="line">        <span class="built_in">require</span>(_to != <span class="number">0x0</span>);</span><br><span class="line">        <span class="built_in">require</span>(balanceOf[_from] &gt;= _value);</span><br><span class="line">        <span class="built_in">require</span>(balanceOf[_to] + _value &gt; balanceOf[_to]);</span><br><span class="line">        uint previousBalances = balanceOf[_from] + balanceOf[_to];</span><br><span class="line">        balanceOf[_from] -= _value;</span><br><span class="line">        balanceOf[_to] += _value;</span><br><span class="line">        Transfer(_from, _to, _value);</span><br><span class="line">        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">transfer</span>(<span class="params">address _to, uint256 _value</span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">        _transfer(msg.sender, _to, _value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">transferFrom</span>(<span class="params">address _from, address _to, uint256 _value</span>) <span class="title">public</span> <span class="title">returns</span> (<span class="params">bool success</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">require</span>(_value &lt;= allowance[_from][msg.sender]);     <span class="comment">// Check allowance</span></span><br><span class="line">        allowance[_from][msg.sender] -= _value;</span><br><span class="line">        _transfer(_from, _to, _value);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">approve</span>(<span class="params">address _spender, uint256 _value</span>) <span class="title">public</span></span></span><br><span class="line"><span class="function">        <span class="title">returns</span> (<span class="params">bool success</span>) </span>&#123;</span><br><span class="line">        allowance[msg.sender][_spender] = _value;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">approveAndCall</span>(<span class="params">address _spender, uint256 _value, bytes _extraData</span>) <span class="title">public</span> <span class="title">returns</span> (<span class="params">bool success</span>) </span>&#123;</span><br><span class="line">        tokenRecipient spender = tokenRecipient(_spender);</span><br><span class="line">        <span class="keyword">if</span> (approve(_spender, _value)) &#123;</span><br><span class="line">            spender.receiveApproval(msg.sender, _value, <span class="keyword">this</span>, _extraData);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">burn</span>(<span class="params">uint256 _value</span>) <span class="title">public</span> <span class="title">returns</span> (<span class="params">bool success</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">require</span>(balanceOf[msg.sender] &gt;= _value);</span><br><span class="line">        balanceOf[msg.sender] -= _value;</span><br><span class="line">        totalSupply -= _value;</span><br><span class="line">        Burn(msg.sender, _value);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">burnFrom</span>(<span class="params">address _from, uint256 _value</span>) <span class="title">public</span> <span class="title">returns</span> (<span class="params">bool success</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">require</span>(balanceOf[_from] &gt;= _value);</span><br><span class="line">        <span class="built_in">require</span>(_value &lt;= allowance[_from][msg.sender]);</span><br><span class="line">        balanceOf[_from] -= _value;</span><br><span class="line">        allowance[_from][msg.sender] -= _value;</span><br><span class="line">        totalSupply -= _value;</span><br><span class="line">        Burn(_from, _value);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码的详细解读，请订阅我的<a href="https://xiaozhuanlan.com/blockchaincore" target="_blank" rel="noopener">小专栏</a>。</p><h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><p>在开发测试智能合约时，<a href="https://metamask.io/" target="_blank" rel="noopener">MetaMask</a>和<a href="https://remix.ethereum.org" target="_blank" rel="noopener">Remix Solidity IDE</a>是两个非常好用的工具，今天就用他们来完成部署。</p><ol><li><p>安装和配置MetaMask请参考<a href="https://learnblockchain.cn/2018/01/12/first-dapp">开发、部署第一个去中心化应用</a>，不同的上本文选择了以太坊的测试网络Ropsten，如果你没有余额请点击购买buy，进入的网站可以送一些测试以太币给你，配置好之后，界面应该如下：<br><img src="https://learnblockchain.cn/images/metamask_main.png" alt=""></p></li><li><p>浏览器打开Remix Solidity IDE，复制以上源码粘贴上，在右侧选项参考如图的设置：<br><img src="https://learnblockchain.cn/images/token_create_remix.jpeg" alt=""><br>注意Environment和Account和MetaMask保持一致，然后选择合约TokenERC20，填入你想要的发行量，名称及代号，就可以创建合约了。<br>这时MetaMask会弹出一个交易确认框，点SUBMIT。待合约部署交易确认之后，复制合约地址。</p></li><li><p>打开Metamask界面，切换到TOKENS，点添加合约，出现如下对话框：<br><img src="https://learnblockchain.cn/images/metamask_add_token.png" alt=""><br>填入刚刚复制的地址，点ADD，这时你就可以看到你创建的代币了，如图：<br><img src="https://learnblockchain.cn/images/metamask_token_added.png" alt=""></p></li></ol><p>哈哈，你已经完成了代币的创建和部署(正式网络和测试网络部署方法一样)，可以在<a href="https://ropsten.etherscan.io/token/0x1f0c085ad323bb69758111cf9ecdc32a32d9a5bb" target="_blank" rel="noopener">Etherscan</a>查询到我们刚刚部署的代币。可以用它进行ICO了，从此走上人生巅峰（玩笑话，不鼓励大家发行无意义的代币）。</p><h2 id="代币交易"><a href="#代币交易" class="headerlink" title="代币交易"></a>代币交易</h2><p>由于MetaMask插件没有提供代币交易功能，同时考虑到很多人并没有以太坊钱包或是被以太坊钱包网络同步问题折磨，今天我用<a href="https://www.myetherwallet.com" target="_blank" rel="noopener">网页钱包</a>来讲解代币交易。</p><ol><li>进入<a href="https://www.myetherwallet.com/#send-transaction" target="_blank" rel="noopener">网页钱包地址</a>, 第一次进入有一些安全提示需要用户确认。</li><li>进入之后，按照下图进行设置：<br><img src="https://learnblockchain.cn/images/myetherwaller.jpeg" alt=""></li><li>连接上之后，如图<br><img src="https://learnblockchain.cn/images/myetherwaller_connected.jpeg" alt=""><br>需要添加代币，填入代币合约地址。</li><li>进行代币转账交易<br><img src="https://learnblockchain.cn/images/myetherwaller_transfer.jpeg" alt=""><br>在接下来的交易确认也，点击确认即可。</li><li>交易完成后，可以看到MetaMask中代币余额减少了，如图：<br><img src="https://learnblockchain.cn/images/metamask_token_tansfered.png" alt=""></li></ol><p>代币交易是不是很简单，只要明白了交易流程，使用其他的钱包也是一样的道理。</p><p>如果你在创建代币的过程中遇到问题，我的<strong><a href="https://t.xiaomiquan.com/RfAu7uj" target="_blank" rel="noopener">知识星球</a></strong>可为大家解答问题。</p><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul><li><a href="https://theethereum.wiki/w/index.php/ERC20_Token_Standard" target="_blank" rel="noopener">代币标准</a></li><li><a href="https://ethereum.org/token" target="_blank" rel="noopener">Create your own crypto-currency with ethereum</a></li></ul><p><a href="https://learnblockchain.cn/">深入浅出区块链</a> - 系统学习区块链，打造最好的区块链技术博客。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文从技术角度详细介绍如何基于以太坊ERC20创建代币的流程.&lt;/p&gt;
    
    </summary>
    
      <category term="以太坊" scheme="https://learnblockchain.cn/categories/ethereum/"/>
    
      <category term="Dapp" scheme="https://learnblockchain.cn/categories/ethereum/Dapp/"/>
    
    
      <category term="Dapp入门" scheme="https://learnblockchain.cn/tags/Dapp%E5%85%A5%E9%97%A8/"/>
    
      <category term="以太坊概念" scheme="https://learnblockchain.cn/tags/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%A6%82%E5%BF%B5/"/>
    
  </entry>
  
  <entry>
    <title>区块链技术学习指引</title>
    <link href="https://learnblockchain.cn/2018/01/11/guide/"/>
    <id>https://learnblockchain.cn/2018/01/11/guide/</id>
    <published>2018-01-11T07:03:36.000Z</published>
    <updated>2018-01-23T08:44:07.000Z</updated>
    
    <content type="html"><![CDATA[<p>原本这篇文章是在我的<a href="https://wiki.learnblockchain.cn/" target="_blank" rel="noopener">wiki</a>里，发现好多同学还是找不到，那就重新发一下。本文会一直更新，建议感兴趣的同学加入收藏夹。</p><a id="more"></a><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>给迷失在如何学习区块链技术的同学一个指引，区块链技术是随比特币诞生，因此要搞明白区块链技术，应该先了解下比特币。<br>但区块链技术不单应用于比特币，还有非常多的现实应用场景，想做区块链应用开发，可进一步阅读以太坊系列。</p><h2 id="比特币"><a href="#比特币" class="headerlink" title="比特币"></a>比特币</h2><p>如果你是还不知比特币是什么，那就看看<a href="https://learnblockchain.cn/2017/10/23/whatisbitcoin/">比特币是什么</a></p><h3 id="基础入门"><a href="#基础入门" class="headerlink" title="基础入门"></a>基础入门</h3><p>接下来可以通过下面这几篇文章了解比特币大概的运行原理：</p><ul><li><a href="https://learnblockchain.cn/2017/10/25/whatbc/">区块链记账原理</a><br> 通过这篇可以了解到区块链是一个怎样的结构</li><li><a href="https://learnblockchain.cn/2017/11/02/bitcoin-own/">比特币所有权及隐私问题</a><br> 通过这篇可以了解到地址私钥 非对称加密应用 等概念</li><li><a href="https://learnblockchain.cn/2017/11/04/bitcoin-pow/">比特币如何挖矿</a><br> 通过这篇了解工作量证明</li><li><a href="https://learnblockchain.cn/2017/12/07/bitcoin-sonsensus/">比特币如何达成共识 - 最长链的选择</a><br> 通过这篇可以了解共识机制。</li></ul><h3 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h3><p>在基础入门之后，可以进一步阅读以下几篇，理解分布式网络，交易验证。</p><ul><li><a href="https://learnblockchain.cn/2017/11/07/bitcoin-p2p/">分析比特币网络：一种去中心化、点对点的网络架构</a></li><li><a href="https://learnblockchain.cn/2017/11/10/bitcoin-script/">比特币区块结构 Merkle 树及简单支付验证分析</a></li><li><a href="https://xiaozhuanlan.com/topic/1402935768" target="_blank" rel="noopener">比特币脚本及交易分析 - 智能合约雏形</a></li></ul><p>看完上面这些，区块链应该理解差不多了，就可以尝试实现一个简单的区块链了。参考这篇<a href="https://learnblockchain.cn/2017/10/27/build_blockchain_by_python/">用Python从零开始创建区块链</a>。</p><h2 id="以太坊"><a href="#以太坊" class="headerlink" title="以太坊"></a>以太坊</h2><p>一个技术要落地还得靠应用， 以太坊就这样一个建立在区块链技术之上， 去中心化的应用平台。可以阅读几下几篇，这部分以开发为主，需要大家多发时间实践。</p><ul><li><a href="https://learnblockchain.cn/2017/11/20/whatiseth/">以太坊开发入门</a></li><li><a href="https://learnblockchain.cn/2017/11/24/init-env/">智能合约开发环境搭建及Hello World合约</a></li><li><a href="https://learnblockchain.cn/2017/11/29/geth_cmd_options">以太坊客户端Geth命令用法-参数详解</a></li><li><a href="https://learnblockchain.cn/2017/12/01/geth_cmd_short/">Geth控制台使用实战及Web3.js使用</a></li><li><a href="https://learnblockchain.cn/2018/01/12/first-dapp/">一步步教你开发、部署第一个Dapp应用</a></li><li><a href="https://learnblockchain.cn/2018/01/12/create_token/">一步步教你创建自己的数字货币（代币）进行ICO</a></li></ul><h3 id="智能合约开发"><a href="#智能合约开发" class="headerlink" title="智能合约开发"></a>智能合约开发</h3><p>Solidity语言是开发智能合约最广泛的语言，本专栏应该是国内最深度介绍Solidity的文章了。</p><ul><li><a href="https://learnblockchain.cn/2017/12/05/solidity1/">Solidity 教程系列1 - 类型介绍</a></li><li><a href="https://learnblockchain.cn/2017/12/12/solidity2/">Solidity 教程系列2 - 地址类型介绍</a></li><li><a href="https://learnblockchain.cn/2017/12/12/solidity_func/">Solidity 教程系列3 - 函数类型介绍</a></li><li><a href="https://learnblockchain.cn/2017/12/21/solidity_reftype_datalocation/">Solidity 教程系列4 - 数据存储位置分析</a></li><li><a href="https://learnblockchain.cn/2017/12/21/solidity-arrays/">Solidity 教程系列5 - 数组介绍</a></li><li><a href="https://learnblockchain.cn/2017/12/27/solidity-structs/">Solidity 教程系列6 - 结构体与映射</a></li></ul><p>区块链技术付费交流群已建立，有需要加入的同学请加微信：xlbxiong</p><p><a href="https://learnblockchain.cn/">深入浅出区块链</a> - 系统学习区块链，打造最好的区块链技术博客。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;原本这篇文章是在我的&lt;a href=&quot;https://wiki.learnblockchain.cn/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;wiki&lt;/a&gt;里，发现好多同学还是找不到，那就重新发一下。本文会一直更新，建议感兴趣的同学加入收藏夹。&lt;/p&gt;
    
    </summary>
    
      <category term="目录" scheme="https://learnblockchain.cn/categories/%E7%9B%AE%E5%BD%95/"/>
    
    
      <category term="如何学习" scheme="https://learnblockchain.cn/tags/%E5%A6%82%E4%BD%95%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="目录" scheme="https://learnblockchain.cn/tags/%E7%9B%AE%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>智能合约语言 Solidity 教程系列6 - 结构体与映射</title>
    <link href="https://learnblockchain.cn/2017/12/27/solidity-structs/"/>
    <id>https://learnblockchain.cn/2017/12/27/solidity-structs/</id>
    <published>2017-12-27T03:55:26.000Z</published>
    <updated>2018-01-10T08:11:49.019Z</updated>
    
    <content type="html"><![CDATA[<p>Solidity 教程系列第6篇 - Solidity 结构体与映射。</p><a id="more"></a><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>Solidity 是以太坊智能合约编程语言，阅读本文前，你应该对以太坊、智能合约有所了解，<br>如果你还不了解，建议你先看<a href="https://learnblockchain.cn/2017/11/20/whatiseth/">以太坊是什么</a></p><p>本系列文章一部分是参考Solidity官方文档（当前最新版本：0.4.20）进行翻译，另一部分是Solidity深入分析，这部分请订阅<a href="https://xiaozhuanlan.com/blockchaincore" target="_blank" rel="noopener">区块链技术专栏</a>阅读。</p><h2 id="结构体-Structs"><a href="#结构体-Structs" class="headerlink" title="结构体(Structs)"></a>结构体(Structs)</h2><p>Solidity提供<strong>struct</strong>来定义自定义类型，自定义的类型是引用类型。<br>我们看看下面的例子：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.11</span>;</span><br><span class="line"></span><br><span class="line">contract CrowdFunding &#123;</span><br><span class="line">    <span class="comment">// 定义一个包含两个成员的新类型</span></span><br><span class="line">    struct Funder &#123;</span><br><span class="line">        address addr;</span><br><span class="line">        uint amount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    struct Campaign &#123;</span><br><span class="line">        address beneficiary;</span><br><span class="line">        uint fundingGoal;</span><br><span class="line">        uint numFunders;</span><br><span class="line">        uint amount;</span><br><span class="line">        mapping (<span class="function"><span class="params">uint</span> =&gt;</span> Funder) funders;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    uint numCampaigns;</span><br><span class="line">    mapping (<span class="function"><span class="params">uint</span> =&gt;</span> Campaign) campaigns;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">newCampaign</span>(<span class="params">address beneficiary, uint goal</span>) <span class="title">public</span> <span class="title">returns</span> (<span class="params">uint campaignID</span>) </span>&#123;</span><br><span class="line">        campaignID = numCampaigns++; <span class="comment">// campaignID 作为一个变量返回</span></span><br><span class="line">        <span class="comment">// 创建一个结构体实例，存储在storage ，放入mapping里</span></span><br><span class="line">        campaigns[campaignID] = Campaign(beneficiary, goal, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">contribute</span>(<span class="params">uint campaignID</span>) <span class="title">public</span> <span class="title">payable</span> </span>&#123;</span><br><span class="line">        Campaign storage c = campaigns[campaignID];</span><br><span class="line">        <span class="comment">// 用mapping对应项创建一个结构体引用</span></span><br><span class="line">        <span class="comment">// 也可以用 Funder(msg.sender, msg.value) 来初始化.</span></span><br><span class="line">        c.funders[c.numFunders++] = Funder(&#123;<span class="attr">addr</span>: msg.sender, <span class="attr">amount</span>: msg.value&#125;);</span><br><span class="line">        c.amount += msg.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">checkGoalReached</span>(<span class="params">uint campaignID</span>) <span class="title">public</span> <span class="title">returns</span> (<span class="params">bool reached</span>) </span>&#123;</span><br><span class="line">        Campaign storage c = campaigns[campaignID];</span><br><span class="line">        <span class="keyword">if</span> (c.amount &lt; c.fundingGoal)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        uint amount = c.amount;</span><br><span class="line">        c.amount = <span class="number">0</span>;</span><br><span class="line">        c.beneficiary.transfer(amount);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面是一个简化版的众筹合约，但它可以让我们理解<strong>structs</strong>的基础概念，<strong>struct</strong>可以用于映射和数组中作为元素。其本身也可以包含映射和数组等类型。</p><p>不能声明一个struct同时将自身struct作为成员，这个限制是基于结构体的大小必须是有限的。<br>但<strong>struct</strong>可以作为<strong>mapping</strong>的值类型成员。</p><p>注意在函数中，将一个<strong>struct</strong>赋值给一个局部变量（默认是storage类型），实际是拷贝的引用，所以修改局部变量值的同时，会影响到原变量。</p><p>当然，也可以直接通过访问成员修改值，而不用一定赋值给一个局部变量，如campaigns[campaignID].amount = 0</p><h2 id="映射-Mappings"><a href="#映射-Mappings" class="headerlink" title="映射(Mappings)"></a>映射(Mappings)</h2><p>映射类型，一种键值对的映射关系存储结构。定义方式为mapping(_KeyType =&gt; _KeyValue)。键类型允许除映射、变长数组、合约、枚举、结构体外的几乎所有类型（）。值类型没有任何限制，可以为任何类型包括映射类型。</p><p><strong>映射</strong>可以被视作为一个哈希表，所有可能的键会被虚拟化的创建，映射到一个类型的默认值（二进制的全零表示）。在映射表中，并不存储键的数据，仅仅存储它的keccak256哈希值，这个哈希值在查找值时需要用到。<br>正因为此，<strong>映射</strong>是没有长度的，也没有键集合或值集合的概念。</p><p><strong>映射类型</strong>，仅能用来作为状态变量，或在内部函数中作为<strong>storage</strong>类型的引用。</p><p>可以通过将映射标记为public，来让Solidity创建一个访问器。通过提供一个键值做为参数来访问它，将返回对应的值。<br>映射的值类型也可以是映射，使用访问器访问时，要提供这个映射值所对应的键，不断重复这个过程。<br>来看一个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract MappingExample &#123;</span><br><span class="line">    mapping(<span class="function"><span class="params">address</span> =&gt;</span> uint) public balances;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">update</span>(<span class="params">uint newBalance</span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">        balances[msg.sender] = newBalance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract MappingUser &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) <span class="title">public</span> <span class="title">returns</span> (<span class="params">uint</span>) </span>&#123;</span><br><span class="line">        MappingExample m = <span class="keyword">new</span> MappingExample();</span><br><span class="line">        m.update(<span class="number">100</span>);</span><br><span class="line">        <span class="keyword">return</span> m.balances(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：<br>映射并未提供迭代输出的方法，可以自行实现一个这样的数据结构。参考<a href="https://github.com/ethereum/dapp-bin/blob/master/library/iterable_mapping.sol" target="_blank" rel="noopener">iterable mapping</a></p><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="https://solidity.readthedocs.io/en/develop/types.html#mappings" target="_blank" rel="noopener">Solidity官方文档</a></p><p><a href="https://learnblockchain.cn/">深入浅出区块链</a> - 系统学习区块链，打造最好的区块链技术博客。<br>我的<strong><a href="https://t.xiaomiquan.com/RfAu7uj" target="_blank" rel="noopener">知识星球</a></strong>为各位解答区块链技术问题，欢迎加入讨论。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Solidity 教程系列第6篇 - Solidity 结构体与映射。&lt;/p&gt;
    
    </summary>
    
      <category term="以太坊" scheme="https://learnblockchain.cn/categories/ethereum/"/>
    
      <category term="Solidity" scheme="https://learnblockchain.cn/categories/ethereum/Solidity/"/>
    
    
      <category term="Solidity手册" scheme="https://learnblockchain.cn/tags/Solidity%E6%89%8B%E5%86%8C/"/>
    
  </entry>
  
  <entry>
    <title>智能合约语言 Solidity 教程系列5 - 数组介绍</title>
    <link href="https://learnblockchain.cn/2017/12/21/solidity-arrays/"/>
    <id>https://learnblockchain.cn/2017/12/21/solidity-arrays/</id>
    <published>2017-12-21T03:55:18.000Z</published>
    <updated>2018-01-10T08:11:41.472Z</updated>
    
    <content type="html"><![CDATA[<p>Solidity 教程系列第5篇 - Solidity 数组介绍。</p><a id="more"></a><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>Solidity 是以太坊智能合约编程语言，阅读本文前，你应该对以太坊、智能合约有所了解，<br>如果你还不了解，建议你先看<a href="https://learnblockchain.cn/2017/11/20/whatiseth/">以太坊是什么</a></p><p>本文前半部分是参考Solidity官方文档（当前最新版本：0.4.20）进行翻译，后半部分对官方文档中没有提供代码的知识点补充代码说明（订阅<a href="https://xiaozhuanlan.com/blockchaincore" target="_blank" rel="noopener">专栏</a>阅读）。</p><h2 id="数组（Arrays）"><a href="#数组（Arrays）" class="headerlink" title="数组（Arrays）"></a>数组（Arrays）</h2><p>数组可以声明时指定长度，也可以是动态变长。对storage存储的数组来说，元素类型可以是任意的，类型可以是数组，映射类型，结构体等。但对于memory的数组来说。如果作为public函数的参数，它不能是映射类型的数组，只能是支持<a href="https://github.com/ethereum/wiki/wiki/Ethereum-Contract-ABI#types" target="_blank" rel="noopener">ABI的类型</a>。</p><p>一个元素类型为T，固定长度为k的数组，可以声明为<strong>T[k]</strong>，而一个动态大小（变长）的数组则声明为<strong>T[]</strong>。<br>还可以声明一个多维数组，如声明一个类型为uint的数组长度为5的变长数组（5个元素都是变长数组），可以声明为uint[][5]。（注意，相比非区块链语言，多维数组的长度声明是反的。）</p><p>要访问第三个动态数组的第二个元素，使用x[2][1]。数组的序号是从0开始的，序号顺序与定义相反。</p><p><strong>bytes</strong>和<strong>string</strong>是一种特殊的数组。<strong>bytes</strong>类似<strong>byte[]</strong>，但在外部函数作为参数调用中，<strong>bytes</strong>会进行压缩打包。<strong>string</strong>类似<strong>bytes</strong>，但不提供长度和按序号的访问方式（目前）。<br>所以应该尽量使用<strong>bytes</strong>而不是<strong>byte[]</strong>。</p><blockquote><p>可以将字符串s通过bytes(s)转为一个bytes，可以通过<strong>bytes(s).length</strong>获取长度，<strong>bytes(s)[n]</strong>获取对应的UTF-8编码。通过下标访问获取到的不是对应字符，而是UTF-8编码，比如中文编码是多字节，变长的，所以下标访问到的只是其中的一个编码。<br>类型为数组的状态变量，可以标记为<strong>public</strong>，从而让Solidity创建一个访问器，如果要访问数组的某个元素，指定数字下标就好了。（稍后代码事例）</p></blockquote><h2 id="创建内存数组"><a href="#创建内存数组" class="headerlink" title="创建内存数组"></a>创建内存数组</h2><p>可使用new关键字创建一个memory的数组。与stroage数组不同的是，你不能通过.length的长度来修改数组大小属性。我们来看看下面的例子：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.16</span>;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">uint len</span>) <span class="title">public</span> <span class="title">pure</span> </span>&#123;</span><br><span class="line">        uint[] memory a = <span class="keyword">new</span> uint[](<span class="number">7</span>);</span><br><span class="line">                </span><br><span class="line">        <span class="comment">//a.length = 100;  // 错误</span></span><br><span class="line">        bytes memory b = <span class="keyword">new</span> bytes(len);</span><br><span class="line">        <span class="comment">// Here we have a.length == 7 and b.length == len</span></span><br><span class="line">        a[<span class="number">6</span>] = <span class="number">8</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="数组常量及内联数组"><a href="#数组常量及内联数组" class="headerlink" title="数组常量及内联数组"></a>数组常量及内联数组</h2><p>数组常量，是一个数组表达式（还没有赋值到变量）。下面是一个简单的例子：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.16</span>;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) <span class="title">public</span> <span class="title">pure</span> </span>&#123;</span><br><span class="line">        g([uint(<span class="number">1</span>), <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">g</span>(<span class="params">uint[<span class="number">3</span>] _data</span>) <span class="title">public</span> <span class="title">pure</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>通过数组常量，创建的数组是memory的，同时还是定长的。元素类型则是使用刚好能存储的元素的能用类型，比如[1, 2, 3]，只需要uint8即可存储，它的类型是<strong>uint8[3] memory</strong>。</p><p>由于g()方法的参数需要的是uint（默认的uint表示的其实是uint256），所以需要对第一个元素进行类型转换，使用uint(1)来进行这个转换。</p><p>还需注意的一点是，定长数组，不能与变长数组相互赋值，我们来看下面的代码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  无法编译</span></span><br><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">        <span class="comment">// The next line creates a type error because uint[3] memory</span></span><br><span class="line">        <span class="comment">// cannot be converted to uint[] memory.</span></span><br><span class="line">        uint[] x = [uint(<span class="number">1</span>), <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>已经计划在未来移除这样的限制。当前因为ABI传递数组还有些问题。</p><h2 id="成员"><a href="#成员" class="headerlink" title="成员"></a>成员</h2><h3 id="length属性"><a href="#length属性" class="headerlink" title="length属性"></a>length属性</h3><p>数组有一个.length属性，表示当前的数组长度。storage的变长数组，可以通过给.length赋值调整数组长度。memory的变长数组不支持。<br>不能通过访问超出当前数组的长度的方式，来自动实现改变数组长度。memory数组虽然可以通过参数，灵活指定大小，但一旦创建，大小不可调整。</p><h3 id="push方法"><a href="#push方法" class="headerlink" title="push方法"></a>push方法</h3><p>storage的变长数组和bytes都有一个<strong>push</strong>方法（string没有），用于附加新元素到数据末端，返回值为新的长度。</p><h2 id="限制情况"><a href="#限制情况" class="headerlink" title="限制情况"></a>限制情况</h2><p>当前在external函数中，不能使用多维数组。</p><p>另外，基于EVM的限制，不能通过外部函数返回动态的内容。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">contract C &#123;</span><br><span class="line">     <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) <span class="title">returns</span> (<span class="params">uint[]</span>) </span>&#123; ... &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure></p><p>在这个的例子中，如果通过web.js调用能返回数据，但从Solidity中调用不能返回数据。一种绕过这个问题的办法是使用一个非常大的静态数组。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.16</span>;</span><br><span class="line"></span><br><span class="line">contract ArrayContract &#123;</span><br><span class="line">    uint[<span class="number">2</span>**<span class="number">20</span>] m_aLotOfIntegers;</span><br><span class="line">    <span class="comment">// 这里不是两个动态数组的数组，而是一个动态数组里，每个元素是长度为二的数组。</span></span><br><span class="line">    bool[<span class="number">2</span>][] m_pairsOfFlags;</span><br><span class="line">    <span class="comment">// newPairs 存在 memory里，因为是函数参数</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">setAllFlagPairs</span>(<span class="params">bool[<span class="number">2</span>][] newPairs</span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">        m_pairsOfFlags = newPairs;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">setFlagPair</span>(<span class="params">uint index, bool flagA, bool flagB</span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 访问不存在的index会抛出异常</span></span><br><span class="line">        m_pairsOfFlags[index][<span class="number">0</span>] = flagA;</span><br><span class="line">        m_pairsOfFlags[index][<span class="number">1</span>] = flagB;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">changeFlagArraySize</span>(<span class="params">uint newSize</span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果新size更小, 移除的元素会被销毁</span></span><br><span class="line">        m_pairsOfFlags.length = newSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">clear</span>(<span class="params"></span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 销毁</span></span><br><span class="line">        <span class="keyword">delete</span> m_pairsOfFlags;</span><br><span class="line">        <span class="keyword">delete</span> m_aLotOfIntegers;</span><br><span class="line">        <span class="comment">// 同销毁一样的效果</span></span><br><span class="line">        m_pairsOfFlags.length = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bytes m_byteData;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">byteArrays</span>(<span class="params">bytes data</span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">        <span class="comment">// byte arrays ("bytes") are different as they are stored without padding,</span></span><br><span class="line">        <span class="comment">// but can be treated identical to "uint8[]"</span></span><br><span class="line">        m_byteData = data;</span><br><span class="line">        m_byteData.length += <span class="number">7</span>;</span><br><span class="line">        m_byteData[<span class="number">3</span>] = byte(<span class="number">8</span>);</span><br><span class="line">        <span class="keyword">delete</span> m_byteData[<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">addFlag</span>(<span class="params">bool[<span class="number">2</span>] flag</span>) <span class="title">public</span> <span class="title">returns</span> (<span class="params">uint</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_pairsOfFlags.push(flag);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">createMemoryArray</span>(<span class="params">uint size</span>) <span class="title">public</span> <span class="title">pure</span> <span class="title">returns</span> (<span class="params">bytes</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// Dynamic memory arrays are created using `new`:</span></span><br><span class="line">        uint[<span class="number">2</span>][] memory arrayOfPairs = <span class="keyword">new</span> uint[<span class="number">2</span>][](size);</span><br><span class="line">        <span class="comment">// Create a dynamic byte array:</span></span><br><span class="line">        bytes memory b = <span class="keyword">new</span> bytes(<span class="number">200</span>);</span><br><span class="line">        <span class="keyword">for</span> (uint i = <span class="number">0</span>; i &lt; b.length; i++)</span><br><span class="line">            b[i] = byte(i);</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="补充事例说明"><a href="#补充事例说明" class="headerlink" title="补充事例说明"></a>补充事例说明</h2><p>事例代码及讲解，请订阅<a href="https://xiaozhuanlan.com/blockchaincore" target="_blank" rel="noopener">区块链技术</a>查看。</p><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="https://solidity.readthedocs.io/en/develop/types.html#arrays" target="_blank" rel="noopener">Solidity官方文档-数组</a></p><p><a href="https://learnblockchain.cn/">深入浅出区块链</a> - 系统学习区块链，打造最好的区块链技术博客。<br>我的<strong><a href="https://t.xiaomiquan.com/RfAu7uj" target="_blank" rel="noopener">知识星球</a></strong>为各位解答区块链技术问题，欢迎加入讨论。</p><!---<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    </span><br><span class="line">    uint [] public u = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];    <span class="comment">// 生成访问器</span></span><br><span class="line">    string  s = <span class="string">"abcdefg"</span>;</span><br><span class="line"></span><br><span class="line">    uint[] c;  <span class="comment">//storage</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">g</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        c = <span class="keyword">new</span> uint[](<span class="number">7</span>);</span><br><span class="line">        c.length = <span class="number">10</span>;   <span class="comment">//可以修改storage的数组</span></span><br><span class="line">        c[<span class="number">9</span>] = <span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">h</span>(<span class="params"></span>) <span class="title">public</span>  <span class="title">returns</span> (<span class="params">uint</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> bytes(s).length;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) <span class="title">public</span>  <span class="title">returns</span> (<span class="params">byte</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> bytes(s)[<span class="number">1</span>];     <span class="comment">// 转为数组访问</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打开<a href="https://ethereum.github.io/browser-solidity">Remix - Solidity IDE</a>,帖入代码，依次创建合约，如图：<br><img src="/images/testarray.jpg" alt=""></p><p>创建合约后，可以看到public的数组u，生成了对应访问器，可直接访问。</p><p>–&gt;</p>-->]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Solidity 教程系列第5篇 - Solidity 数组介绍。&lt;/p&gt;
    
    </summary>
    
      <category term="以太坊" scheme="https://learnblockchain.cn/categories/ethereum/"/>
    
      <category term="Solidity" scheme="https://learnblockchain.cn/categories/ethereum/Solidity/"/>
    
    
      <category term="Solidity手册" scheme="https://learnblockchain.cn/tags/Solidity%E6%89%8B%E5%86%8C/"/>
    
  </entry>
  
  <entry>
    <title>智能合约语言 Solidity 教程系列4 - 数据存储位置分析</title>
    <link href="https://learnblockchain.cn/2017/12/21/solidity_reftype_datalocation/"/>
    <id>https://learnblockchain.cn/2017/12/21/solidity_reftype_datalocation/</id>
    <published>2017-12-21T03:51:02.000Z</published>
    <updated>2018-01-10T08:11:34.713Z</updated>
    
    <content type="html"><![CDATA[<p>Solidity教程系列第4篇 - Solidity数据位置分析。</p><a id="more"></a><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>Solidity 是以太坊智能合约编程语言，阅读本文前，你应该对以太坊、智能合约有所了解，<br>如果你还不了解，建议你先看<a href="https://learnblockchain.cn/2017/11/20/whatiseth/">以太坊是什么</a></p><p>这部分的内容官方英文文档讲的不是很透，因此我在参考Solidity官方文档（当前最新版本：0.4.20）的同时加入了深入分析部分，欢迎订阅<a href="https://xiaozhuanlan.com/blockchaincore" target="_blank" rel="noopener">专栏</a>。</p><h2 id="数据位置-Data-location"><a href="#数据位置-Data-location" class="headerlink" title="数据位置(Data location)"></a>数据位置(Data location)</h2><p>在系列第一篇，我们提到 Solidity 类型分为两类：<br><strong>值类型(Value Type)</strong> 及 <strong>引用类型(Reference Types)</strong>，<br>前面我们已经介绍完了值类型，接下来会介绍引用类型。</p><p>引用类型是一个复杂类型，占用的空间通常超过256位， 拷贝时开销很大，因此我们需要考虑将它们存储在什么位置，是<strong>memory</strong>（内存中，数据不是永久存在）还是<strong>storage</strong>（永久存储在区块链中）<br>所有的复杂类型如数组(arrays)和结构体(struct)有一个额外的属性：<strong>数据的存储位置（data location）</strong>。可为<strong>memory</strong>和<strong>storage</strong>。</p><p>根据上下文的不同，大多数时候数据位置有默认值，也通过指定关键字storage和memory修改它。</p><p>函数参数（包含返回的参数）默认是<strong>memory</strong>。<br>局部复杂类型变量（local variables）和 状态变量（state variables） 默认是<strong>storage</strong>。</p><blockquote><p>局部变量：局部作用域（越过作用域即不可被访问，等待被回收）的变量，如函数内的变量。状态变量：合约内声明的公有变量</p></blockquote><p>还有一个存储位置是：<strong>calldata</strong>，用来存储函数参数，是只读的，不会永久存储的一个数据位置。外部函数的参数（不包括返回参数）被强制指定为calldata。效果与memory差不多。</p><p>数据位置指定非常重要，因为他们影响着赋值行为。<br>在memory和storage之间或与状态变量之间相互赋值，总是会创建一个完全独立的拷贝。<br>而将一个storage的状态变量，赋值给一个storage的局部变量，是通过引用传递。所以对于局部变量的修改，同时修改关联的状态变量。<br>另一方面，将一个memory的引用类型赋值给另一个memory的引用，不会创建拷贝（即：memory之间是引用传递）。</p><blockquote><ol><li>注意：不能将memory赋值给局部变量。</li><li>对于值类型，总是会进行拷贝。</li></ol></blockquote><p>下面看一段代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.0;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    uint[] x; //  x的存储位置是storage</span><br><span class="line"></span><br><span class="line">    // memoryArray的存储位置是 memory</span><br><span class="line">    function f(uint[] memoryArray) public &#123;</span><br><span class="line">        x = memoryArray;    // 从 memory 复制到 storage</span><br><span class="line">        var y = x;          // storage 引用传递局部变量y（y 是一个 storage 引用）</span><br><span class="line">        y[7];               // 返回第8个元素</span><br><span class="line">        y.length = 2;       // x同样会被修改</span><br><span class="line">        delete x;           // y同样会被修改</span><br><span class="line"></span><br><span class="line">        // 错误， 不能将memory赋值给局部变量</span><br><span class="line">        // y = memoryArray;  </span><br><span class="line"></span><br><span class="line">        // 错误，不能通过引用销毁storage</span><br><span class="line">        // delete y;        </span><br><span class="line"></span><br><span class="line">        g(x);               // 引用传递， g可以改变x的内容</span><br><span class="line">        h(x);               // 拷贝到memory， h无法改变x的内容</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function g(uint[] storage storageArray) internal &#123;&#125;</span><br><span class="line">    function h(uint[] memoryArray) public &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><h4 id="强制的数据位置-Forced-data-location"><a href="#强制的数据位置-Forced-data-location" class="headerlink" title="强制的数据位置(Forced data location)"></a>强制的数据位置(Forced data location)</h4><ul><li>外部函数(External function)的参数(不包括返回参数)强制为：calldata</li><li>状态变量(State variables)强制为: storage</li></ul><h4 id="默认数据位置（Default-data-location）"><a href="#默认数据位置（Default-data-location）" class="headerlink" title="默认数据位置（Default data location）"></a>默认数据位置（Default data location）</h4><ul><li>函数参数及返回参数：memory</li><li>复杂类型的局部变量：storage</li></ul><h2 id="深入分析"><a href="#深入分析" class="headerlink" title="深入分析"></a>深入分析</h2><p>storage 存储结构是在合约创建的时候就确定好了的，它取决于合约所声明状态变量。但是内容可以被（交易）调用改变。</p><blockquote><p>Solidity 称这个为状态改变，这也是合约级变量称为<strong>状态变量</strong>的原因。也可以更好的理解为什么状态变量都是storage存储。</p></blockquote><p>memory 只能用于函数内部，memory 声明用来告知EVM在运行时创建一块（固定大小）内存区域给变量使用。</p><blockquote><p>storage 在区块链中是用key/value的形式存储，而memory则表现为字节数组</p></blockquote><h3 id="关于栈（stack）"><a href="#关于栈（stack）" class="headerlink" title="关于栈（stack）"></a>关于栈（stack）</h3><p>EVM是一个基于栈的语言，栈实际是在内存(memory)的一个数据结构，每个栈元素占为256位，栈最大长度为1024。<br>值类型的局部变量是存储在栈上。</p><h3 id="不同存储的消耗（gas消耗）"><a href="#不同存储的消耗（gas消耗）" class="headerlink" title="不同存储的消耗（gas消耗）"></a>不同存储的消耗（gas消耗）</h3><ul><li>storage 会永久保存合约状态变量，开销最大</li><li>memory 仅保存临时变量，函数调用之后释放，开销很小</li><li>stack  保存很小的局部变量，几乎免费使用，但有数量限制。</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://solidity.readthedocs.io/en/develop/types.html#data-location" target="_blank" rel="noopener">Solidity官方文档-类型</a></p><p><a href="https://learnblockchain.cn/">深入浅出区块链</a> - 系统学习区块链，打造最好的区块链技术博客。<br>我的<strong><a href="https://t.xiaomiquan.com/RfAu7uj" target="_blank" rel="noopener">知识星球</a></strong>为各位解答区块链技术问题，欢迎加入讨论。</p><!---[1](https://stackoverflow.com/questions/33839154/in-ethereum-solidity-what-is-the-purpose-of-the-memory-keyword)[2](https://ethereum.stackexchange.com/questions/17964/why-are-local-variables-allocated-to-storage-instead-of-memory) -->]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Solidity教程系列第4篇 - Solidity数据位置分析。&lt;/p&gt;
    
    </summary>
    
      <category term="以太坊" scheme="https://learnblockchain.cn/categories/ethereum/"/>
    
      <category term="Solidity" scheme="https://learnblockchain.cn/categories/ethereum/Solidity/"/>
    
    
      <category term="Solidity手册" scheme="https://learnblockchain.cn/tags/Solidity%E6%89%8B%E5%86%8C/"/>
    
  </entry>
  
  <entry>
    <title>智能合约语言 Solidity 教程系列2 - 地址类型介绍</title>
    <link href="https://learnblockchain.cn/2017/12/12/solidity2/"/>
    <id>https://learnblockchain.cn/2017/12/12/solidity2/</id>
    <published>2017-12-12T07:25:59.000Z</published>
    <updated>2018-01-10T08:12:05.510Z</updated>
    
    <content type="html"><![CDATA[<p>Solidity教程系列第二篇 - Solidity地址类型介绍. </p><a id="more"></a><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>Solidity是以太坊智能合约编程语言，阅读本文前，你应该对以太坊、智能合约有所了解，如果你还不了解，建议你先看<a href="https://learnblockchain.cn/2017/11/20/whatiseth/">以太坊是什么</a></p><p>本文前半部分是参考Solidity官方文档（当前最新版本：0.4.20）进行翻译，后半部分是结合实际合约代码实例说明类型的使用（仅针对<a href="https://xiaozhuanlan.com/blockchaincore" target="_blank" rel="noopener">专栏</a>订阅用户）。</p><h2 id="地址类型（Address）"><a href="#地址类型（Address）" class="headerlink" title="地址类型（Address）"></a>地址类型（Address）</h2><p>地址类型<strong>address</strong>是一个值类型，</p><p><strong>地址</strong>： 20字节（一个以太坊地址的长度），地址类型也有成员，地址是所有合约的基础<br>支持的运算符：</p><ul><li>&lt;=, &lt;, ==, !=, &gt;= 和 &gt;<blockquote><p>注意：从0.5.0开始，合约不再继承自地址类型，但仍然可以显式转换为地址。</p></blockquote></li></ul><h3 id="地址类型的成员"><a href="#地址类型的成员" class="headerlink" title="地址类型的成员"></a>地址类型的成员</h3><ul><li><p>balance 属性及transfer() 函数<br>这里是地址类型相关成员的<a href="https://solidity.readthedocs.io/en/develop/units-and-global-variables.html#address-related" target="_blank" rel="noopener">快速索引</a><br>  balance用来查询账户余额，transfer()用来发送以太币（以wei为单位）。<br>  如：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">address x = 0x123;</span><br><span class="line">address myAddress = this;</span><br><span class="line">if (x.balance &lt; 10 &amp;&amp; myAddress.balance &gt;= 10) x.transfer(10);</span><br></pre></td></tr></table></figure><p> <strong>注解</strong>：如果x是合约地址，合约的回退函数（fallback 函数）会随<strong>transfer</strong>调用一起执行（这个是EVM特性），如果因gas耗光或其他原因失败，转移交易会还原并且合约会抛异常停止。</p><blockquote><p>关于回退函数（fallback 函数），简单来说它是合约中无函数名函数，下面代码事例中，进进一步讲解回退函数（fallback） 的使用。</p></blockquote></li></ul><ul><li><p>send() 函数<br>  send 与transfer对应，但更底层。如果执行失败，transfer不会因异常停止，而send会返回false。</p><blockquote><p><strong>警告</strong>：send() 执行有一些风险：如果调用栈的深度超过1024或gas耗光，交易都会失败。因此，为了保证安全，必须检查send的返回值，如果交易失败，会回退以太币。如果用transfer会更好。</p></blockquote></li><li><p>call(), callcode() 和 delegatecall() 函数<br>  为了和非ABI协议的合约进行交互，可以使用call() 函数, 它用来向另一个合约发送原始数据，支持任何类型任意数量的参数，每个参数会按规则(ABI协议)打包成32字节并一一拼接到一起。一个例外是：如果第一个参数恰好4个字节，在这种情况下，会被认为根据ABI协议定义的函数器指定的函数签名而直接使用。如果仅想发送消息体，需要避免第一个参数是4个字节。如下面的例子：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">address nameReg = 0x72ba7d8e73fe8eb666ea66babc8116a41bfb10e2;</span><br><span class="line">nameReg.call(&quot;register&quot;, &quot;MyName&quot;);</span><br><span class="line">nameReg.call(bytes4(keccak256(&quot;fun(uint256)&quot;)), a);</span><br></pre></td></tr></table></figure><p>  <strong>call</strong>函数返回一个bool值，以表明执行成功与否。正常结束返回true，异常终止返回false。但无法获取到结果数据，因为需要提前知道返回的数据的编码和数据大小（因不知道对方使用的协议格式，所以也不会知道返回的结果如何解析）。<br>  还可以提供<strong>.gas()</strong>修饰器进行调用：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">namReg.call.gas(1000000)(&quot;register&quot;, &quot;MyName&quot;);</span><br></pre></td></tr></table></figure><p>  类似还可以提供附带以太币：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nameReg.call.value(1 ether)(&quot;register&quot;, &quot;MyName&quot;);</span><br></pre></td></tr></table></figure><p>  修饰器可以混合使用，修饰器调用顺序无所谓。</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nameReg.call.gas(1000000).value(1 ether)(&quot;register&quot;, &quot;MyName&quot;);</span><br></pre></td></tr></table></figure><blockquote><p>注解：目前还不能在重载函数上使用gas或value修饰符，A workaround is to introduce a special case for gas and value and just re-check whether they are present at the point of overload resolution.（这句我怕翻译的不准确，引用原文）</p></blockquote><p>  同样我们也可以使用delegatecall()，它与call方法的区别在于，仅仅是代码会执行，而其它方面，如（存储，余额等）都是用的当前的合约的数据。delegatecall()方法的目的是用来执行另一个合约中的库代码。所以开发者需要保证两个合约中的存储变量能兼容，来保证delegatecall()能顺利执行。在homestead阶段之前，仅有一个受限的callcode()方法可用，但callcode未提供对msg.sender，msg.value的访问权限。</p><p>  上面的这三个方法call()，delegatecall()，callcode()都是底层的消息传递调用，最好仅在万不得已才进行使用，因为他们破坏了Solidity的类型安全。<br>  .gas() 在call(), callcode() 和 delegatecall() 函数下都可以使用， delegatecall()不支持.value()</p><blockquote><p>注解：所有合约都继承了address的成员，因此可以使用this.balance查询余额。<br>callcode不鼓励使用，以后会移除。</p><p>警告：上述的函数都是底层的函数，使用时要异常小心。当调用一个未知的，可能是恶意的合约时，当你把控制权交给它，它可能回调回你的合约，所以要准备好在调用返回时，应对你的状态变量可能被恶意篡改的情况。</p></blockquote></li></ul><h2 id="地址常量（Address-Literals）"><a href="#地址常量（Address-Literals）" class="headerlink" title="地址常量（Address Literals）"></a>地址常量（Address Literals）</h2><p>一个能通过地址合法性检查（address checksum test）十六进制常量就会被认为是地址，如0xdCad3a6d3569DF655070DEd06cb7A1b2Ccd1D3AF。而不能通过地址合法性检查的39到41位长的十六进制常量，会提示一个警告，被视为普通的有理数常量。</p><blockquote><p>地址合法性检查定义在<a href="https://github.com/ethereum/EIPs/blob/master/EIPS/eip-55.md" target="_blank" rel="noopener">EIP-55</a></p></blockquote><h2 id="合约事例讲解"><a href="#合约事例讲解" class="headerlink" title="合约事例讲解"></a>合约事例讲解</h2><h3 id="合约事例代码"><a href="#合约事例代码" class="headerlink" title="合约事例代码"></a>合约事例代码</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract AddrTest&#123;</span><br><span class="line">    event logdata(bytes data);</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params"></span>) <span class="title">payable</span> </span>&#123;</span><br><span class="line">        logdata(msg.data);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">getBalance</span>(<span class="params"></span>) <span class="title">returns</span> (<span class="params">uint</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.balance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    uint score = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">setScore</span>(<span class="params">uint s</span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">        score = s;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">getScore</span>(<span class="params"></span>) <span class="title">returns</span> (<span class="params"> uint</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> score;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract CallTest&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">deposit</span>(<span class="params"></span>) <span class="title">payable</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    event logSendEvent(address to, uint value);</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">transferEther</span>(<span class="params">address towho</span>) <span class="title">payable</span> </span>&#123;</span><br><span class="line">        towho.transfer(<span class="number">10</span>);</span><br><span class="line">        logSendEvent(towho, <span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">callNoFunc</span>(<span class="params">address addr</span>) <span class="title">returns</span> (<span class="params">bool</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> addr.call(<span class="string">"tinyxiong"</span>, <span class="number">1234</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">callfunc</span>(<span class="params">address addr</span>) <span class="title">returns</span> (<span class="params">bool</span>)</span>&#123;</span><br><span class="line">        bytes4 methodId = bytes4(keccak256(<span class="string">"setScore(uint256)"</span>));</span><br><span class="line">        <span class="keyword">return</span> addr.call(methodId, <span class="number">100</span>);</span><br><span class="line">    &#125;  </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">getBalance</span>(<span class="params"></span>) <span class="title">returns</span> (<span class="params">uint</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.balance;</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="代码运行及讲解"><a href="#代码运行及讲解" class="headerlink" title="代码运行及讲解"></a>代码运行及讲解</h3><p>代码运行及讲解，请订阅<a href="https://xiaozhuanlan.com/blockchaincore" target="_blank" rel="noopener">区块链技术</a>查看。</p><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="https://solidity.readthedocs.io/en/develop/types.html" target="_blank" rel="noopener">Solidity官方文档-类型</a></p><p><a href="https://learnblockchain.cn/">深入浅出区块链</a> - 系统学习区块链，打造最好的区块链技术博客。<br>我的<strong><a href="https://t.xiaomiquan.com/RfAu7uj" target="_blank" rel="noopener">知识星球</a></strong>为各位解答区块链技术问题，欢迎加入讨论。</p><!---和[类型介绍](https://xiaozhuanlan.com/topic/7518269403)篇一样，打开[Remix - Solidity IDE](https://ethereum.github.io/browser-solidity),帖入代码，依次创建合约AddrTest及CallTest，如图：![](/images/testaddr.jpg)创建合约后，可以看到，AddrTest合约内没有命令的函数，显示fallback。AddrTest合约主要是用来说明转入以太币及调用函数式回退函数的调用情况，CallTest合约是作为AddrTest合约的调用者。CallTest合约的函数说明：* transferEther(address towho):  用来给指定合约地址转账（如果一个函数需要进行货币操作，必须要带上payable关键字），转账时填入AddrTest的地址（加双引号）作为参数* deposit(): 函数上增加payable标识，可接收ether，并会把ether存在当前合约，（transferEther转账前需要先存款）。* callfunc() : 调用函数，使用指定的是函数签名。* callNoFunc(): 调用不存在的函数，这时被调用的合约的fallback函数会执行。关于fallback函数用法可进一步参考这一篇:[Ethereum-Development-Best-Practices][1]及[问答](https://ethereum.stackexchange.com/questions/7570/whats-a-fallback-function-when-using-address-send)下面截图演示下，存款和转账，其他的调用请读者动手练习。存款操作如图：![](/images/testaddr1.jpg)完成后，可以在左下角区域查看日志Details->value。然后进行转账，如图：![](/images/testaddr2.jpg)完成后，可以在左下角区域查看日志Details->logs数据，可以看到fallback函数被调用。还可以调用AddrTest的getBalance查看余额数据。[1]: https://github.com/ConsenSys/Ethereum-Development-Best-Practices/wiki/Fallback-functions-and-the-fundamental-limitations-of-using-send()-in-Ethereum-&-Solidity-->]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Solidity教程系列第二篇 - Solidity地址类型介绍. &lt;/p&gt;
    
    </summary>
    
      <category term="以太坊" scheme="https://learnblockchain.cn/categories/ethereum/"/>
    
      <category term="Solidity" scheme="https://learnblockchain.cn/categories/ethereum/Solidity/"/>
    
    
      <category term="Solidity" scheme="https://learnblockchain.cn/tags/Solidity/"/>
    
  </entry>
  
  <entry>
    <title>智能合约语言 Solidity 教程系列3 - 函数类型</title>
    <link href="https://learnblockchain.cn/2017/12/12/solidity_func/"/>
    <id>https://learnblockchain.cn/2017/12/12/solidity_func/</id>
    <published>2017-12-12T07:25:59.000Z</published>
    <updated>2018-01-10T08:11:25.622Z</updated>
    
    <content type="html"><![CDATA[<p>Solidity 教程系列第三篇 - Solidity 函数类型介绍。</p><a id="more"></a><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>Solidity 是以太坊智能合约编程语言，阅读本文前，你应该对以太坊、智能合约有所了解，如果你还不了解，建议你先看<a href="https://learnblockchain.cn/2017/11/20/whatiseth/">以太坊是什么</a></p><p>本文前半部分是参考Solidity 官方文档（当前最新版本：0.4.20）进行翻译，后半部分函数可见性（ public, external, internal, privite ）深度分析（仅针对<a href="https://xiaozhuanlan.com/blockchaincore" target="_blank" rel="noopener">专栏</a>订阅用户）。</p><h2 id="函数类型（Function-Types）"><a href="#函数类型（Function-Types）" class="headerlink" title="函数类型（Function Types）"></a>函数类型（Function Types）</h2><p>函数也是一种类型，且属于值类型。<br>可以将一个函数赋值给一个函数类型的变量。还可以将一个函数作为参数进行传递。也可以在函数调用中返回一个函数。<br>函数类型有两类:内部(internal)和外部(external)函数</p><p><strong>内部(internal)函数</strong>只能在当前合约内被调用（在当前的代码块内，包括内部库函数，和继承的函数中）。<br><strong>外部(external)函数</strong>由地址和函数方法签名两部分组成，可作为外部函数调用的参数，或返回值。</p><p>函数类型定义如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> (<span class="params">&lt;parameter types&gt;</span>) </span>&#123;internal|external&#125; [pure|constant|view|payable] [returns (&lt;return types&gt;)]</span><br></pre></td></tr></table></figure></p><p>如果函数不需要返回，则省去returns (<return types="">)<br>函数类型默认是internal， 因此internal可以省去。但以此相反，合约中函数本身默认是public的， 仅仅是当作类型名使用时默认是internal的。</return></p><p>有两个方式访问函数，一种是直接用函数名<strong>f</strong>, 一种是<strong>this.f</strong>， 前者用于内部函数，后者用于外部函数。</p><p>如果一个函数变量没有初始化，直接调用它将会产生异常。如果delete了一个函数后调用，也会发生同样的异常。</p><p>如果外部函数类型在Solidity的上下文环境以外的地方使用，他们会被视为<strong>function</strong>类型。它会编码为20字节的函数所在地址，和在它之前的4字节的函数方法签名一起作为<strong>bytes24</strong>类型。<br>合约中的public的函数，可以使用internal和external两种方式来调用。<br>internal访问形式为<strong>f</strong>,  external访问形式为<strong>this.f</strong></p><h3 id="成员-属性-selector"><a href="#成员-属性-selector" class="headerlink" title="成员: 属性 selector"></a>成员: 属性 selector</h3><p> public (或 external) 函数有一个特殊的成员selector, 它对应一个ABI 函数选择器。<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.16</span>;</span><br><span class="line"></span><br><span class="line">contract Selector &#123;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) <span class="title">public</span> <span class="title">view</span> <span class="title">returns</span> (<span class="params">bytes4</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.f.selector;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>下面的代码显示内部（internal）函数类型的使用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.16</span>;</span><br><span class="line"></span><br><span class="line">library ArrayUtils &#123;</span><br><span class="line">  <span class="comment">// internal functions can be used in internal library functions because</span></span><br><span class="line">  <span class="comment">// they will be part of the same code context</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">map</span>(<span class="params">uint[] memory self, function (uint</span>) <span class="title">pure</span> <span class="title">returns</span> (<span class="params">uint</span>) <span class="title">f</span>)</span></span><br><span class="line"><span class="function">    <span class="title">internal</span></span></span><br><span class="line"><span class="function">    <span class="title">pure</span></span></span><br><span class="line"><span class="function">    <span class="title">returns</span> (<span class="params">uint[] memory r</span>)</span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    r = <span class="keyword">new</span> uint[](self.length);</span><br><span class="line">    <span class="keyword">for</span> (uint i = <span class="number">0</span>; i &lt; self.length; i++) &#123;</span><br><span class="line">      r[i] = f(self[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">reduce</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    uint[] memory self,</span></span></span><br><span class="line"><span class="function"><span class="params">    function (uint, uint</span>) <span class="title">pure</span> <span class="title">returns</span> (<span class="params">uint</span>) <span class="title">f</span></span></span><br><span class="line"><span class="function">  )</span></span><br><span class="line"><span class="function">    <span class="title">internal</span></span></span><br><span class="line"><span class="function">    <span class="title">pure</span></span></span><br><span class="line"><span class="function">    <span class="title">returns</span> (<span class="params">uint r</span>)</span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    r = self[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (uint i = <span class="number">1</span>; i &lt; self.length; i++) &#123;</span><br><span class="line">      r = f(r, self[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">range</span>(<span class="params">uint length</span>) <span class="title">internal</span> <span class="title">pure</span> <span class="title">returns</span> (<span class="params">uint[] memory r</span>) </span>&#123;</span><br><span class="line">    r = <span class="keyword">new</span> uint[](length);</span><br><span class="line">    <span class="keyword">for</span> (uint i = <span class="number">0</span>; i &lt; r.length; i++) &#123;</span><br><span class="line">      r[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Pyramid &#123;</span><br><span class="line">  using ArrayUtils <span class="keyword">for</span> *;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">pyramid</span>(<span class="params">uint l</span>) <span class="title">public</span> <span class="title">pure</span> <span class="title">returns</span> (<span class="params">uint</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ArrayUtils.range(l).map(square).reduce(sum);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">square</span>(<span class="params">uint x</span>) <span class="title">internal</span> <span class="title">pure</span> <span class="title">returns</span> (<span class="params">uint</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x * x;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">uint x, uint y</span>) <span class="title">internal</span> <span class="title">pure</span> <span class="title">returns</span> (<span class="params">uint</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面的代码显示外部（external）函数类型的使用：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.11</span>;</span><br><span class="line"></span><br><span class="line">contract Oracle &#123;</span><br><span class="line">  struct Request &#123;</span><br><span class="line">    bytes data;</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params">bytes memory</span>) <span class="title">external</span> <span class="title">callback</span>;</span></span><br><span class="line"><span class="function">  &#125;</span></span><br><span class="line">  Request[] requests;</span><br><span class="line">  event NewRequest(uint);</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">query</span>(<span class="params">bytes data, function(bytes memory</span>) <span class="title">external</span> <span class="title">callback</span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">    requests.push(Request(data, callback));</span><br><span class="line">    NewRequest(requests.length - <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">reply</span>(<span class="params">uint requestID, bytes response</span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Here goes the check that the reply comes from a trusted source</span></span><br><span class="line">    requests[requestID].callback(response);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract OracleUser &#123;</span><br><span class="line">  Oracle constant oracle = Oracle(<span class="number">0x1234567</span>); <span class="comment">// known contract</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">buySomething</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    oracle.query(<span class="string">"USD"</span>, <span class="keyword">this</span>.oracleResponse);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">oracleResponse</span>(<span class="params">bytes response</span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">    <span class="built_in">require</span>(msg.sender == address(oracle));</span><br><span class="line">    <span class="comment">// Use the data</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="函数可见性分析"><a href="#函数可见性分析" class="headerlink" title="函数可见性分析"></a>函数可见性分析</h2><ul><li>public - 任意访问</li><li>private - 仅当前合约内</li><li>internal - 仅当前合约及所继承的合约</li><li>external - 仅外部访问（在内部也只能用外部访问方式访问）</li></ul><h3 id="public-还是-external-最佳实践"><a href="#public-还是-external-最佳实践" class="headerlink" title="public 还是 external 最佳实践"></a>public 还是 external 最佳实践</h3><p>请订阅<a href="https://xiaozhuanlan.com/blockchaincore" target="_blank" rel="noopener">区块链技术</a>查看。</p><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="https://solidity.readthedocs.io/en/develop/types.html" target="_blank" rel="noopener">Solidity官方文档-类型</a></p><p><a href="https://learnblockchain.cn/">深入浅出区块链</a> - 系统学习区块链，打造最好的区块链技术博客。<br>我的<strong><a href="https://t.xiaomiquan.com/RfAu7uj" target="_blank" rel="noopener">知识星球</a></strong>为各位解答区块链技术问题，欢迎加入讨论。</p><!---先上一个例子看 public 与 external 不同，代码如下：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity^<span class="number">0.4</span><span class="number">.18</span>;</span><br><span class="line"></span><br><span class="line">contract Test &#123;</span><br><span class="line">    uint[<span class="number">10</span>] x = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">uint[<span class="number">10</span>] a</span>) <span class="title">public</span> <span class="title">returns</span> (<span class="params">uint</span>)</span>&#123;</span><br><span class="line">         <span class="keyword">return</span> a[<span class="number">9</span>]*<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">test2</span>(<span class="params">uint[<span class="number">10</span>] a</span>) <span class="title">external</span> <span class="title">returns</span> (<span class="params">uint</span>)</span>&#123;</span><br><span class="line">         <span class="keyword">return</span> a[<span class="number">9</span>]*<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">calltest</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        test(x);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">calltest2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.test2(x);</span><br><span class="line">        <span class="comment">//test2(x);  //不能在内部调用一个外部函数，会报编译错误。</span></span><br><span class="line">    &#125;  </span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打开<a href="https://ethereum.github.io/browser-solidity">Remix - Solidity IDE</a>,帖入代码，创建合约。<br>然后，我们分别调用 test 及 test2 ，对比执行花费的 gas。<br><img src="/images/test_func.jpg" alt=""><br><img src="/images/test_func2.jpg" alt=""><br>可以看到调用pubic函数花销更大，这是为什么呢？</p><p>当使用public 函数时，Solidity会立即复制数组参数数据到内存， 而external函数则是从calldata读取，而分配内存开销比直接从calldata读取要大的多。<br>那为什么public函数要复制数组参数数据到内存呢？是因为public函数可能会被内部调用，而内部调用数组的参数是当做指向一块内存的指针。<br>对于external函数不允许内部调用，它直接从<strong>calldata</strong>读取数据，省去了复制的过程。</p><p>所以，如果确认一个函数仅仅在外部访问，请用<strong>external</strong>。</p><p>同样，我们接着对比calltest()及calltest2()，这里不截图了，大家自己运行对比一下，可以发现：calltest2的开销比calltest的开销大很多，这是因为通过<strong>this.f()</strong>模式调用，会有一个大开销的<strong>CALL</strong>调用，并且它传参的方式也比内部传递开销更大。</p><p>因此，当需要内部调用的时候，请用<strong>public</strong>。</p><p>–&gt;</p>-->]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Solidity 教程系列第三篇 - Solidity 函数类型介绍。&lt;/p&gt;
    
    </summary>
    
      <category term="以太坊" scheme="https://learnblockchain.cn/categories/ethereum/"/>
    
      <category term="Solidity" scheme="https://learnblockchain.cn/categories/ethereum/Solidity/"/>
    
    
      <category term="Solidity" scheme="https://learnblockchain.cn/tags/Solidity/"/>
    
  </entry>
  
  <entry>
    <title>比特币如何达成共识 - 最长链的选择</title>
    <link href="https://learnblockchain.cn/2017/12/07/bitcoin-sonsensus/"/>
    <id>https://learnblockchain.cn/2017/12/07/bitcoin-sonsensus/</id>
    <published>2017-12-07T08:12:29.000Z</published>
    <updated>2018-01-10T08:10:46.598Z</updated>
    
    <content type="html"><![CDATA[<p>比特币没有中心机构，几乎所有的完整节点都有一份公共总帐本，那么大家如何达成共识：确认哪一份才是公认权威的总账本呢？</p><a id="more"></a><h2 id="为什么要遵守协议"><a href="#为什么要遵守协议" class="headerlink" title="为什么要遵守协议"></a>为什么要遵守协议</h2><p>这其实是一个经济问题，在经济活动中的每个人都是自私自利的，追求的是利益的最大化，一个节点工作量只有在其他的节点认同其是有效的（打包的新区块，其他的节点只有验证通过才会加入到区块链中，并在网络上传播），才能够过得收益，<br>而只有遵守规则才会得到其他的节点认同。<br>因此，基于逐利，节点就会自发的遵守协议。共识就是数以万计的独立节点遵守了简单的规则（通过异步交互）自发形成的。</p><blockquote><p>共识：共同遵守的协议规范</p></blockquote><h2 id="去中心化共识"><a href="#去中心化共识" class="headerlink" title="去中心化共识"></a>去中心化共识</h2><p>在<a href="https://learnblockchain.cn/2017/11/04/bitcoin-pow/">工作量证明</a>一篇，我们了解通过工作量证明来竞争记账，权威的总帐本是怎么达到共识的，没有完全说清楚，今天补上，<br>实际上，比特币的共识由所有节点的4个<strong>独立过程</strong>相互作用而产生：</p><ol><li>每个节点（挖矿节点）依据标准对每个交易进行独立验证</li><li>挖矿节点通过完成工作量证明，将交易记录独立打包进新区块</li><li>每个节点独立的对新区块进行校验并组装进区块链</li><li>每个节点对区块链进行独立选择，在工作量证明机制下选择累计工作量最大的区块链</li></ol><p>共识最终目的是保证比特币不停的在工作量最大的区块链上运转，工作量最大的区块链就是权威的公共总帐本。</p><p>第1 2 3步在<a href="https://learnblockchain.cn/2017/11/04/bitcoin-pow/">比特币如何挖矿-工作量证明</a>一篇有提到过，下面着重讲第4步。</p><h2 id="最长链的选择"><a href="#最长链的选择" class="headerlink" title="最长链的选择"></a>最长链的选择</h2><p>先来一个定义，把累计了最多难度的区块链。在一般情况下，也是包含最多区块的那个链称为<strong>主链</strong><br>每一个（挖矿）节点总是选择并尝试延长主链。</p><h3 id="分叉"><a href="#分叉" class="headerlink" title="分叉"></a>分叉</h3><p>当有两名矿工在几乎在相同的时间内，各自都算得了工作量证明解，便立即传播自己的“获胜”区块到网络中，先是传播给邻近的节点而后传播到整个网络。每个收到有效区块的节点都会将其并入并延长区块链。<br>当这个两个区块传播时，一些节点首先收到#3458A, 一些节点首先收到#3458B，这两个候选区块（通常这两个候选区块会包含几乎相同的交易）都是主链的延伸，分叉就会产生，这时分叉出有竞争关系的两条链，如图：<br><img src="/images/block_branch.jpg" alt=""><br>两个块都收到的节点，会把其中有更多工作量的一条会继续作为主链，另一条作为<strong>备用链</strong>保存（保存是因为备用链将来可能会超过主链难度称为新主链）。</p><h3 id="分叉解决"><a href="#分叉解决" class="headerlink" title="分叉解决"></a>分叉解决</h3><p>收到#3458A的（挖矿）节点，会立刻以这个区块为父区块来产生新的候选区块，并尝试寻找这个候选区块的工作量证明解。同样地，接受#3458B区块的节点会以这个区块为链的顶点开始生成新块，延长这个链（下面称为B链）。<br>这时总会有一方抢先发现工作量证明解并将其传播出去，假设以#3458B为父区块的工作量证明首先解出，如图：<br><img src="/images/block_branch2.jpg" alt=""></p><p>当原本以#3458A为父区块求解的节点在收到#3458B, #3459B之后，会立刻将B链作为主链（因为#3458A为顶点的链已经不是最长链了）继续挖矿。</p><blockquote><p>节点也有可能先收到#3459B，再收到#3458B，收到#3459B时，会被认为是“孤块“（因为还找不到#3459B的父块#3458B）保存在孤块池中，一旦收到父块#3458B时，节点就会将孤块从孤块池中取出，并且连接到它的父区块，让它作为区块链的一部分。</p></blockquote><p>比特币将区块间隔设计为10分钟，是在更快速的交易确认和更低的分叉概率间作出的妥协。更短的区块产生间隔会让交易确认更快地完成，也会导致更加频繁地区块链分叉。与之相对地，长的间隔会减少分叉数量，却会导致更长的确认时间。</p><p><a href="https://learnblockchain.cn/">深入浅出区块链</a> - 系统学习区块链，打造最好的区块链技术博客。<br>我的<strong><a href="https://t.xiaomiquan.com/RfAu7uj" target="_blank" rel="noopener">知识星球</a></strong>为各位解答区块链技术问题，欢迎加入讨论。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;比特币没有中心机构，几乎所有的完整节点都有一份公共总帐本，那么大家如何达成共识：确认哪一份才是公认权威的总账本呢？&lt;/p&gt;
    
    </summary>
    
      <category term="比特币" scheme="https://learnblockchain.cn/categories/bitcoin/"/>
    
    
      <category term="比特币" scheme="https://learnblockchain.cn/tags/%E6%AF%94%E7%89%B9%E5%B8%81/"/>
    
      <category term="共识协议" scheme="https://learnblockchain.cn/tags/%E5%85%B1%E8%AF%86%E5%8D%8F%E8%AE%AE/"/>
    
  </entry>
  
  <entry>
    <title>智能合约语言 Solidity 教程系列1 - 类型介绍</title>
    <link href="https://learnblockchain.cn/2017/12/05/solidity1/"/>
    <id>https://learnblockchain.cn/2017/12/05/solidity1/</id>
    <published>2017-12-05T07:25:59.000Z</published>
    <updated>2018-01-10T08:11:59.145Z</updated>
    
    <content type="html"><![CDATA[<p>现在的Solidity中文文档，要么翻译的太烂，要么太旧，决定重新翻译下。<br>尤其点名批评极客学院名为《Solidity官方文档中文版》的翻译，机器翻译的都比它好，大家还是别看了。</p><a id="more"></a><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>Solidity是以太坊智能合约编程语言，阅读本文前，你应该对以太坊、智能合约有所了解，<br>如果你还不了解，建议你先看<a href="https://learnblockchain.cn/2017/11/20/whatiseth/">以太坊是什么</a><br>Solidity教程会是一系列文章，本文是第一篇：介绍Solidity的变量类型。</p><p>本文前半部分是参考Solidity官方文档（当前最新版本：0.4.20）进行翻译，后半部分是结合实际合约代码实例说明类型的使用（仅针对<a href="https://xiaozhuanlan.com/blockchaincore" target="_blank" rel="noopener">专栏</a>订阅用户）。</p><h2 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h2><p>Solidity是一种静态类型语言，意味着每个变量（本地或状态变量）需要在编译时指定变量的类型（或至少可以推倒出类型）。Solidity提供了一些基本类型可以用来组合成复杂类型。</p><p>Solidity类型分为两类：</p><ul><li>值类型(Value Type) - 变量在赋值或传参时，总是进行值拷贝。</li><li>引用类型(Reference Types)</li></ul><h3 id="值类型-Value-Type"><a href="#值类型-Value-Type" class="headerlink" title="值类型(Value Type)"></a>值类型(Value Type)</h3><p><strong>值类型</strong>包含:</p><ul><li>布尔类型(Booleans)</li><li>整型(Integers)</li><li>定长浮点型(Fixed Point Numbers)</li><li>定长字节数组(Fixed-size byte arrays)</li><li>有理数和整型常量(Rational and Integer Literals)</li><li>字符串常量（String literals）</li><li>十六进制常量（Hexadecimal literals）</li><li>枚举(Enums)</li><li><a href="https://learnblockchain.cn/2017/12/12/solidity_func/">函数类型</a>(Function Types)</li><li><a href="https://learnblockchain.cn/2017/12/12/solidity2/">地址类型</a>(Address)</li><li>地址常量(Address Literals)<blockquote><p><a href="https://learnblockchain.cn/2017/12/12/solidity_func/">函数类型</a>及<a href="https://learnblockchain.cn/2017/12/12/solidity2/">地址类型</a>(Address)有单独的博文，请点击查看。</p></blockquote></li></ul><h2 id="布尔类型-Booleans"><a href="#布尔类型-Booleans" class="headerlink" title="布尔类型(Booleans)"></a>布尔类型(Booleans)</h2><p><strong>布尔(bool)</strong>:可能的取值为常量值<strong>true</strong>和<strong>false</strong>。</p><p>布尔类型支持的运算符有：</p><ul><li>！逻辑非</li><li>&amp;&amp; 逻辑与</li><li>|| 逻辑或</li><li>== 等于</li><li>!= 不等于</li></ul><p>注意：运算符<strong>&amp;&amp;</strong>和<strong>||</strong>是短路运算符，如f(x)||g(y)，当f(x)为真时，则不会继续执行g(y)。</p><h2 id="整型-Integers"><a href="#整型-Integers" class="headerlink" title="整型(Integers)"></a>整型(Integers)</h2><p><strong>int</strong>/<strong>uint</strong>: 表示有符号和无符号不同位数整数。支持关键字<strong>uint8</strong> 到 <strong>uint256</strong> (以8步进)，<br><strong>uint</strong> 和 <strong>int</strong> 默认对应的是 <strong>uint256</strong> 和 <strong>int256</strong>。</p><p>支持的运算符：</p><ul><li>比较运算符： &lt;=, &lt; , ==, !=, &gt;=, &gt; (返回布尔值：true 或 false)</li><li>位操作符： &amp;，|，^(异或)，~（位取反）</li><li>算术操作符：+，-，一元运算-，一元运算+，<em>，/, %(取余数), **</em>（幂）, &lt;&lt; (左移位), &gt;&gt;(右移位)</li></ul><p>说明：</p><ol><li>整数除法总是截断的，但如果运算符是字面量（字面量稍后讲)，则不会截断。</li><li>整数除0会抛异常。</li><li>移位运算的结果的正负取决于操作符左边的数。x &lt;&lt; y 和 x <em> 2**</em>y 是相等， x &gt;&gt; y 和 x / 2**y 是相等的。</li><li>不能进行负移位，即操作符右边的数不可以为负数，否则会抛出运行时异常。</li></ol><p>注意：Solidity中，右移位是和除等价的，因此右移位一个负数，向下取整时会为0，而不像其他语言里为无限负小数。</p><h2 id="定长浮点型（Fixed-Point-Numbers）"><a href="#定长浮点型（Fixed-Point-Numbers）" class="headerlink" title="定长浮点型（Fixed Point Numbers）"></a>定长浮点型（Fixed Point Numbers）</h2><p>注意：定长浮点型 Solidity（发文时）还不完全支持，它可以用来声明变量，但不可以用来赋值。</p><p><strong>fixed</strong>/<strong>ufixed</strong>: 表示有符号和无符号的固定位浮点数。关键字为<strong>ufixedMxN</strong> 和 <strong>ufixedMxN</strong>。<br><strong>M</strong>表示这个类型要占用的位数，以8步进，可为8到256位。<br><strong>N</strong>表示小数点的个数，可为0到80之前</p><p>支持的运算符：</p><ul><li>比较运算符： &lt;=, &lt; , ==, !=, &gt;=, &gt; (返回布尔值：true 或 false)</li><li>算术操作符：+，-，一元运算-，一元运算+，<em>，/, %(取余数)<br>注意：它和大多数语言的float和double不一样，<em>*M</em></em>是表示整个数占用的固定位数，包含整数部分和小数部分。因此用一个小位数（M较小）来表示一个浮点数时，小数部分会几乎占用整个空间。</li></ul><h2 id="定长字节数组-Fixed-size-byte-arrays"><a href="#定长字节数组-Fixed-size-byte-arrays" class="headerlink" title="定长字节数组(Fixed-size byte arrays)"></a>定长字节数组(Fixed-size byte arrays)</h2><p>关键字有：bytes1, bytes2, bytes3, …, bytes32。（以步长1递增）<br>byte代表bytes1。</p><p>支持的运算符：</p><ul><li>比较符: &lt;=, &lt;, ==, !=, &gt;=, &gt; (返回bool）</li><li>位操作符: &amp;, |, ^ (按位异或)，~（按位取反）, &lt;&lt; (左移位), &gt;&gt; (右移位)</li><li>索引（下标）访问: 如果x是bytesI，当0 &lt;= k &lt; I ，则x[k]返回第k个字节（只读）。</li></ul><p>移位运算和整数类似，移位运算的结果的正负取决于操作符左边的数，且不能进行负移位。</p><p>成员变量：<br><strong>.length</strong>：表示这个字节数组的长度（只读）。</p><h2 id="变长（动态分配大小）字节数组（Dynamically-sized-byte-array）"><a href="#变长（动态分配大小）字节数组（Dynamically-sized-byte-array）" class="headerlink" title="变长（动态分配大小）字节数组（Dynamically-sized byte array）"></a>变长（动态分配大小）字节数组（Dynamically-sized byte array）</h2><ul><li>bytes:动态分配大小字节数组, 参见<a href="http://solidity.readthedocs.io/en/latest/types.html#arrays" target="_blank" rel="noopener">Arrays</a>,不是值类型!</li><li>string:动态分配大小UTF8编码的字符类型,参看<a href="http://solidity.readthedocs.io/en/latest/types.html#arrays" target="_blank" rel="noopener">Arrays</a>。不是值类型!</li></ul><p>根据经验：<br>bytes用来存储任意长度的字节数据，string用来存储任意长度的(UTF-8编码)的字符串数据。<br>如果长度可以确定，尽量使用定长的如byte1到byte32中的一个，因为这样更省空间。</p><h2 id="有理数和整型常量-Rational-and-Integer-Literals"><a href="#有理数和整型常量-Rational-and-Integer-Literals" class="headerlink" title="有理数和整型常量(Rational and Integer Literals)"></a>有理数和整型常量(Rational and Integer Literals)</h2><blockquote><p>也有人把Literals翻译为字面量</p></blockquote><p>整型常量是有一系列0-9的数字组成，10进制表示，比如：8进制是不存在的，前置0在Solidity中是无效的。</p><p>10进制小数常量（Decimal fraction literals）带了一个<strong>.</strong>， 在<strong>.</strong>的两边至少有一个数字，有效的表示如:<strong>1.</strong>, <strong>.1</strong> 和 <strong>1.3</strong>.</p><p>科学符号也支持，基数可以是小数，指数必须是整数， 有效的表示如: <strong>2e10</strong>, <strong>-2e10</strong>, <strong>2e-10</strong>, <strong>2.5e1</strong>。</p><p>数字常量表达式本身支持任意精度，也就是可以不会运算溢出，或除法截断。但当它被转换成对应的非常量类型，或者将他们与非常量进行运算，则不能保证精度了。<br>如：(2*<strong>800 + 1) - 2*</strong>800的结果为1（uint8整类) ，尽管中间结果已经超过计算机字长。另外：<strong>.5 * 8</strong>的结果是4，尽管有非整形参与了运算。</p><p>只要操作数是整形，整型支持的运算符都适用于整型常量表达式。<br>如果两个操作数是小数，则不允许进行位运算，指数也不能是小数。</p><p>注意：<br>Solidity对每一个有理数都有一个数值常量类型。整数常量和有理数常量从属于数字常量。所有的数字常表达式的结果都属于数字常量。所以1 + 2和2 + 1都属于同样的有理数的数字常量3</p><p>警告：<br>整数常量除法，在早期的版本中是被截断的，但现在可以被转为有理数了，如5/2的值为 2.5</p><p>注意：<br>数字常量表达式，一旦其中含有常量表达式，它就会被转为一个非常量类型。下面代码中表达式的结果将会被认为是一个有理数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">uint128 a = 1;</span><br><span class="line">uint128 b = 2.5 + a + 0.5;</span><br></pre></td></tr></table></figure></p><p>上述代码编译不能通过，因为b会被编译器认为是小数型。</p><h2 id="字符串常量"><a href="#字符串常量" class="headerlink" title="字符串常量"></a>字符串常量</h2><p>字符串常量是指由单引号，或双引号引起来的字符串 (“foo” or ‘bar’)。字符串并不像C语言，包含结束符，”foo”这个字符串大小仅为三个字节。和整数常量一样，字符串的长度类型可以是变长的。字符串可以隐式的转换为byte1,…byte32 如果适合，也会转为bytes或string。</p><p>字符串常量支持转义字符，比如\n，\xNN，\uNNNN。其中\xNN表示16进制值，最终转换合适的字节。而\uNNNN表示Unicode编码值，最终会转换为UTF8的序列。</p><h2 id="十六进制常量（Hexadecimal-literals）"><a href="#十六进制常量（Hexadecimal-literals）" class="headerlink" title="十六进制常量（Hexadecimal literals）"></a>十六进制常量（Hexadecimal literals）</h2><p>十六进制常量，以关键字hex打头，后面紧跟用单或双引号包裹的字符串，内容是十六进制字符串，如hex”001122ff”。<br>它的值会用二进制来表示。</p><p>十六进制常量和字符串常量类似，也可以转换为字节数组。</p><h2 id="枚举（Enums）"><a href="#枚举（Enums）" class="headerlink" title="枚举（Enums）"></a>枚举（Enums）</h2><p>在Solidity中，枚举可以用来自定义类型。它可以显示的转换与整数进行转换，但不能进行隐式转换。显示的转换会在运行时检查数值范围，如果不匹配，将会引起异常。枚举类型应至少有一名成员。下面是一个枚举的例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.0;</span><br><span class="line"></span><br><span class="line">contract test &#123;</span><br><span class="line">    enum ActionChoices &#123; GoLeft, GoRight, GoStraight, SitStill &#125;</span><br><span class="line">    ActionChoices choice;</span><br><span class="line">    ActionChoices constant defaultChoice = ActionChoices.GoStraight;</span><br><span class="line"></span><br><span class="line">    function setGoStraight() &#123;</span><br><span class="line">        choice = ActionChoices.GoStraight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Since enum types are not part of the ABI, the signature of &quot;getChoice&quot;</span><br><span class="line">    // will automatically be changed to &quot;getChoice() returns (uint8)&quot;</span><br><span class="line">    // for all matters external to Solidity. The integer type used is just</span><br><span class="line">    // large enough to hold all enum values, i.e. if you have more values,</span><br><span class="line">    // `uint16` will be used and so on.</span><br><span class="line">    function getChoice() returns (ActionChoices) &#123;</span><br><span class="line">        return choice;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function getDefaultChoice() returns (uint) &#123;</span><br><span class="line">        return uint(defaultChoice);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="代码实例"><a href="#代码实例" class="headerlink" title="代码实例"></a>代码实例</h2><p>通过合约代码实例说明类型的使用，请订阅<a href="https://xiaozhuanlan.com/blockchaincore" target="_blank" rel="noopener">区块链技术</a>查看。</p><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="https://solidity.readthedocs.io/en/develop/types.html" target="_blank" rel="noopener">Solidity官方文档-类型</a></p><p><a href="https://learnblockchain.cn/">深入浅出区块链</a> - 系统学习区块链，打造最好的区块链技术博客。<br>我的<strong><a href="https://t.xiaomiquan.com/RfAu7uj" target="_blank" rel="noopener">知识星球</a></strong>为各位解答区块链技术问题，欢迎加入讨论。</p><!---下面我们用一个真实的合约代码来理解下各个类型及操作符。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.18</span>;</span><br><span class="line"></span><br><span class="line">contract testType&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">uint x, uint y</span>) <span class="title">public</span> <span class="title">returns</span> (<span class="params">uint z</span>)</span>&#123;</span><br><span class="line">        z = x + y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">divide</span>(<span class="params">uint x, uint y </span>) <span class="title">public</span> <span class="title">returns</span> (<span class="params">uint z</span>) </span>&#123;</span><br><span class="line">        z = x / y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">leftshift</span>(<span class="params">int x, uint y</span>) <span class="title">public</span> <span class="title">returns</span> (<span class="params">int z</span>)</span>&#123;</span><br><span class="line">        z = x &lt;&lt; y;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">rightshift</span>(<span class="params">int x, uint y</span>) <span class="title">public</span> <span class="title">returns</span> (<span class="params">int z</span>)</span>&#123;</span><br><span class="line">        z = x &gt;&gt; y;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">interLiteral</span>(<span class="params"></span>) <span class="title">public</span> <span class="title">returns</span> (<span class="params">uint, uint</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ((<span class="number">2</span>**<span class="number">800</span> + <span class="number">1</span>) - <span class="number">2</span>**<span class="number">800</span>,  <span class="number">0.5</span>*<span class="number">8</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">hexLiteralBytes</span>(<span class="params"></span>) <span class="title">public</span> <span class="title">returns</span> (<span class="params">bytes2, bytes1, bytes1</span>) </span>&#123;</span><br><span class="line">        bytes2 a = hex<span class="string">"aabb"</span>;</span><br><span class="line">        <span class="keyword">return</span> (a, a[<span class="number">0</span>], a[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><ol><li>打开<a href="https://ethereum.github.io/browser-solidity">browser-solidity</a>，把代码拷贝到编辑器。</li><li>选择环境创建合约</li><li>传参数调用</li><li>点Details 查看结果<br>上一张截图大家就明白了。<br><img src="(https://diycode.b0.upaiyun.com/photo/2017/b2b5529012ae930f5ae3e9a700247cbe.jpg" alt=""></li></ol><p>建议根据自己对类型的理解，修改代码，使用不同的参数进行调用以增强对类型的理解。<br>如：运行hexLiteralBytes()查看输出结果，十六进制常量可转化为字节数组。<br><img src="https://diycode.b0.upaiyun.com/photo/2017/e28c82c8442eca12422d32b9d6563dfa.jpg" alt=""></p><p>–&gt;</p>-->]]></content>
    
    <summary type="html">
    
      &lt;p&gt;现在的Solidity中文文档，要么翻译的太烂，要么太旧，决定重新翻译下。&lt;br&gt;尤其点名批评极客学院名为《Solidity官方文档中文版》的翻译，机器翻译的都比它好，大家还是别看了。&lt;/p&gt;
    
    </summary>
    
      <category term="以太坊" scheme="https://learnblockchain.cn/categories/ethereum/"/>
    
      <category term="Solidity" scheme="https://learnblockchain.cn/categories/ethereum/Solidity/"/>
    
    
      <category term="Solidity手册" scheme="https://learnblockchain.cn/tags/Solidity%E6%89%8B%E5%86%8C/"/>
    
  </entry>
  
  <entry>
    <title>Geth 控制台使用及 Web3.js 使用实战</title>
    <link href="https://learnblockchain.cn/2017/12/01/geth_cmd_short/"/>
    <id>https://learnblockchain.cn/2017/12/01/geth_cmd_short/</id>
    <published>2017-12-01T11:41:53.000Z</published>
    <updated>2018-01-10T08:11:01.433Z</updated>
    
    <content type="html"><![CDATA[<p>在开发以太坊去中心化应用，免不了和以太坊进行交互，那就离不开Web3。<br>Geth 控制台（REPL）实现了所有的<a href="http://web3js.readthedocs.io/en/1.0/index.html" target="_blank" rel="noopener">web3 API</a>及<a href="https://github.com/ethereum/go-ethereum/wiki/Management-APIs#admin" target="_blank" rel="noopener">Admin API</a>，<br>使用好 Geth 就是必修课。结合<a href="https://learnblockchain.cn/2017/11/29/geth_cmd_options/">Geth命令用法</a>阅读效果更佳。</p><a id="more"></a><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>阅读本文之前，你需要对以太坊（区块链）有初步的了解，如果你不知道以太坊是什么，请先阅读<a href="https://learnblockchain.cn/2017/11/20/whatiseth/">以太坊是什么</a>。<br>如果你在我的小专栏之外的地方阅读到本文，你可能只能阅读本文的节选，阅读完整全文请订阅小专栏<a href="https://xiaozhuanlan.com/blockchaincore" target="_blank" rel="noopener">区块链技术</a></p><h2 id="geth控制台初探-启动、退出"><a href="#geth控制台初探-启动、退出" class="headerlink" title="geth控制台初探 - 启动、退出"></a>geth控制台初探 - 启动、退出</h2><p>安装参考<a href="https://learnblockchain.cn/2017/11/24/init-env/">智能合约开发环境搭建</a><br>最简单启动方式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ geth console</span><br></pre></td></tr></table></figure></p><p>geth控制台启动成功之后，可以看到<strong>&gt;</strong>提示符。<br>退出输入exit</p><h2 id="geth-日志控制"><a href="#geth-日志控制" class="headerlink" title="geth 日志控制"></a>geth 日志控制</h2><h3 id="重定向日志到文件"><a href="#重定向日志到文件" class="headerlink" title="重定向日志到文件"></a>重定向日志到文件</h3><p>使用<strong>geth console</strong>启动是，会在当前的交互界面下时不时出现日志。<br>可以使用以下方式把日志输出到文件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ geth console 2&gt;&gt;geth.log</span><br></pre></td></tr></table></figure></p><p>可以新开一个命令行终端输入以下命令查看日志：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ tail -f geth.log</span><br></pre></td></tr></table></figure></p><h3 id="重定向另一个终端"><a href="#重定向另一个终端" class="headerlink" title="重定向另一个终端"></a>重定向另一个终端</h3><p>也可以把日志重定向到另一个终端，先在想要看日志的终端输入：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ tty</span><br></pre></td></tr></table></figure></p><p>就可以获取到终端编号，如：/dev/ttys003<br>然后另一个终端使用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ geth console 2&gt;&gt; /dev/ttys003</span><br></pre></td></tr></table></figure></p><p>启动geth, 这是日志就输出到另一个终端。<br>如果不想看到日志还可以重定向到空终端：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ geth console 2&gt;&gt; /dev/null</span><br></pre></td></tr></table></figure></p><h3 id="日志级别控制"><a href="#日志级别控制" class="headerlink" title="日志级别控制"></a>日志级别控制</h3><p>使用<strong>–verbosity</strong>可以控制日志级别，如不想看到日志还可以使用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ geth --verbosity 0 console</span><br></pre></td></tr></table></figure></p><h2 id="启动一个开发模式测试节点"><a href="#启动一个开发模式测试节点" class="headerlink" title="启动一个开发模式测试节点"></a>启动一个开发模式测试节点</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">geth --datadir /home/xxx/testNet --dev console</span><br></pre></td></tr></table></figure><blockquote><p>技巧：如果我们经常使用一个方式来启动，可以把命令存为一个bash脚本。<br>~/bin你可以放一些常用的脚本，并把~/bin加入到环境变量PATH里。</p></blockquote><h2 id="连接geth节点"><a href="#连接geth节点" class="headerlink" title="连接geth节点"></a>连接geth节点</h2><p>另外一个启动geth的方法是连接到一个geth节点：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ geth attach ipc:/some/custom/path</span><br><span class="line">$ geth attach http://191.168.1.1:8545</span><br><span class="line">$ geth attach ws://191.168.1.1:8546</span><br></pre></td></tr></table></figure></p><p>如连接刚刚打开的开发模式节点使用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">geth attach ipc:testNet/geth.ipc</span><br></pre></td></tr></table></figure></p><p>更多内容请前往区块链技术小专栏查看<a href="https://xiaozhuanlan.com/topic/5617843029" target="_blank" rel="noopener">全文链接</a>。<br><a href="https://learnblockchain.cn/">深入浅出区块链</a> - 系统学习区块链，打造最好的区块链技术博客。<br>我的<strong><a href="https://t.xiaomiquan.com/RfAu7uj" target="_blank" rel="noopener">知识星球</a></strong>为各位解答区块链技术问题，欢迎加入讨论。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在开发以太坊去中心化应用，免不了和以太坊进行交互，那就离不开Web3。&lt;br&gt;Geth 控制台（REPL）实现了所有的&lt;a href=&quot;http://web3js.readthedocs.io/en/1.0/index.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;web3 API&lt;/a&gt;及&lt;a href=&quot;https://github.com/ethereum/go-ethereum/wiki/Management-APIs#admin&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Admin API&lt;/a&gt;，&lt;br&gt;使用好 Geth 就是必修课。结合&lt;a href=&quot;https://learnblockchain.cn/2017/11/29/geth_cmd_options/&quot;&gt;Geth命令用法&lt;/a&gt;阅读效果更佳。&lt;/p&gt;
    
    </summary>
    
      <category term="以太坊" scheme="https://learnblockchain.cn/categories/ethereum/"/>
    
      <category term="geth" scheme="https://learnblockchain.cn/categories/ethereum/geth/"/>
    
    
      <category term="Geth使用" scheme="https://learnblockchain.cn/tags/Geth%E4%BD%BF%E7%94%A8/"/>
    
      <category term="Web3.js" scheme="https://learnblockchain.cn/tags/Web3-js/"/>
    
  </entry>
  
  <entry>
    <title>以太坊客户端Geth命令用法-参数详解</title>
    <link href="https://learnblockchain.cn/2017/11/29/geth_cmd_options/"/>
    <id>https://learnblockchain.cn/2017/11/29/geth_cmd_options/</id>
    <published>2017-11-29T03:51:52.000Z</published>
    <updated>2018-01-10T08:10:52.557Z</updated>
    
    <content type="html"><![CDATA[<p>Geth在以太坊智能合约开发中最常用的工具（必备开发工具），一个多用途的命令行工具。<br>熟悉Geth可以让我们有更好的效率，大家可收藏起来作为Geth命令用法手册。 本文主要是对geth help的翻译，基于最新的geth 1.7.3-stable版本。</p><a id="more"></a><p>如果你还不知道geth是什么，请先阅读<a href="https://learnblockchain.cn/2017/11/20/whatiseth/">入门篇：以太坊是什么</a>。<br>更多geth实战使用方法请参考<a href="https://learnblockchain.cn/2017/12/01/geth_cmd_short/">Geth控制台使用实战及Web3.js使用</a><br>以下开始正文。</p><h2 id="命令用法"><a href="#命令用法" class="headerlink" title="命令用法"></a>命令用法</h2><pre><code>geth [选项] 命令 [命令选项] [参数…]</code></pre><h3 id="版本："><a href="#版本：" class="headerlink" title="版本："></a>版本：</h3><pre><code>1.7.3-stable</code></pre><h3 id="命令"><a href="#命令" class="headerlink" title="命令:"></a>命令:</h3><pre><code>account    管理账户attach     启动交互式JavaScript环境（连接到节点）bug        上报bug Issuesconsole    启动交互式JavaScript环境copydb     从文件夹创建本地链dump       Dump（分析）一个特定的块存储dumpconfig 显示配置值export     导出区块链到文件import     导入一个区块链文件init       启动并初始化一个新的创世纪块js         执行指定的JavaScript文件(多个)license    显示许可信息makecache  生成ethash验证缓存(用于测试)makedag    生成ethash 挖矿DAG(用于测试)monitor    监控和可视化节点指标removedb   删除区块链和状态数据库version    打印版本号wallet     管理Ethereum预售钱包help,h     显示一个命令或帮助一个命令列表</code></pre><h3 id="ETHEREUM选项"><a href="#ETHEREUM选项" class="headerlink" title="ETHEREUM选项:"></a>ETHEREUM选项:</h3><pre><code>--config value          TOML 配置文件--datadir “xxx”         数据库和keystore密钥的数据目录--keystore              keystore存放目录(默认在datadir内)--nousb                 禁用监控和管理USB硬件钱包--networkid value       网络标识符(整型, 1=Frontier, 2=Morden (弃用), 3=Ropsten, 4=Rinkeby) (默认: 1)--testnet               Ropsten网络:预先配置的POW(proof-of-work)测试网络--rinkeby               Rinkeby网络: 预先配置的POA(proof-of-authority)测试网络--syncmode &quot;fast&quot;       同步模式 (&quot;fast&quot;, &quot;full&quot;, or &quot;light&quot;)--ethstats value        上报ethstats service  URL (nodename:secret@host:port)--identity value        自定义节点名--lightserv value       允许LES请求时间最大百分比(0 – 90)(默认值:0) --lightpeers value      最大LES client peers数量(默认值:20)--lightkdf              在KDF强度消费时降低key-derivation RAM&amp;CPU使用</code></pre><h3 id="开发者（模式）选项"><a href="#开发者（模式）选项" class="headerlink" title="开发者（模式）选项:"></a>开发者（模式）选项:</h3><pre><code>--dev               使用POA共识网络，默认预分配一个开发者账户并且会自动开启挖矿。--dev.period value  开发者模式下挖矿周期 (0 = 仅在交易时) (默认: 0)</code></pre><h3 id="ETHASH-选项"><a href="#ETHASH-选项" class="headerlink" title="ETHASH 选项:"></a>ETHASH 选项:</h3><pre><code>--ethash.cachedir                        ethash验证缓存目录(默认 = datadir目录内)--ethash.cachesinmem value               在内存保存的最近的ethash缓存个数  (每个缓存16MB ) (默认: 2)--ethash.cachesondisk value              在磁盘保存的最近的ethash缓存个数 (每个缓存16MB) (默认: 3)--ethash.dagdir &quot;&quot;                       存ethash DAGs目录 (默认 = 用户hom目录)--ethash.dagsinmem value                 在内存保存的最近的ethash DAGs 个数 (每个1GB以上) (默认: 1)--ethash.dagsondisk value                在磁盘保存的最近的ethash DAGs 个数 (每个1GB以上) (默认: 2)</code></pre><h3 id="交易池选项"><a href="#交易池选项" class="headerlink" title="交易池选项:"></a>交易池选项:</h3><pre><code>--txpool.nolocals            为本地提交交易禁用价格豁免--txpool.journal value       本地交易的磁盘日志：用于节点重启 (默认: &quot;transactions.rlp&quot;)--txpool.rejournal value     重新生成本地交易日志的时间间隔 (默认: 1小时)--txpool.pricelimit value    加入交易池的最小的gas价格限制(默认: 1)--txpool.pricebump value     价格波动百分比（相对之前已有交易） (默认: 10)--txpool.accountslots value  每个帐户保证可执行的最少交易槽数量  (默认: 16)--txpool.globalslots value   所有帐户可执行的最大交易槽数量 (默认: 4096)--txpool.accountqueue value  每个帐户允许的最多非可执行交易槽数量 (默认: 64)--txpool.globalqueue value   所有帐户非可执行交易最大槽数量  (默认: 1024)--txpool.lifetime value      非可执行交易最大入队时间(默认: 3小时)</code></pre><h3 id="性能调优的选项"><a href="#性能调优的选项" class="headerlink" title="性能调优的选项:"></a>性能调优的选项:</h3><pre><code>--cache value                分配给内部缓存的内存MB数量，缓存值(最低16 mb /数据库强制要求)(默认:128)--trie-cache-gens value      保持在内存中产生的trie node数量(默认:120)</code></pre><h3 id="帐户选项"><a href="#帐户选项" class="headerlink" title="帐户选项:"></a>帐户选项:</h3><pre><code>--unlock value              需解锁账户用逗号分隔--password value            用于非交互式密码输入的密码文件</code></pre><h3 id="API和控制台选项"><a href="#API和控制台选项" class="headerlink" title="API和控制台选项:"></a>API和控制台选项:</h3><pre><code>--rpc                       启用HTTP-RPC服务器--rpcaddr value             HTTP-RPC服务器接口地址(默认值:“localhost”)--rpcport value             HTTP-RPC服务器监听端口(默认值:8545)--rpcapi value              基于HTTP-RPC接口提供的API--ws                        启用WS-RPC服务器--wsaddr value              WS-RPC服务器监听接口地址(默认值:“localhost”)--wsport value              WS-RPC服务器监听端口(默认值:8546)--wsapi  value              基于WS-RPC的接口提供的API--wsorigins value           websockets请求允许的源--ipcdisable                禁用IPC-RPC服务器--ipcpath                   包含在datadir里的IPC socket/pipe文件名(转义过的显式路径)--rpccorsdomain value       允许跨域请求的域名列表(逗号分隔)(浏览器强制)--jspath loadScript         JavaScript加载脚本的根路径(默认值:“.”)--exec value                执行JavaScript语句(只能结合console/attach使用)--preload value             预加载到控制台的JavaScript文件列表(逗号分隔)</code></pre><h3 id="网络选项"><a href="#网络选项" class="headerlink" title="网络选项:"></a>网络选项:</h3><pre><code>--bootnodes value    用于P2P发现引导的enode urls(逗号分隔)(对于light servers用v4+v5代替)--bootnodesv4 value  用于P2P v4发现引导的enode urls(逗号分隔) (light server, 全节点)--bootnodesv5 value  用于P2P v5发现引导的enode urls(逗号分隔) (light server, 轻节点)--port value         网卡监听端口(默认值:30303)--maxpeers value     最大的网络节点数量(如果设置为0，网络将被禁用)(默认值:25)--maxpendpeers value    最大尝试连接的数量(如果设置为0，则将使用默认值)(默认值:0)--nat value             NAT端口映射机制 (any|none|upnp|pmp|extip:&lt;IP&gt;) (默认: “any”)--nodiscover            禁用节点发现机制(手动添加节点)--v5disc                启用实验性的RLPx V5(Topic发现)机制--nodekey value         P2P节点密钥文件--nodekeyhex value      十六进制的P2P节点密钥(用于测试)</code></pre><h3 id="矿工选项"><a href="#矿工选项" class="headerlink" title="矿工选项:"></a>矿工选项:</h3><pre><code>--mine                  打开挖矿--minerthreads value    挖矿使用的CPU线程数量(默认值:8)--etherbase value       挖矿奖励地址(默认=第一个创建的帐户)(默认值:“0”)--targetgaslimit value  目标gas限制：设置最低gas限制（低于这个不会被挖？） (默认值:“4712388”)--gasprice value        挖矿接受交易的最低gas价格--extradata value       矿工设置的额外块数据(默认=client version)</code></pre><h3 id="GAS价格选项"><a href="#GAS价格选项" class="headerlink" title="GAS价格选项:"></a>GAS价格选项:</h3><pre><code>--gpoblocks value      用于检查gas价格的最近块的个数  (默认: 10)--gpopercentile value  建议gas价参考最近交易的gas价的百分位数，(默认: 50)</code></pre><h3 id="虚拟机的选项"><a href="#虚拟机的选项" class="headerlink" title="虚拟机的选项:"></a>虚拟机的选项:</h3><pre><code>--vmdebug        记录VM及合约调试信息</code></pre><h3 id="日志和调试选项"><a href="#日志和调试选项" class="headerlink" title="日志和调试选项:"></a>日志和调试选项:</h3><pre><code>--metrics            启用metrics收集和报告--fakepow            禁用proof-of-work验证--verbosity value    日志详细度:0=silent, 1=error, 2=warn, 3=info, 4=debug, 5=detail (default: 3)--vmodule value      每个模块详细度:以 &lt;pattern&gt;=&lt;level&gt;的逗号分隔列表 (比如 eth/*=6,p2p=5)--backtrace value    请求特定日志记录堆栈跟踪 (比如 “block.go:271”)--debug                     突出显示调用位置日志(文件名及行号)--pprof                     启用pprof HTTP服务器--pprofaddr value           pprof HTTP服务器监听接口(默认值:127.0.0.1)--pprofport value           pprof HTTP服务器监听端口(默认值:6060)--memprofilerate value      按指定频率打开memory profiling    (默认:524288)--blockprofilerate value    按指定频率打开block profiling    (默认值:0)--cpuprofile value          将CPU profile写入指定文件--trace value               将execution trace写入指定文件</code></pre><h3 id="WHISPER实验选项"><a href="#WHISPER实验选项" class="headerlink" title="WHISPER实验选项:"></a>WHISPER实验选项:</h3><pre><code>--shh                        启用Whisper--shh.maxmessagesize value   可接受的最大的消息大小 (默认值: 1048576)--shh.pow value              可接受的最小的POW (默认值: 0.2)</code></pre><h3 id="弃用选项："><a href="#弃用选项：" class="headerlink" title="弃用选项："></a>弃用选项：</h3><pre><code>--fast     开启快速同步--light    启用轻客户端模式</code></pre><h3 id="其他选项"><a href="#其他选项" class="headerlink" title="其他选项:"></a>其他选项:</h3><pre><code>–help, -h    显示帮助</code></pre><h3 id="版权："><a href="#版权：" class="headerlink" title="版权："></a>版权：</h3><pre><code>Copyright 2013-2017 The go-ethereum Authors</code></pre><h2 id="翻译说明"><a href="#翻译说明" class="headerlink" title="翻译说明"></a>翻译说明</h2><p>   有些参数翻译可能有不准确的地方，请大家指正。<br>   原文会尽量随geth升级保持更新，原始链接：<a href="https://learnblockchain.cn/2017/11/29/geth_cmd_options">https://learnblockchain.cn/2017/11/29/geth_cmd_options/</a></p><p><a href="https://learnblockchain.cn/">深入浅出区块链</a> - 系统学习区块链，打造最好的区块链技术博客。<br>我的<strong><a href="https://t.xiaomiquan.com/RfAu7uj" target="_blank" rel="noopener">知识星球</a></strong>为各位解答区块链技术问题，欢迎加入讨论。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Geth在以太坊智能合约开发中最常用的工具（必备开发工具），一个多用途的命令行工具。&lt;br&gt;熟悉Geth可以让我们有更好的效率，大家可收藏起来作为Geth命令用法手册。 本文主要是对geth help的翻译，基于最新的geth 1.7.3-stable版本。&lt;/p&gt;
    
    </summary>
    
      <category term="以太坊" scheme="https://learnblockchain.cn/categories/ethereum/"/>
    
      <category term="geth" scheme="https://learnblockchain.cn/categories/ethereum/geth/"/>
    
    
      <category term="Geth命令用法" scheme="https://learnblockchain.cn/tags/Geth%E5%91%BD%E4%BB%A4%E7%94%A8%E6%B3%95/"/>
    
      <category term="Geth命令参数详解" scheme="https://learnblockchain.cn/tags/Geth%E5%91%BD%E4%BB%A4%E5%8F%82%E6%95%B0%E8%AF%A6%E8%A7%A3/"/>
    
      <category term="Geth手册" scheme="https://learnblockchain.cn/tags/Geth%E6%89%8B%E5%86%8C/"/>
    
  </entry>
  
  <entry>
    <title>智能合约开发环境搭建及Hello World合约</title>
    <link href="https://learnblockchain.cn/2017/11/24/init-env/"/>
    <id>https://learnblockchain.cn/2017/11/24/init-env/</id>
    <published>2017-11-24T11:41:53.000Z</published>
    <updated>2018-01-10T08:11:10.051Z</updated>
    
    <content type="html"><![CDATA[<p>如果你对于以太坊智能合约开发还没有概念（本文会假设你已经知道这些概念），建议先阅读<a href="https://learnblockchain.cn/2017/11/20/whatiseth/">入门篇</a>。<br>就先学习任何编程语言一样，入门的第一个程序都是Hello World。今天我们来一步一步从搭建以太坊智能合约开发环境开始，讲解智能合约的Hello World如何编写。</p><a id="more"></a><h2 id="开发环境搭建"><a href="#开发环境搭建" class="headerlink" title="开发环境搭建"></a>开发环境搭建</h2><h3 id="Solidity安装"><a href="#Solidity安装" class="headerlink" title="Solidity安装"></a>Solidity安装</h3><p>强烈建议新手使用<a href="https://ethereum.github.io/browser-solidity" target="_blank" rel="noopener">Browser-Solidity</a>来进行开发。<br>Browser-Solidity是一个基于浏览器的Solidity，就可以不用安装Solidity，本文的Hello World教程也将基于Browser-Solidity来进行。</p><p>如果你想自己安装请参考<a href="https://solidity.readthedocs.io/en/develop/installing-solidity.html" target="_blank" rel="noopener">Solidity安装指引</a>。</p><h3 id="geth-安装"><a href="#geth-安装" class="headerlink" title="geth 安装"></a>geth 安装</h3><p>Mac下安装命令如下：其他平台参考：<a href="https://github.com/ethereum/go-ethereum/wiki/Building-Ethereum" target="_blank" rel="noopener">geth官方安装指引</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">brew tap ethereum/ethereum</span><br><span class="line">brew install ethereum</span><br></pre></td></tr></table></figure></p><blockquote><p>brew 是 Mac 下的包管理工具，和Ubuntu里的apt-get类似</p></blockquote><p>安装完以后，就是把geth控制台启动。</p><h2 id="启动环境"><a href="#启动环境" class="headerlink" title="启动环境"></a>启动环境</h2><p>在入门篇讲过，geth是一个以太坊客户端，现在利用geth启动一个以太坊（开发者）网络节点。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">geth --datadir testNet --dev console 2&gt;&gt; test.log</span><br></pre></td></tr></table></figure><p>执行命名后，会进入geth控制台，这时光标停在一个向右的箭头处，像这样：<br><img src="https://learnblockchain.cn/images/open_geth_eth.jpg" alt=""></p><p>命令参数说明（更多命令详解可阅读<a href="https://learnblockchain.cn/2017/11/29/geth_cmd_options/">Geth命令用法-参数详解篇</a>）:<br><strong>–dev</strong> 启用开发者网络（模式），开发者网络会使用POA共识，默认预分配一个开发者账户并且会自动开启挖矿。<br><strong>–datadir</strong> 后面的参数是区块数据及秘钥存放目录。<br>第一次输入命令后，它会放在当前目录下新建一个testNet目录来存放数据。<br><strong>console</strong> 进入控制台<br><strong>2&gt;&gt; test.log</strong> 表示把控制台日志输出到test.log文件</p><p>为了更好的理解，建议新开一个命令行终端，实时显示日志：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tail -f test.log</span><br></pre></td></tr></table></figure></p><h2 id="准备账户"><a href="#准备账户" class="headerlink" title="准备账户"></a>准备账户</h2><p>部署智能合约需要一个外部账户，我们先来看看分配的开发者账户，在控制台使用以下命令查看账户：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; eth.accounts</span><br></pre></td></tr></table></figure></p><p>回车后，返回一个账户数组，里面有一个默认账户，如：<br><img src="https://learnblockchain.cn/images/geth_accounts_1.jpg" alt=""></p><blockquote><p>也可以使用personal.listAccounts查看账户，</p></blockquote><p>再来看一下账户里的余额，使用一下命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; eth.getBalance(eth.accounts[0])</span><br></pre></td></tr></table></figure></p><p><strong>eth.accounts[0]</strong>表示账户列表第一个账户<br>回车后，可以看到大量的余额，如：<br>1.15792089237316195423570985008687907853269… e+77</p><p>开发者账户因余额太多，如果用这个账户来部署合约时会无法看到余额变化，为了更好的体验完整的过程，这里选择创建一个新的账户。</p><h3 id="创建账户"><a href="#创建账户" class="headerlink" title="创建账户"></a>创建账户</h3><p>使用以下命令创建账户：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; personal.newAccount(&quot;TinyXiong&quot;)</span><br></pre></td></tr></table></figure></p><p>TinyXiong为新账户的密码，回车后，返回一个新账户。</p><p>这时我们查看账户列表：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; eth.accounts</span><br></pre></td></tr></table></figure></p><p>可以看到账户数组你包含两个账户，新账户在第二个（索引为1）位置。</p><p>现在看看账户的余额：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; eth.getBalance(eth.accounts[1])</span><br><span class="line">0</span><br></pre></td></tr></table></figure></p><p>回车后，返回的是0，新账户是0。结果如：<br><img src="https://learnblockchain.cn/images/geth_accounts_2.jpg" alt=""></p><h3 id="给新账户转账"><a href="#给新账户转账" class="headerlink" title="给新账户转账"></a>给新账户转账</h3><p>我们知道没有余额的账户是没法部署合约的，那我们就从默认账户转1以太币给新账户，使用以下命令（请使用你自己eth.accounts对应输出的账户）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eth.sendTransaction(&#123;from: &apos;0xb0ebe17ef0e96b5c525709c0a1ede347c66bd391&apos;, to: &apos;0xf280facfd60d61f6fd3f88c9dee4fb90d0e11dfc&apos;, value: web3.toWei(1, &quot;ether&quot;)&#125;)</span><br></pre></td></tr></table></figure></p><blockquote><p>在打开的<strong>tail -f test.log</strong>日志终端里，可以同时看到挖矿记录<br>再次查看新账户余额，可以新账户有1个以太币<br><img src="https://learnblockchain.cn/images/geth_accounts_3.jpg" alt=""></p></blockquote><h3 id="解锁账户"><a href="#解锁账户" class="headerlink" title="解锁账户"></a>解锁账户</h3><p>在部署合约前需要先解锁账户（就像银行转账要输入密码一样），使用以下命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">personal.unlockAccount(eth.accounts[1],&quot;TinyXiong&quot;);</span><br></pre></td></tr></table></figure></p><p>“TinyXiong” 是之前创建账户时的密码<br>解锁成功后，账户就准备完毕啦，接下来就是编写合约代码。</p><h2 id="编写合约代码"><a href="#编写合约代码" class="headerlink" title="编写合约代码"></a>编写合约代码</h2><p>现在我们来开始编写第一个智能合约代码，solidity代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.18</span>;</span><br><span class="line">contract hello &#123;</span><br><span class="line">    string greeting;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">hello</span>(<span class="params">string _greeting</span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">        greeting = _greeting;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">say</span>(<span class="params"></span>) <span class="title">constant</span> <span class="title">public</span> <span class="title">returns</span> (<span class="params">string</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> greeting;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单解释下，我们定义了一个名为hello的合约，在合约初始化时保存了一个字符串（我们会传入hello world），每次调用say返回字符串。<br>把这段代码写(拷贝)到<a href="https://ethereum.github.io/browser-solidity" target="_blank" rel="noopener">Browser-Solidity</a>，如果没有错误，点击Details获取部署代码，如：<br><img src="https://learnblockchain.cn/images/eth_code_hello_step1.jpeg" alt=""></p><p>在弹出的对话框中找到WEB3DEPLOY部分，点拷贝，粘贴到编辑器后，修改初始化字符串为hello world。<br><img src="https://learnblockchain.cn/images/eth_code_hello_step2.jpeg" alt=""></p><blockquote><p>solidity在博文写作时（2017/11/24），版本为0.4.18，solidity发展非常快，solidity版本之间有可能不能兼容，这是你可以在Browser-Solidity的Settings里选择对应的编译器版本。<br>Browser-Solidity也不停的更新中，截图可能和你看到的界面不一样。</p></blockquote><h2 id="部署合约"><a href="#部署合约" class="headerlink" title="部署合约"></a>部署合约</h2><p>Browser-Solidity生成的代码，拷贝到编辑器里修改后的代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> _greeting = <span class="string">"Hello World"</span> ;</span><br><span class="line"><span class="keyword">var</span> helloContract = web3.eth.contract([&#123;<span class="string">"constant"</span>:<span class="literal">true</span>,<span class="string">"inputs"</span>:[],<span class="string">"name"</span>:<span class="string">"say"</span>,<span class="string">"outputs"</span>:[&#123;<span class="string">"name"</span>:<span class="string">""</span>,<span class="string">"type"</span>:<span class="string">"string"</span>&#125;],<span class="string">"payable"</span>:<span class="literal">false</span>,<span class="string">"stateMutability"</span>:<span class="string">"view"</span>,<span class="string">"type"</span>:<span class="string">"function"</span>&#125;,&#123;<span class="string">"inputs"</span>:[&#123;<span class="string">"name"</span>:<span class="string">"_greeting"</span>,<span class="string">"type"</span>:<span class="string">"string"</span>&#125;],<span class="string">"payable"</span>:<span class="literal">false</span>,<span class="string">"stateMutability"</span>:<span class="string">"nonpayable"</span>,<span class="string">"type"</span>:<span class="string">"constructor"</span>&#125;]);</span><br><span class="line"><span class="keyword">var</span> hello = helloContract.new(</span><br><span class="line">   _greeting,</span><br><span class="line">   &#123;</span><br><span class="line">     <span class="keyword">from</span>: web3.eth.accounts[<span class="number">1</span>], </span><br><span class="line">     data: <span class="string">'0x6060604052341561000f57600080fd5b6040516102b83803806102b8833981016040528080518201919050508060009080519060200190610041929190610048565b50506100ed565b828054600181600116156101000203166002900490600052602060002090601f016020900481019282601f1061008957805160ff19168380011785556100b7565b828001600101855582156100b7579182015b828111156100b657825182559160200191906001019061009b565b5b5090506100c491906100c8565b5090565b6100ea91905b808211156100e65760008160009055506001016100ce565b5090565b90565b6101bc806100fc6000396000f300606060405260043610610041576000357c0100000000000000000000000000000000000000000000000000000000900463ffffffff168063954ab4b214610046575b600080fd5b341561005157600080fd5b6100596100d4565b6040518080602001828103825283818151815260200191508051906020019080838360005b8381101561009957808201518184015260208101905061007e565b50505050905090810190601f1680156100c65780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b6100dc61017c565b60008054600181600116156101000203166002900480601f0160208091040260200160405190810160405280929190818152602001828054600181600116156101000203166002900480156101725780601f1061014757610100808354040283529160200191610172565b820191906000526020600020905b81548152906001019060200180831161015557829003601f168201915b5050505050905090565b6020604051908101604052806000815250905600a165627a7a723058204a5577bb3ad30e02f7a3bdd90eedcc682700d67fc8ed6604d38bb739c0655df90029'</span>, </span><br><span class="line">     gas: <span class="string">'4700000'</span></span><br><span class="line">   &#125;, <span class="function"><span class="keyword">function</span> (<span class="params">e, contract</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e, contract);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> contract.address !== <span class="string">'undefined'</span>) &#123;</span><br><span class="line">         <span class="built_in">console</span>.log(<span class="string">'Contract mined! address: '</span> + contract.address + <span class="string">' transactionHash: '</span> + contract.transactionHash);</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;);</span><br></pre></td></tr></table></figure><p>第1行：修改字符串为Hello World<br>第2行：修改合约变量名<br>第3行：修改合约实例变量名，之后可以直接用实例调用函数。<br>第6行：修改部署账户为新账户索引，即使用新账户来部署合约。<br>第8行：准备付的gas费用，IDE已经帮我们预估好了。<br>第9行：设置部署回调函数。</p><p>拷贝会geth控制台里，回车后，看到输出如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Contract mined! address: 0x79544078dcd9d560ec3f6eff0af42a9fc84c7d19 transactionHash: 0xe2caab22102e93434888a0b8013a7ae7e804b132e4a8bfd2318356f6cf0480b3</span><br></pre></td></tr></table></figure></p><p>说明合约已经部署成功。</p><blockquote><p>在打开的<strong>tail -f test.log</strong>日志终端里，可以同时看到挖矿记录</p></blockquote><p>现在我们查看下新账户的余额：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; eth.getBalance(eth.accounts[1])</span><br></pre></td></tr></table></figure></p><p>是不是比之前转账的余额少呀！</p><h2 id="运行合约"><a href="#运行合约" class="headerlink" title="运行合约"></a>运行合约</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; hello.say()</span><br><span class="line">&quot;Hello World&quot;</span><br></pre></td></tr></table></figure><p>输出Hello World，我们第一个合约Hello World，成功运行了。</p><p>本文会随geth，solidity语言版本升级保持更新，查看本文原始链接：<a href="https://learnblockchain.cn/2017/11/24/init-env/">https://learnblockchain.cn/2017/11/24/init-env/</a></p><p>第一个合约的意义更重要的是体验智能合约开发流程，对于初学者一些可以选择先放弃一些细节，开发流程打通之后，可以增强信心进行下一步的学习。<br>有问题就加入<a href="https://t.xiaomiquan.com/RfAu7uj" target="_blank" rel="noopener">深入浅出区块链群</a>一起来交流吧。</p><p><a href="https://learnblockchain.cn/">深入浅出区块链</a> - 系统学习区块链，打造最好的区块链技术博客。<br>我的<strong><a href="https://t.xiaomiquan.com/RfAu7uj" target="_blank" rel="noopener">知识星球</a></strong>为各位解答区块链技术问题，欢迎加入讨论。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;如果你对于以太坊智能合约开发还没有概念（本文会假设你已经知道这些概念），建议先阅读&lt;a href=&quot;https://learnblockchain.cn/2017/11/20/whatiseth/&quot;&gt;入门篇&lt;/a&gt;。&lt;br&gt;就先学习任何编程语言一样，入门的第一个程序都是Hello World。今天我们来一步一步从搭建以太坊智能合约开发环境开始，讲解智能合约的Hello World如何编写。&lt;/p&gt;
    
    </summary>
    
      <category term="以太坊" scheme="https://learnblockchain.cn/categories/ethereum/"/>
    
    
      <category term="环境" scheme="https://learnblockchain.cn/tags/%E7%8E%AF%E5%A2%83/"/>
    
      <category term="geth安装" scheme="https://learnblockchain.cn/tags/geth%E5%AE%89%E8%A3%85/"/>
    
      <category term="第一个智能合约" scheme="https://learnblockchain.cn/tags/%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/"/>
    
  </entry>
  
  <entry>
    <title>以太坊是什么 - 以太坊开发入门指南</title>
    <link href="https://learnblockchain.cn/2017/11/20/whatiseth/"/>
    <id>https://learnblockchain.cn/2017/11/20/whatiseth/</id>
    <published>2017-11-20T03:51:52.000Z</published>
    <updated>2018-01-10T08:12:24.199Z</updated>
    
    <content type="html"><![CDATA[<p>很多同学已经跃跃欲试投入到区块链开发队伍当中来，可是又感觉无从下手，本文将基于以太坊平台，以通俗的方式介绍以太坊开发中涉及的各晦涩的概念，轻松带大家入门。</p><a id="more"></a><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>阅读本文前，你应该大概了解区块链是什么，如果你还不了解，欢迎订阅专栏：<a href="https://xiaozhuanlan.com/blockchaincore" target="_blank" rel="noopener">区块链技术</a><br>指引你从头开始学区块链技术。</p><h2 id="以太坊是什么"><a href="#以太坊是什么" class="headerlink" title="以太坊是什么"></a>以太坊是什么</h2><p>以太坊（Ethereum）是一个建立在区块链技术之上， 去中心化应用平台。它允许任何人在平台中建立和使用通过区块链技术运行的去中心化应用。</p><blockquote><p>对这句话不理解的同学，姑且可以理解为以太坊是区块链里的Android，它是一个开发平台，让我们就可以像基于Android Framework一样基于区块链技术写应用。</p></blockquote><p>在没有以太坊之前，写区块链应用是这样的：拷贝一份比特币代码，然后去改底层代码如加密算法，共识机制，网络协议等等（很多山寨币就是这样，改改就出来一个新币）。<br>以太坊平台对底层区块链技术进行了封装，让区块链应用开发者可以直接基于以太坊平台进行开发，开发者只要专注于应用本身的开发，从而大大降低了难度。 </p><blockquote><p>目前围绕以太坊已经形成了一个较为完善的开发生态圈：有社区的支持，有很多开发框架、工具可以选择。</p></blockquote><h2 id="智能合约"><a href="#智能合约" class="headerlink" title="智能合约"></a>智能合约</h2><h3 id="什么是智能合约"><a href="#什么是智能合约" class="headerlink" title="什么是智能合约"></a>什么是智能合约</h3><p><strong>以太坊上的程序称之为智能合约</strong>， 它是代码和数据(状态)的集合。</p><blockquote><p>智能合约可以理解为在区块链上可以自动执行的（由消息驱动的）、以代码形式编写的合同（特殊的交易）。</p></blockquote><p>在<a href="https://learnblockchain.cn/2017/11/10/bitcoin-script/">比特币脚本</a>中，我们讲到过比特币的交易是可以编程的，但是比特币脚本有很多的限制，能够编写的程序也有限，<br>而以太坊则更加完备（在计算机科学术语中，称它为是“图灵完备的”），让我们就像使用任何高级语言一样来编写几乎可以做任何事情的程序（智能合约）。</p><p>智能合约非常适合对信任、安全和持久性要求较高的应用场景，比如：数字货币、数字资产、投票、保险、金融应用、预测市场、产权所有权管理、物联网、点对点交易等等。<br>目前除数字货币之外，真正落地的应用还不多（就像移动平台刚开始出来一样），相信1到3年内，各种杀手级会慢慢出现。</p><h3 id="编程语言：Solidity"><a href="#编程语言：Solidity" class="headerlink" title="编程语言：Solidity"></a>编程语言：Solidity</h3><p>智能合约的默认的编程语言是Solidity，文件扩展名以.sol结尾。<br>Solidity语言和JavaScript很相似，用它来开发合约并编译成以太坊虚拟机字节代码。</p><blockquote><p>还有Viper，Serpent，LLL及Bamboo，建议大家还是使用Solidity。<br>更新：Serpent官方已经不再推荐，建议Serpent的用户转换到Viper，他们都是类Python语言。</p></blockquote><p><a href="https://ethereum.github.io/browser-solidity" target="_blank" rel="noopener">Browser-Solidity</a>是一个浏览器的Solidity IDE, 大家可以点进去看看，以后我们更多文章介绍Solidity这个语言。</p><h3 id="运行环境：EVM"><a href="#运行环境：EVM" class="headerlink" title="运行环境：EVM"></a>运行环境：EVM</h3><p>EVM（Ethereum Virtual Machine）以太坊虚拟机是以太坊中智能合约的运行环境。</p><blockquote><p>Solidity之于EVM，就像之于跟JVM的关系一样，这样大家就容易理解了。<br>以太坊虚拟机是一个隔离的环境，外部无法接触到在EVM内部运行的代码。</p></blockquote><p>而EVM运行在以太坊节点上，当我们把合约部署到以太坊网络上之后，合约就可以在以太坊网络中运行了。</p><h3 id="合约的编译"><a href="#合约的编译" class="headerlink" title="合约的编译"></a>合约的编译</h3><p>以太坊虚拟机上运行的是合约的字节码形式，需要我们在部署之前先对合约进行编译，可以选择<a href="https://ethereum.github.io/browser-solidity" target="_blank" rel="noopener">Browser-Solidity Web IDE</a>或solc编译器。</p><h3 id="合约的部署"><a href="#合约的部署" class="headerlink" title="合约的部署"></a>合约的部署</h3><p>在以太坊上开发应用时，常常要使用到以太坊客户端（钱包）。平时我们在开发中，一般不接触到客户端或钱包的概念，它是什么呢？</p><h4 id="以太坊客户端（钱包）"><a href="#以太坊客户端（钱包）" class="headerlink" title="以太坊客户端（钱包）"></a>以太坊客户端（钱包）</h4><p>以太坊客户端，其实我们可以把它理解为一个开发者工具，它提供账户管理、挖矿、转账、智能合约的部署和执行等等功能。</p><blockquote><p>EVM是由以太坊客户端提供的</p></blockquote><p><strong>Geth</strong>是典型的开发以太坊时使用的客户端，基于Go语言开发。 Geth提供了一个交互式命令控制台，通过命令控制台中包含了以太坊的各种功能（API）。Geth的使用我们之后会有文章介绍，这里大家先有个概念。</p><blockquote><p>Geth控制台和Chrome浏览器开发者工具里的面的控制台是类似的，不过Geth控制台是跑在终端里。<br>相对于Geth，Mist则是图形化操作界面的以太坊客户端。</p></blockquote><h4 id="如何部署"><a href="#如何部署" class="headerlink" title="如何部署"></a>如何部署</h4><p>智能合约的部署是指把合约字节码发布到区块链上，并使用一个特定的地址来标示这个合约，这个地址称为合约账户。</p><blockquote><p>以太坊中有两类账户：</p><ul><li>外部账户<br>该类账户被私钥控制（由人控制），没有关联任何代码。</li><li>合约账户<br>该类账户被它们的合约代码控制且有代码与之关联。</li></ul><blockquote><p>和比特币使用UTXO的设计不一样，以太坊使用更为简单的账户概念。<br>两类账户对于EVM来说是一样的。</p></blockquote><p>外部账户与合约账户的区别和关系是这样的：一个外部账户可以通过创建和用自己的私钥来对交易进行签名，来发送消息给另一个外部账户或合约账户。<br>在两个外部账户之间传送消息是价值转移的过程。但从外部账户到合约账户的消息会激活合约账户的代码，允许它执行各种动作（比如转移代币，写入内部存储，挖出一个新代币，执行一些运算，创建一个新的合约等等）。<br>只有当外部账户发出指令时，合同账户才会执行相应的操作。</p></blockquote><p>合约部署就是将编译好的合约字节码通过外部账号发送交易的形式部署到以太坊区块链上（由实际矿工出块之后，才真正部署成功）。</p><h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><p>合约部署之后，当需要调用这个智能合约的方法时只需要向这个合约账户发送消息（交易）即可，通过消息触发后智能合约的代码就会在EVM中执行了。</p><h2 id="Gas"><a href="#Gas" class="headerlink" title="Gas"></a>Gas</h2><p>和云计算相似，占用区块链的资源（不管是简单的转账交易，还是合约的部署和执行）同样需要付出相应的费用（天下没有免费的午餐对不对!）。<br>以太坊上用Gas机制来计费，Gas也可以认为是一个工作量单位，智能合约越复杂（计算步骤的数量和类型，占用的内存等），用来完成运行就需要越多Gas。<br>任何特定的合约所需的运行合约的Gas数量是固定的，由合约的复杂度决定。<br>而Gas价格由运行合约的人在提交运行合约请求的时候规定，以确定他愿意为这次交易愿意付出的费用：Gas价格（用以太币计价） * Gas数量。</p><p>Gas的目的是限制执行交易所需的工作量，同时为执行支付费用。当EVM执行交易时，Gas将按照特定规则被逐渐消耗，无论执行到什么位置，一旦Gas被耗尽，将会触发异常。当前调用帧所做的所有状态修改都将被回滚， 如果执行结束还有Gas剩余，这些Gas将被返还给发送账户。</p><blockquote><p>如果没有这个限制，就会有人写出无法停止（如：死循环）的合约来阻塞网络。</p></blockquote><p>因此实际上（把前面的内容串起来），我们需要一个有以太币余额的外部账户，来发起一个交易（普通交易或部署、运行一个合约），运行时，矿工收取相应的工作量费用。</p><h2 id="以太坊网络"><a href="#以太坊网络" class="headerlink" title="以太坊网络"></a>以太坊网络</h2><p>有些着急的同学要问了，没有以太币，要怎么进行智能合约的开发？可以选择以下方式：</p><h3 id="选择以太坊官网测试网络Testnet"><a href="#选择以太坊官网测试网络Testnet" class="headerlink" title="选择以太坊官网测试网络Testnet"></a>选择以太坊官网测试网络Testnet</h3><p>测试网络中，我们可以很容易获得免费的以太币，缺点是需要发很长时间初始化节点。</p><h3 id="使用私有链"><a href="#使用私有链" class="headerlink" title="使用私有链"></a>使用私有链</h3><p>创建自己的以太币私有测试网络，通常也称为私有链，我们可以用它来作为一个测试环境来开发、调试和测试智能合约。<br>通过上面提到的Geth很容易就可以创建一个属于自己的测试网络，以太币想挖多少挖多少，也免去了同步正式网络的整个区块链数据。</p><h3 id="使用开发者网络-模式"><a href="#使用开发者网络-模式" class="headerlink" title="使用开发者网络(模式)"></a>使用开发者网络(模式)</h3><p>相比私有链，开发者网络(模式)下，会自动分配一个有大量余额的开发者账户给我们使用。</p><h3 id="使用模拟环境"><a href="#使用模拟环境" class="headerlink" title="使用模拟环境"></a>使用模拟环境</h3><p>另一个创建测试网络的方法是使用testrpc，testrpc是在本地使用内存模拟的一个以太坊环境，对于开发调试来说，更方便快捷。而且testrpc可以在启动时帮我们创建10个存有资金的测试账户。<br>进行合约开发时，可以在testrpc中测试通过后，再部署到Geth节点中去。</p><blockquote><p>更新：testrpc 现在已经并入到Truffle 开发框架中，现在名字是Ganache CLI。</p></blockquote><h2 id="Dapp：去中心化的应用程序"><a href="#Dapp：去中心化的应用程序" class="headerlink" title="Dapp：去中心化的应用程序"></a>Dapp：去中心化的应用程序</h2><p>以太坊社区把基于智能合约的应用称为去中心化的应用程序(Decentralized App)。如果我们把区块链理解为一个不可篡改的数据库，智能合约理解为和数据库打交道的程序，那就很容易理解Dapp了，一个Dapp不单单有智能合约，比如还需要有一个友好的用户界面和其他的东西。</p><h3 id="Truffle"><a href="#Truffle" class="headerlink" title="Truffle"></a>Truffle</h3><p>Truffle是Dapp开发框架，他可以帮我们处理掉大量无关紧要的小事情，让我们可以迅速开始写代码-编译-部署-测试-打包DApp这个流程。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我们现在来总结一下，以太坊是平台，它让我们方便的使用区块链技术开发去中心化的应用，在这个应用中，使用Solidity来编写和区块链交互的智能合约，合约编写好后之后，我们需要用以太坊客户端用一个有余额的账户去部署及运行合约（使用Truffle框架可以更好的帮助我们做这些事情了）。为了开发方便，我们可以用Geth或testrpc来搭建一个测试网络。</p><p>注：本文中为了方便大家理解，对一些概念做了类比，有些严格来不是准确，不过我也认为对于初学者，也没有必要把每一个概念掌握的很细致和准确，学习是一个逐步深入的过程，很多时候我们会发现，过一段后，我们会对同一个东西有不一样的理解。</p><p>本文完，这些概念你都明白了么？现在你可以开始开发了，看看<a href="https://learnblockchain.cn/2017/11/24/init-env/">智能合约开发环境搭建及Hello World合约</a></p><p><a href="https://learnblockchain.cn/">深入浅出区块链</a> - 系统学习区块链，打造最好的区块链技术博客。<br>我的<strong><a href="https://t.xiaomiquan.com/RfAu7uj" target="_blank" rel="noopener">知识星球</a></strong>为各位解答区块链技术问题，欢迎加入讨论。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;很多同学已经跃跃欲试投入到区块链开发队伍当中来，可是又感觉无从下手，本文将基于以太坊平台，以通俗的方式介绍以太坊开发中涉及的各晦涩的概念，轻松带大家入门。&lt;/p&gt;
    
    </summary>
    
      <category term="以太坊" scheme="https://learnblockchain.cn/categories/ethereum/"/>
    
    
      <category term="以太坊概念" scheme="https://learnblockchain.cn/tags/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%A6%82%E5%BF%B5/"/>
    
      <category term="以太坊入门" scheme="https://learnblockchain.cn/tags/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E5%85%A5%E9%97%A8/"/>
    
      <category term="ethereum" scheme="https://learnblockchain.cn/tags/ethereum/"/>
    
  </entry>
  
  <entry>
    <title>非对称加密技术- RSA算法数学原理分析</title>
    <link href="https://learnblockchain.cn/2017/11/15/asy-encryption/"/>
    <id>https://learnblockchain.cn/2017/11/15/asy-encryption/</id>
    <published>2017-11-15T02:53:27.000Z</published>
    <updated>2018-01-10T08:09:47.985Z</updated>
    
    <content type="html"><![CDATA[<p>非对称加密技术，在现在网络中，有非常广泛应用。加密技术更是数字货币的基础。</p><p>所谓非对称，就是指该算法需要一对密钥，使用其中一个（公钥）加密，则需要用另一个（私钥）才能解密。<br>但是对于其原理大部分同学应该都是一知半解，今天就来分析下经典的非对称加密算法 - RSA算法。<br>通过本文的分析，可以更好的理解非对称加密原理，可以让我们更好的使用非对称加密技术。</p><a id="more"></a><p>题外话:<br>并博客一直有打算写一系列文章通俗的密码学，昨天给站点上https, 因其中使用了RSA算法，就查了一下，发现现在网上介绍RSA算法的文章都写的太难理解了，反正也准备写密码学，就先写RSA算法吧，下面开始正文。</p><h2 id="RSA算法原理"><a href="#RSA算法原理" class="headerlink" title="RSA算法原理"></a>RSA算法原理</h2><p>RSA算法的基于这样的数学事实：两个大质数相乘得到的大数难以被因式分解。<br>如：有很大质数p跟q，很容易算出N，使得 N = p * q，<br>但给出N, 比较难找p q（没有很好的方式， 只有不停的尝试）</p><blockquote><p>这其实也是单向函数的概念</p></blockquote><p>下面来看看<strong>数学演算过程</strong>：</p><ol><li><p>选取两个大质数p，q，计算N = p <em> q 及 φ ( N ) = φ (p) </em> φ (q)  = (p-1) * (q-1)</p><blockquote><p>三个数学概念：<br><strong>质数</strong>(prime numbe)：又称素数，为在大于1的自然数中，除了1和它本身以外不再有其他因数。<br><strong>互质关系</strong>：如果两个正整数，除了1以外，没有其他公因子，我们就称这两个数是<strong>互质关系</strong>（coprime）。<br><strong>φ(N)</strong>：叫做<strong>欧拉函数</strong>，是指任意给定正整数N，在小于等于N的正整数之中，有多少个与N构成互质关系。</p><blockquote><p>如果n是质数，则 φ(n)=n-1。<br>如果n可以分解成两个互质的整数之积， φ(n) = φ(p1p2) = φ(p1)φ(p2)。即积的欧拉函数等于各个因子的欧拉函数之积。</p></blockquote></blockquote></li><li><p>选择一个大于1 小于φ(N)的数e，使得 e 和 φ(N)互质</p><blockquote><p>e其实是1和φ(N)之前的一个质数</p></blockquote></li><li><p>计算d，使得d<em>e=1 mod φ(N) 等价于方程式 ed-1 = k </em> φ(N) 求一组解。</p><blockquote><p>d 称为e的模反元素，e 和 φ(N)互质就肯定存在d。</p><blockquote><p><strong>模反元素</strong>是指如果两个正整数a和n互质，那么一定可以找到整数b，使得ab被n除的余数是1，则b称为a的模反元素。<br>可根据欧拉定理证明模反元素存在，<strong>欧拉定理</strong>是指若n,a互质，则：<img src="/images/aes_mod.png" alt=""><br>a^φ(n) ≡ 1(mod n)  及 a^φ(n) = a * a^（φ(n) - 1）， 可得a的 φ(n)-1 次方，就是a的模反元素。</p></blockquote></blockquote></li><li><p>(N, e)封装成公钥，(N, d)封装成私钥。<br>假设m为明文，加密就是算出密文c:<br> m^e mod N = c (明文m用公钥e加密并和随机数N取余得到密文c)<br>解密则是：<br> c^d mod N = m　(密文c用密钥解密并和随机数N取余得到明文m)</p><blockquote><p>私钥解密这个是可以证明的，这里不展开了。</p></blockquote></li></ol><h2 id="加解密步骤"><a href="#加解密步骤" class="headerlink" title="加解密步骤"></a>加解密步骤</h2><p>具体还是来看看步骤，举个例子，假设Alice和Bob又要相互通信。</p><ol><li>Alice 随机取大质数P1=53，P2=59，那N=53*59=3127，φ(N)=3016</li><li>取一个e=3，计算出d=2011。</li><li>只将N=3127，e=3 作为公钥传给Bob（公钥公开）</li><li>假设Bob需要加密的明文m=89，c = 89^3 mod 3127=1394，于是Bob传回c=1394。 （公钥加密过程）</li><li>Alice使用c^d mod N = 1394^2011 mod 3127，就能得到明文m=89。 （私钥解密过程）</li></ol><p>假如攻击者能截取到公钥n=3127，e=3及密文c=1394，是仍然无法不通过d来进行密文解密的。</p><h2 id="安全性分析"><a href="#安全性分析" class="headerlink" title="安全性分析"></a>安全性分析</h2><p>那么，有无可能在已知n和e的情况下，推导出d？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">　　1. ed≡1 (mod φ(n))。只有知道e和φ(n)，才能算出d。</span><br><span class="line">　　2. φ(n)=(p-1)(q-1)。只有知道p和q，才能算出φ(n)。</span><br><span class="line">　　3. n=pq。只有将n因数分解，才能算出p和q。</span><br></pre></td></tr></table></figure></p><p>如果n可以被因数分解，d就可以算出，因此RSA安全性建立在N的因式分解上。大整数的因数分解，是一件非常困难的事情。<br>只要密钥长度足够长，用RSA加密的信息实际上是不能被解破的。</p><h2 id="补充模运算规则"><a href="#补充模运算规则" class="headerlink" title="补充模运算规则"></a>补充模运算规则</h2><ol><li>模运算加减法：<br> (a + b) mod p = (a mod p + b mod p) mod p<br> (a - b) mod p = (a mod p - b mod p) mod p</li><li>模运算乘法：<br> (a <em> b) mod p = (a mod p </em> b mod p) mod p</li><li>模运算幂<br> a ^ b mod p = ((a mod p)^b) mod p</li></ol><p><a href="https://learnblockchain.cn/">深入浅出区块链</a> - 系统学习区块链，打造最好的区块链技术博客。<br>我的<strong><a href="https://t.xiaomiquan.com/RfAu7uj" target="_blank" rel="noopener">知识星球</a></strong>为各位解答区块链技术问题，欢迎加入讨论。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;非对称加密技术，在现在网络中，有非常广泛应用。加密技术更是数字货币的基础。&lt;/p&gt;
&lt;p&gt;所谓非对称，就是指该算法需要一对密钥，使用其中一个（公钥）加密，则需要用另一个（私钥）才能解密。&lt;br&gt;但是对于其原理大部分同学应该都是一知半解，今天就来分析下经典的非对称加密算法 - RSA算法。&lt;br&gt;通过本文的分析，可以更好的理解非对称加密原理，可以让我们更好的使用非对称加密技术。&lt;/p&gt;
    
    </summary>
    
      <category term="密码学" scheme="https://learnblockchain.cn/categories/cryptography/"/>
    
    
      <category term="非对称加密" scheme="https://learnblockchain.cn/tags/%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/"/>
    
      <category term="数学" scheme="https://learnblockchain.cn/tags/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="RSA算法" scheme="https://learnblockchain.cn/tags/RSA%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>比特币脚本及交易分析 - 智能合约雏形</title>
    <link href="https://learnblockchain.cn/2017/11/10/bitcoin-script/"/>
    <id>https://learnblockchain.cn/2017/11/10/bitcoin-script/</id>
    <published>2017-11-10T09:05:33.000Z</published>
    <updated>2018-01-10T08:10:40.795Z</updated>
    
    <content type="html"><![CDATA[<p>大家都有转过账，每笔交易是这样的：张三账上减￥200，李四账上加￥200。<br>在比特币区块链中，交易不是这么简单，交易实际是通过脚本来完成，以承载更多的功能个，这也是为什么比特币被称为是一种“可编程的货币”。<br>本文就来分析一下交易是如何实现可编程的。</p><a id="more"></a><h2 id="未花费的交易输出-UTXO"><a href="#未花费的交易输出-UTXO" class="headerlink" title="未花费的交易输出(UTXO)"></a>未花费的交易输出(UTXO)</h2><p>先引入一个概念：未花费的交易输出——UTXO（Unspent Transaction Output）</p><p>其实比特币的交易都是基于UTXO上的，即交易的输入是之前交易未花费的输出，这笔交易的输出可以被当做下一笔新交易的输入。</p><blockquote><p>挖矿奖励属于一个特殊的交易（称为coinbase交易），可以没有输入。<br>UTXO是交易的基本单元，不能在分割。<br>在比特币没有余额概念，只有分散到区块链里的UTXO</p></blockquote><p>随着钱从一个地址被移动到另一个地址的同时形成了一条所有权链，像这样：<br><img src="/images/own_chain.jpeg" alt="own_chain"></p><h2 id="比特币脚本"><a href="#比特币脚本" class="headerlink" title="比特币脚本"></a>比特币脚本</h2><p>比特币交易是首先要提供一个用于解锁UTXO（用私钥去匹配锁定脚本）的脚本（常称为解锁脚本：Signature script)，这也叫交易输入，<br>交易的输出则是指向一个脚本（称为锁定脚本：PubKey script），这个脚本表达了：谁的签名（签名是常见形式，并不一定必须是签名）能匹配这个输出地址，钱就支付给谁。</p><p>每一个比特币节点会通过同时执行这解锁和锁定脚本（不是当前的锁定脚本，是指上一个交易的锁定脚本）来验证一笔交易，脚本组合结果为真，则为有效交易。</p><blockquote><p>当解锁版脚本与锁定版脚本的设定条件相匹配时，执行组合有效脚本时才会显示结果为真</p></blockquote><p>如最为常见类型的比特币交易脚本（支付到公钥哈希：P2PKH（Pay-to-Public-Key-Hash））组合是这样：<br><img src="/images/script.jpeg" alt="script"></p><h3 id="常见交易脚本验证过程"><a href="#常见交易脚本验证过程" class="headerlink" title="常见交易脚本验证过程"></a>常见交易脚本验证过程</h3><p>比特币交易脚本语言是一种基于逆波兰表示法的基于栈的执行语言（不知道逆波兰和栈的同学去翻大学数据结构课本，你也可跳过这个部分）。</p><blockquote><p>比特币脚本语言包含基本算数计算、基本逻辑(比如if…then)、报错以及返回结果和一些加密指令，不支持循环。想了解更多语言细节可参考:<a href="http://www.8btc.com/bitcoin_scripts" target="_blank" rel="noopener">比特币脚本</a></p></blockquote><p>脚本语言通过从左至右地处理每个项目的方式执行脚本。</p><p>下面用两个图说明下常见类型的比特币交易脚本验证执行过程：<br><img src="/images/script_run1.jpeg" alt="script_run1"><br>上图为解锁脚本运行过程（主要是入栈）<br><img src="/images/script_run2.jpeg" alt="script_run2"><br>上图为锁定脚本运行过程（主要是出栈），最后的结果为真，说明交易有效。</p><h2 id="交易分析"><a href="#交易分析" class="headerlink" title="交易分析"></a>交易分析</h2><p>实际上比特币的交易被设计为可以纳入多个输入和输出。</p><h3 id="交易结构"><a href="#交易结构" class="headerlink" title="交易结构"></a>交易结构</h3><p>我们来看看完整的交易结构，<br><img src="/images/tx_struce.jpeg" alt=""></p><blockquote><p>交易的锁定时间定义了能被加到区块链里的最早的交易时间。在大多数交易里，它被设置成0，用来表示立即执行。<br>如果锁定时间不是0并且小于5亿，就被视为区块高度，意指在这个指定的区块高度之前，该交易不会被包含在区块链里。<br>如果锁定时间大于5亿，则它被当作是一个Unix纪元时间戳（从1970年1月1日以来的秒数），并且在这个指定时间之前，该交易不会被包含在区块链里。</p></blockquote><p>交易的数据结构没有交易费的字段，交易费通过所有输入的总和，以及所有输出的总和之间的差来表示，即：</p><blockquote><p>交易费 = 求和（所有输入） - 求和（所有输出）</p></blockquote><h3 id="交易输入结构"><a href="#交易输入结构" class="headerlink" title="交易输入结构"></a>交易输入结构</h3><p>刚刚我们提过输入需要提供一个解锁脚本，现在来看看一个交易的输入结构：<br><img src="/images/tx_input_struce.jpeg" alt=""></p><p>我们结合整个交易的结构里看输入结构就是这样子：<br><img src="/images/tx_input_overview.jpeg" alt=""></p><h3 id="交易输出结构"><a href="#交易输出结构" class="headerlink" title="交易输出结构"></a>交易输出结构</h3><p>刚刚我们提过输出是指向一个解锁脚本，具体交易的输出结构为：<br><img src="/images/tx_output_struce.jpeg" alt=""><br>我们结合整个交易的结构里看输出结构就是这样子：<br><img src="/images/tx_output_overview.jpeg" alt=""></p><h3 id="交易哈希计算"><a href="#交易哈希计算" class="headerlink" title="交易哈希计算"></a>交易哈希计算</h3><p>在<a href="https://xiaozhuanlan.com/topic/1402935768" target="_blank" rel="noopener">比特币区块结构Merkle 树及简单支付验证分析</a> 讲到区块结构，区块结构包含多个交易的哈希。<br>那么交易哈希是怎么计算的呢？</p><ol><li>交易结构各字段序列化为字节数组</li><li>把字节数组拼接为支付串</li><li>对支付串计算两次SHA256 得到交易hash</li></ol><p>了解详情可进一步参考<a href="https://bitcoin.stackexchange.com/questions/2859/how-are-transaction-hashes-calculated" target="_blank" rel="noopener">如何计算交易Hash?</a>及<a href="https://bitcointalk.org/index.php?topic=54451.msg649253#msg649253" target="_blank" rel="noopener">如何创建Hash?</a></p><p>现在是不是对完整的交易到区块有了更清晰的认识。</p><h2 id="智能合约雏形-应用场景说明"><a href="#智能合约雏形-应用场景说明" class="headerlink" title="智能合约雏形 - 应用场景说明"></a>智能合约雏形 - 应用场景说明</h2><p>由于交易是通过脚本来实现，脚本语言可以表达出无数的条件变种。</p><p>比特币的脚本目前常用的主要分为两种，一种是常见的P2PKH（支付给公钥哈希），另一种是P2SH（Pay-to-Script-Hash支付脚本哈希）。<br>P2SH支付中，锁定脚本被密码学哈希所取代，当一笔交易试图支付UTXO时，要解锁支付脚本，它必须含有与哈希相匹配的脚本。</p><p>这里不展开技术细节，下面说明一些应用场景，以便大家有更直观的认识。</p><ul><li><p>多重签名应用<br>合伙经营中，如只有一半以上的的股东同意签名就可以进行支付，可为公司治理提供管控便利，同时也能有效防范盗窃、挪用和遗失。</p><p>用于担保和争端调解，一个买家想和他不认识或不信任的某人交易，在一般情况交易正常进行时，买家不想任何第三方参与。那交易双方可以发起支付，但如果交易出现问题时，那第三方就可以根据裁定，使用自己的签名和裁定认可的一方共同签名来兑现这笔交易。</p></li><li><p>保证合同<br>保证合同是建造公众商品时的集资办法，公众商品是指一旦建成，任何人都可以免费享受到好处。标准的例子是灯塔，所有人都认同应该建造一个，但是对于个人航海者来说灯塔太贵了，灯塔同时也会方便其他航海者。<br>一个解决方案是向所有人集资，只有当筹集的资金超过所需的建造成本时，每个人才真正付钱，如果集资款不足，则谁都不用付钱。</p></li><li>依靠预言<br>假如老人想让他孙子继承遗产，继承时间是在他死后或者在孙子年满18岁时（也是一个带锁定时间交易），无论哪个条件先满足，他的孙子都可以得到遗产。<br>因为比特币节点可依靠预言对死亡条件进行判断，预言是指具有密钥对的服务器，当用户自定义的表达式被证明是真的，它能按照要求对交易签名。</li></ul><p>相信随着区块链的普及，会对未来的交易模式和商业结构带来巨大的影响。不过由于比特币的脚本语言不是图灵完备的，交易模式依旧有限，以太坊就是为解决这一问题而出现，后面我们会有大量介绍以太坊的文章。</p><h2 id="参考文献-amp-补充阅读"><a href="#参考文献-amp-补充阅读" class="headerlink" title="参考文献 &amp; 补充阅读"></a>参考文献 &amp; 补充阅读</h2><ol><li><a href="http://book.8btc.com/master_bitcoin" target="_blank" rel="noopener">精通比特币</a></li><li>廖雪峰的<a href="http://www.infoq.com/cn/articles/deep-understanding-of-bitcoin-transaction-script" target="_blank" rel="noopener">深入理解比特币交易的脚本</a></li><li><a href="http://www.8btc.com/bitcoin_contracts" target="_blank" rel="noopener">比特币合同</a></li></ol><p><a href="https://learnblockchain.cn/">深入浅出区块链</a> - 系统学习区块链，打造最好的区块链技术博客。<br>我的<strong><a href="https://t.xiaomiquan.com/RfAu7uj" target="_blank" rel="noopener">知识星球</a></strong>为各位解答区块链技术问题，欢迎加入讨论。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;大家都有转过账，每笔交易是这样的：张三账上减￥200，李四账上加￥200。&lt;br&gt;在比特币区块链中，交易不是这么简单，交易实际是通过脚本来完成，以承载更多的功能个，这也是为什么比特币被称为是一种“可编程的货币”。&lt;br&gt;本文就来分析一下交易是如何实现可编程的。&lt;/p&gt;
    
    </summary>
    
      <category term="比特币" scheme="https://learnblockchain.cn/categories/bitcoin/"/>
    
    
      <category term="比特币脚本" scheme="https://learnblockchain.cn/tags/%E6%AF%94%E7%89%B9%E5%B8%81%E8%84%9A%E6%9C%AC/"/>
    
      <category term="交易结构" scheme="https://learnblockchain.cn/tags/%E4%BA%A4%E6%98%93%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>比特币区块结构Merkle树及简单支付验证分析</title>
    <link href="https://learnblockchain.cn/2017/11/09/merkle/"/>
    <id>https://learnblockchain.cn/2017/11/09/merkle/</id>
    <published>2017-11-09T02:03:36.000Z</published>
    <updated>2018-01-10T08:11:16.136Z</updated>
    
    <content type="html"><![CDATA[<p>在比特币网络中，不是每个节点都有能力储存完整的区块链数据，受限于存储空间的的限制，很多节点是以SPV（Simplified Payment Verification简单支付验证）钱包接入比特币网络，通过简单支付验证可以在不必存储完整区块链下对交易进行验证，本文将分析区块结构Merkle树及如何进行交易验证。</p><a id="more"></a><h2 id="区块结构"><a href="#区块结构" class="headerlink" title="区块结构"></a>区块结构</h2><p>在<a href="https://xiaozhuanlan.com/topic/7548206913" target="_blank" rel="noopener">工作量证明</a>中出现过一个区块信息截图：<br><img src="/images/block_info_493050.jpg" alt="区块#493050"></p><p>细心的同学一定已经在里面发现了很多未讲的其他信息，如：时间戳，版本号，交易次数，二进制哈希树根(Merkle根)等。</p><p>我们来看看一个区块结构到底是怎样的：</p><p><img src="/images/block_structure.jpeg" alt="区块结构图"></p><p>如上图（下文称：区块结构图）所示：每个数据区块包含区块头和区块体。<br>区块头封装了当前版本号、前一区块哈希值、当前区块PoW要求的随机数(Nonce)、时间戳、以及Merkle根信息。<br>区块体则包括当前区块经过验证的、 区块创建过程中生成的所有交易记录。这些记录通过 Merkle树的哈希过程生成唯一的Merkle根并记入区块头.</p><blockquote><p>区块哈希值实际上并不包含在区块的数据结构里，其实区块打包时只有区块头被用于计算哈希（从网络被接收时由每个节点计算出来），常说的区块哈希值实际是区块头哈希值，它可以用来唯一、明确地标识一个区块。</p></blockquote><p>区块头是80字节，而平均每个交易至少是250字节，而且平均每个区块包含2000个交易。因此，包含完整交易的区块比区块头的4千倍还要大。<br>SPV节点只下载区块头，不下载包含在每个区块中的交易信息。这样的不含交易信息的区块链，大小只有完整区块链的几千分之1，那SPV节点是如何验证交易的呢？</p><h2 id="哈希验证"><a href="#哈希验证" class="headerlink" title="哈希验证"></a>哈希验证</h2><p>上面先留一个引子，先来回顾下哈希函数，<a href="https://xiaozhuanlan.com/topic/9827453061" target="_blank" rel="noopener">记账原理</a>我们知道原始信息任何微小的变化都会哈希完全不同的哈希值。</p><h3 id="简单文件验证"><a href="#简单文件验证" class="headerlink" title="简单文件验证"></a>简单文件验证</h3><p>我们通常用哈希来检验下载的文件是否完整，我经常看到这样的下载页面：<br><img src="/images/ex_check_file.jpeg" alt="下载hash"><br>可以看到下载链接后面提供了一个MD5（MD5也是一种Hash算法），这样我们可以在下载之后对文件计算MD5，如果MD5与提供的MD5相等，说明文件有没有被损坏，这个验证过程相信大家都能理解。</p><h3 id="多点文件验证-哈希列表"><a href="#多点文件验证-哈希列表" class="headerlink" title="多点文件验证(哈希列表)"></a>多点文件验证(哈希列表)</h3><p>现在复杂度提高一点，在P2P网络中下载时，会把大文件切成小文件，同时从多个机器上下载数据，这个时候怎么验证数据呢？</p><p>以BT下载为例，在下载真正的数据之前，我们会先下载一个哈希列表的（每个下小块计算出一个哈希），如果有一个小块数据在传输过程中损坏了，那我只要重新下载这一个数据块就行了，这时有一个问题就出现了，那么多的哈希，怎么保证它们本身(哈希列表中的哈希值)都是正确地呢？</p><p>答案是把每个小块数据的哈希值拼到一起，然后对这个长字符串在作一次哈希运算，得到哈希列表的根哈希。只要根哈希校对比一样就说明验哈希列表是正确的，再通过哈希列表校验小数据块，如果所有的小数据块验证通过则说明大文件没有被损坏。</p><h2 id="Merkle树"><a href="#Merkle树" class="headerlink" title="Merkle树"></a>Merkle树</h2><p>验证交易的过程和文件验证很相似，可以人为每个交易是一个小数据块，但比特币使用Merkle树的方式进行验证，相对于哈希列表，Merkle树是一种哈希二叉树，它的明显的一个好处是可以单独拿出一个分支来（作为一个小树）对部分数据进行校验，更加高效。</p><p>我们回看下上面的区块结构图，区块体就包含这样一个Merkle树,Merkle树被用来归纳一个区块中的所有交易。</p><p>每个叶子节点是每个交易信息的哈希，往上对相邻的两个哈希合并成字符串再哈希，继续类似的操作直到只剩下顶部的一个节点，即Merkle根，存入区块头。</p><p>因为Merkle树是二叉树，所以它需要偶数个叶子节点。如果仅有奇数个交易需要归纳，那最后的交易就会被复制一份以构成偶数个叶子节点，这种偶数个叶子节点的树也被称为平衡树。</p><h3 id="简化支付验证"><a href="#简化支付验证" class="headerlink" title="简化支付验证"></a>简化支付验证</h3><p>SPV节点不保存所有交易也不会下载整个区块，仅仅保存区块头，我们来看看它是如何对交易数据进行验证的。</p><p>假如要验证区块结构图中交易6，SPV节点会通过向相邻节点索要（通过Merkleblock消息）包括从交易6哈希值沿Merkle树上溯至区块头根哈希处的哈希序列 (即哈希节点6, 5, 56, 78, 5678, 1234 1~8 - 称为认证路径) 来确认交易的存在性和正确性。（在N个交易组成的区块中确认任一交易只需要计算log2(N)个字节的哈希值，非常快速高效）</p><p>大家明白了吗？</p><p><a href="https://learnblockchain.cn/">深入浅出区块链</a> - 系统学习区块链，打造最好的区块链技术博客。<br>我的<strong><a href="https://t.xiaomiquan.com/RfAu7uj" target="_blank" rel="noopener">知识星球</a></strong>为各位解答区块链技术问题，欢迎加入讨论。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在比特币网络中，不是每个节点都有能力储存完整的区块链数据，受限于存储空间的的限制，很多节点是以SPV（Simplified Payment Verification简单支付验证）钱包接入比特币网络，通过简单支付验证可以在不必存储完整区块链下对交易进行验证，本文将分析区块结构Merkle树及如何进行交易验证。&lt;/p&gt;
    
    </summary>
    
      <category term="比特币" scheme="https://learnblockchain.cn/categories/bitcoin/"/>
    
    
      <category term="比特币" scheme="https://learnblockchain.cn/tags/%E6%AF%94%E7%89%B9%E5%B8%81/"/>
    
      <category term="区块结构" scheme="https://learnblockchain.cn/tags/%E5%8C%BA%E5%9D%97%E7%BB%93%E6%9E%84/"/>
    
      <category term="Merkle树" scheme="https://learnblockchain.cn/tags/Merkle%E6%A0%91/"/>
    
      <category term="SPV简单支付验证" scheme="https://learnblockchain.cn/tags/SPV%E7%AE%80%E5%8D%95%E6%94%AF%E4%BB%98%E9%AA%8C%E8%AF%81/"/>
    
  </entry>
  
  <entry>
    <title>分析比特币网络：一种去中心化、点对点的网络架构</title>
    <link href="https://learnblockchain.cn/2017/11/07/bitcoin-p2p/"/>
    <id>https://learnblockchain.cn/2017/11/07/bitcoin-p2p/</id>
    <published>2017-11-07T03:25:30.000Z</published>
    <updated>2018-01-10T08:10:25.199Z</updated>
    
    <content type="html"><![CDATA[<p>比特币采用了基于互联网的点对点（P2P：peer-to-peer）分布式网络架构。<br>比特币网络可以认为是按照比特币P2P协议运行的一系列节点的集合。<br>本文来分析下比特币网络，了解它跟传统中心化网络的区别，以及比特币网络是如何发现相邻节点的。</p><a id="more"></a><h2 id="中心化网络"><a href="#中心化网络" class="headerlink" title="中心化网络"></a>中心化网络</h2><p>为了更好的理解P2P网络，我们先来看看传统的中心化模型：<br><img src="/images/cs_network.jpeg" alt="中心化网络模型"></p><p>这是一种典型的星型（“中心化”）结构，我们常见B/S及C/S网络架构就是这种模型，C1 、C2 、C3等之间没法直接的连接，C节点如果要连接必须要通过中心化S节点做为桥梁。<br>中心化节点充当服务者、中介作用，比如我们没有办法把资金直接从一个人转移给另一个人，必须通过银行这个中介。</p><h2 id="P2P网络"><a href="#P2P网络" class="headerlink" title="P2P网络"></a>P2P网络</h2><p>P2P网络是指位于同一网络中的每台计算机都彼此对等，各个节点共同提供网络服务，不存在任何“特殊”节点，每个网络节点以扁平（flat）的拓扑结构相互连通。<br><img src="/images/p2p_network.jpeg" alt="p2p网络模型"></p><p>对比中心化网络，在P2P网络中不存在任何服务端（server）、中央化的服务。<br>P2P网络的节点之间交互连接、协同，每个节点在对外提供服务的同时也使用网络中其他节点所提供的服务，每个节点即是服务端又是客户端。<br>P2P网络模型除应用于比特币网络，使用广泛的BT下载就是基于P2P网络。</p><p>P2P网络不仅仅去除了中心化带来的风险（中心化可能作恶），还可以提高传输的效率。（中心化网络当能也有优点）</p><h2 id="如何发现节点"><a href="#如何发现节点" class="headerlink" title="如何发现节点"></a>如何发现节点</h2><p>既然每个网络节点都是平等的（是指在网络层面上节点是平等的，但各节点在功能上可以有不同的分工, 如钱包节点、挖矿节点等），不存在任何“特殊”中心节点，那么当新的网络节点启动后，它是如何跟其他的节点建立连接，从而加入到比特币网络呢？</p><blockquote><p>在中心化网络中，新加入的节点只要连接“特殊”的中心节点就可以加入网络。</p></blockquote><p>为了能够加入到比特币网络，比特币客户端会做一下几件事情：</p><ol><li><p>节点会记住它最近成功连接的网络节点，当重新启动后它可以迅速与先前的对等节点网络重新建立连接。</p></li><li><p>节点会在失去已有连接时尝试发现新节点。</p></li><li><p>当建立一个或多个连接后，节点将一条包含自身IP地址消息发送给其相邻节点。相邻节点再将此消息依次转发给它们各自的相邻节点，从而保证节点信息被多个节点所接收、保证连接更稳定。</p></li><li><p>新接入的节点可以向它的相邻节点发送获取地址getaddr消息，要求它们返回其已知对等节点的IP地址列表。节点可以找到需连接到的对等节点。</p></li><li><p>在节点启动时，可以给节点指定一个正活跃节点IP, 如果没有，客户端也维持一个列表，列出了那些长期稳定运行的节点。这样的节点也被称为种子节点（其实和BT下载的种子文件道理是一样的），就可以通过种子节点来快速发现网络中的其他节点。</p></li></ol><h2 id="节点通信简述"><a href="#节点通信简述" class="headerlink" title="节点通信简述"></a>节点通信简述</h2><p>比特币节点通常采用TCP协议、使用8333端口与相邻节点建立连接, 建立连接时也会有认证“握手”的通信过程，用来确定协议版本，软件版本，节点IP，区块高度等。</p><p>当节点连接到相邻节点后，接着就开始跟相邻节点同步区块链数据（轻量级钱包应用其实不会同步所有区块数据），节点们会交换一个getblocks消息，它包含本地区块链最顶端的哈希值。如果某个节点识别出它接收到的哈希值并不属于顶端区块，而是属于一个非顶端区块的旧区块，就说其自身的本地区块链比其他节点的区块链更长，并告诉其他节点需要补充区块，其他节点发送getdata消息来请求区块，验证后更新到本地区块链中。</p><p><a href="https://learnblockchain.cn/">深入浅出区块链</a> - 系统学习区块链，打造最好的区块链技术博客<br>我的<strong><a href="https://t.xiaomiquan.com/RfAu7uj" target="_blank" rel="noopener">知识星球</a></strong>为各位解答区块链技术问题，欢迎加入讨论。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;比特币采用了基于互联网的点对点（P2P：peer-to-peer）分布式网络架构。&lt;br&gt;比特币网络可以认为是按照比特币P2P协议运行的一系列节点的集合。&lt;br&gt;本文来分析下比特币网络，了解它跟传统中心化网络的区别，以及比特币网络是如何发现相邻节点的。&lt;/p&gt;
    
    </summary>
    
      <category term="比特币" scheme="https://learnblockchain.cn/categories/bitcoin/"/>
    
    
      <category term="p2p" scheme="https://learnblockchain.cn/tags/p2p/"/>
    
      <category term="去中心化" scheme="https://learnblockchain.cn/tags/%E5%8E%BB%E4%B8%AD%E5%BF%83%E5%8C%96/"/>
    
      <category term="比特币网络" scheme="https://learnblockchain.cn/tags/%E6%AF%94%E7%89%B9%E5%B8%81%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>比特币如何挖矿（挖矿原理）-工作量证明</title>
    <link href="https://learnblockchain.cn/2017/11/04/bitcoin-pow/"/>
    <id>https://learnblockchain.cn/2017/11/04/bitcoin-pow/</id>
    <published>2017-11-04T08:12:29.000Z</published>
    <updated>2018-01-10T08:10:29.562Z</updated>
    
    <content type="html"><![CDATA[<p>在<a href="/2017/10/25/whatbc/" title="区块链记账原理">区块链记账原理</a> 一篇，我们了解到记账是把交易记录、交易时间、账本序号、上一个Hash值等信息计算Hash打包的过程。<br>我们知道所有的计算和存贮是需要消耗计算机资源的，既然要付出成本，那节点为什么还要参与记账呢？在中本聪（比特币之父）的设计里，完成记账的节点可以获得系统给与的一定数量的比特币奖励，这个奖励的过程也就是比特币的发行过程，因此大家形象的把记账称为“挖矿”，本文将详细讨论这个过程。</p><a id="more"></a><h2 id="记账工作"><a href="#记账工作" class="headerlink" title="记账工作"></a>记账工作</h2><p>由于记账是有奖励的，每次记账都可以给自己凭空增加一定数量的个比特币（当前是12.5比特币，博文写作时每个比特币是4万人民币以上，大家可以算算多少钱），因此就出现大家争相记账，大家一起记账就会引起问题：出现记账不一致的问题，比特币系统引入工作量证明来解决这个问题，规则如下：</p><ul><li>一段时间内（10分钟左右，具体时间会与密码学难题难度相互影响）只有一人可以记账成功</li><li>通过解决密码学难题（即工作量证明）竞争获得唯一记账权</li><li>其他节点复制记账结果</li></ul><p>不过在进行工作量证明之前，记账节点会做进行如下准备工作：</p><ul><li>收集广播中还没有被记录账本的原始交易信息</li><li>检查每个交易信息中付款地址有没有足够的余额</li><li>验证交易是否有正确的签名</li><li>把验证通过的交易信息进行打包记录</li><li>添加一个奖励交易：给自己的地址增加12.5比特币</li></ul><p>如果节点争夺记账权成功的话，就可以得到12.5比特币的奖励。</p><h2 id="工作量证明"><a href="#工作量证明" class="headerlink" title="工作量证明"></a>工作量证明</h2><a href="/2017/10/25/whatbc/" title="区块链记账原理">区块链记账原理</a>我们了解到，每次记账的时候回把上一个块的Hash值和当前的账页信息一起作为原始信息进行Hash。<br>如果仅仅是这样，显然每个人都可以很轻松的完成记账。<br>为了保证10分钟左右只有一个人可以记账，就必须要提高记账的难度，使得Hash的结果必须以若干个0开头。同是为了满足这个条件，在进行Hash时引入一个随机数变量。<br><br>用伪代码表示一下：<br><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 没有难度时为：Hash(上一个Hash值，交易记录集) = 456635BCD</span></span><br><span class="line">Hash(上一个Hash值，交易记录集，随机数) = <span class="number">0000</span>aFD635BCD</span><br></pre></td></tr></table></figure><p>我们知道改变Hash的原始信息的任何一部分，Hash值也会随之不断的变化，因此在运算Hash时，不断的改变随机数的值，总可以找的一个随机数使的Hash的结果以若干个0开头（下文把这个过程称为猜谜），率先找到随机数的节点就获得此次记账的唯一记账权。</p><h3 id="计算量分析"><a href="#计算量分析" class="headerlink" title="计算量分析"></a>计算量分析</h3><p>（这部分可选阅读）我们简单分析下记账难度有多大，<br>Hash值是由数字和大小写字母构成的字符串，每一位有62种可能性（可能为26个大写字母、26个小写字母，10个数字中任一个），假设任何一个字符出现的概率是均等的，那么第一位为0的概率是1/62（其他位出现什么字符先不管），理论上需要尝试62次Hash运算才会出现一次第一位为0的情况，如果前两2位为0，就得尝试62的平方次Hash运算，以n个0开头就需要尝试62的n次方次运算。我们结合当前实际区块#493050信息来看看：</p><p><img src="/images/block_info_493050.jpg" alt="区块#493050"></p><p>注：数据来源于<a href="https://blockchain.info" target="_blank" rel="noopener">https://blockchain.info</a><br>我们可以看到Hash值以18个0开头，理论上需要尝试62的18次方次，这个数是非常非常巨大的，我已经算不清楚了，应该是亿亿级别以上了。如此大的计算量需要投入大量的计算设备、电力等，<br>目前应该没有单矿工独立参与挖矿了，基本都是由矿工联合起来组成矿池进行挖矿（矿池里的矿工按算力百分比来分收益）。</p><p>从经济的角度讲，只有挖矿还有收益（比特币价格不断上涨也让收益变大），就会有新的矿工加入，从而加剧竞争，提高算力难度，挖矿就需要耗费更多的运算和电力，相互作用引起最终成本会接近收益。</p><p>题外话：国内由于电力成本较低，相对收益更高，中国的算力占整个网络的一半以上</p><h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><p>在节点成功找到满足的Hash值之后，会马上对全网进行广播打包区块，网络的节点收到广播打包区块，会立刻对其进行验证。</p><p>如果验证通过，则表明已经有节点成功解迷，自己就不再竞争当前区块打包，而是选择接受这个区块，记录到自己的账本中，然后进行下一个区块的竞争猜谜。<br>网络中只有最快解谜的区块，才会添加的账本中，其他的节点进行复制，这样就保证了整个账本的唯一性。</p><p>假如节点有任何的作弊行为，都会导致网络的节点验证不通过，直接丢弃其打包的区块，这个区块就无法记录到总账本中，作弊的节点耗费的成本就白费了，因此在巨大的挖矿成本下，也使得矿工自觉自愿的遵守比特币系统的共识协议，也就确保了整个系统的安全。</p><p>进阶阅读<a href="https://xiaozhuanlan.com/topic/1402935768" target="_blank" rel="noopener">比特币区块结构Merkle树及简单支付验证分析</a>，可以详细了解区块结构如何验证交易。</p><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>矿工的收益其实不仅仅包含新发行的12.5比特币奖励，同时还有交易费收益（本文忽略一些细节是为了让主干更清晰）。</p><p>有兴趣的同学可以看看图中区块都包含了那些信息，红箭头标示出的是本文涉及的信息。</p><p>本文中有提到共识协议，比特币共识协议主要是由工作量证明和最长链机制 两部分组成，请阅读<a href="https://xiaozhuanlan.com/topic/0298513746" target="_blank" rel="noopener">比特币如何达成共识 - 最长链的选择</a>。</p><p><a href="https://learnblockchain.cn/">深入浅出区块链</a> - 系统学习区块链，打造最好的区块链技术博客<br>我的<strong><a href="https://t.xiaomiquan.com/RfAu7uj" target="_blank" rel="noopener">知识星球</a></strong>为各位解答区块链技术问题，欢迎加入讨论。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在&lt;a href=&quot;/2017/10/25/whatbc/&quot; title=&quot;区块链记账原理&quot;&gt;区块链记账原理&lt;/a&gt; 一篇，我们了解到记账是把交易记录、交易时间、账本序号、上一个Hash值等信息计算Hash打包的过程。&lt;br&gt;我们知道所有的计算和存贮是需要消耗计算机资源的，既然要付出成本，那节点为什么还要参与记账呢？在中本聪（比特币之父）的设计里，完成记账的节点可以获得系统给与的一定数量的比特币奖励，这个奖励的过程也就是比特币的发行过程，因此大家形象的把记账称为“挖矿”，本文将详细讨论这个过程。&lt;/p&gt;
    
    </summary>
    
      <category term="比特币" scheme="https://learnblockchain.cn/categories/bitcoin/"/>
    
    
      <category term="比特币" scheme="https://learnblockchain.cn/tags/%E6%AF%94%E7%89%B9%E5%B8%81/"/>
    
      <category term="挖矿" scheme="https://learnblockchain.cn/tags/%E6%8C%96%E7%9F%BF/"/>
    
      <category term="工作量证明" scheme="https://learnblockchain.cn/tags/%E5%B7%A5%E4%BD%9C%E9%87%8F%E8%AF%81%E6%98%8E/"/>
    
      <category term="共识机制" scheme="https://learnblockchain.cn/tags/%E5%85%B1%E8%AF%86%E6%9C%BA%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>比特币所有权及隐私问题-非对称加密应用</title>
    <link href="https://learnblockchain.cn/2017/11/02/bitcoin-own/"/>
    <id>https://learnblockchain.cn/2017/11/02/bitcoin-own/</id>
    <published>2017-11-02T09:19:29.000Z</published>
    <updated>2018-01-10T08:10:07.579Z</updated>
    
    <content type="html"><![CDATA[<p> 比特币系统是如何确定某个账户的比特币是属于谁的？谁可以支付这个账户比特币？<br> 如果你对这个问题还不是很明白，那就一起来看看吧。</p><a id="more"></a><h2 id="银行系统"><a href="#银行系统" class="headerlink" title="银行系统"></a>银行系统</h2><p>我们先来回顾下现实的银行系统：</p><ol><li>首先我们需要把我们的个人信息（如身份证）给银行，银行给我们开立相对应的账户，银行在开户的时候确立了对账户的所有权。</li><li>进行支付的时候，银行对交易双方完成转账（银行在开户的时候已经知道我们对应的账户）。</li></ol><p>同时银行会对账户信息进行保密（这点其实不能保证）。</p><h2 id="匿名账本"><a href="#匿名账本" class="headerlink" title="匿名账本"></a>匿名账本</h2><p>那么比特币如何在没有第三方银行的参与下，在确保隐私的同时如何确定账户所有权的呢？</p><p>实际上比特币的账户是用地址来表示，账本上不显示个人信息，转账是把比特币从一个地址转移到另一个地址。<br>转账记录如这样：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    "付款地址"："2A39CBa2390FDe"</span><br><span class="line">    "收款地址"："AAC9CBa239aFcc"</span><br><span class="line">    "金额"："0.2btc"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>接下来问题就变为了 谁有权用某个地址进行付款。</p><blockquote><p>支付和所有权 实际是同一个问题，如果此比特币只有我可以用来支付，那么说明我拥有所有权</p></blockquote><h2 id="地址与私钥"><a href="#地址与私钥" class="headerlink" title="地址与私钥"></a>地址与私钥</h2><p>比特币的解决方案是，谁拥有某个地址的私钥(如果完全没有加密概念的人，可以简单的把私钥当作密码)，谁就能用这个地址进行支付。（所以私钥一定保管好，如果私钥泄漏，比特币就可能丢失）</p><p>比特币地址和私钥是一个非对称的关系,私钥经过一序列运算（其中有两次Hash）之后，可以得到地址, 但是无法从地址反推得到私钥。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">地址： 2A39CBa2390FDe</span><br><span class="line">私钥： sdgHsdniNIhdsgaKIhkgnakgaihNKHIskdgal</span><br><span class="line"></span><br><span class="line">Hash(Hash(fun(sdgHsdniNIhdsgaKIhkgnakgaihNKHIskdgal)))  -&gt; 2A39CBa2390FDe</span><br></pre></td></tr></table></figure></p><blockquote><p>银行系统银行账号和密码是完全独立的，无法互相推导，转出时需要同时验证账号和密码</p></blockquote><p>还是上面交易的例子：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    "付款地址"："2A39CBa2390FDe",</span><br><span class="line">    "收款地址"："AAC9CBa239aFcc",</span><br><span class="line">    "金额"："0.2btc"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>只有拥有地址2A39CBa2390FDe的私钥才能进行支付。</p><h2 id="非对称加密技术"><a href="#非对称加密技术" class="headerlink" title="非对称加密技术"></a>非对称加密技术</h2><p>这个时候问题就变为了，如何证明你拥有某个地址的私钥（在不泄漏私钥的情况下）。</p><h3 id="对交易信息进行签名"><a href="#对交易信息进行签名" class="headerlink" title="对交易信息进行签名"></a>对交易信息进行签名</h3><p>实际在签名之前，会先对交易信息进行Hash运算的到摘要信息，然后对摘要信息进行签名。过程大概是这样：<br>1.对交易进行hash， 得到一个摘要信息（Hash值）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hash(&apos;</span><br><span class="line">    &#123;&quot;付款地址&quot;：&quot;2A39CBa2390FDe&quot;,</span><br><span class="line">    &quot;收款地址&quot;：&quot;AAC9CBa239aFcc&quot;,</span><br><span class="line">    &quot;金额&quot;：&quot;0.2btc&quot;</span><br><span class="line">    &#125;&apos;) -&gt; 8aDB23CDEA6</span><br></pre></td></tr></table></figure><p>2.用私钥对交易摘要进行签名（付款方在安全的环境下进行，以避免私钥泄密）, 用代码表示大概是这样。<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#参数1为交易摘要</span></span><br><span class="line"><span class="comment">#参数2为私钥</span></span><br><span class="line"><span class="comment">#返回签名信息</span></span><br><span class="line">sign("8aDB23CDEA6", "J78sknJhidhLIqdngalket") -&gt; "3cdferdadgadg"</span><br></pre></td></tr></table></figure></p><h3 id="广播"><a href="#广播" class="headerlink" title="广播"></a>广播</h3><p>在签名运算之后，付款节点就开始在全网进行广播：我支付了0.2btc到AAC9CBa239aFcc,签名信息是3cdferdadgadg，你们来确认一下吧。</p><p>广播过程实际上是发信息到相连的其它节点，其它节点在验证通过后再转发到与之相连的节点，这样的扩散过程。</p><p>广播的信息包含了交易原始信息和签名信息</p><h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>其它节点在收到广播信息之后，会验证签名信息是不是付款方用私钥对交易原始信息签名产生的，如果验证通过说明确实是付款方本人发出的交易，说明交易有效，才会记录到账本中去。<br>（实际还会验证付款账号有没有足够的余额，我们暂时忽略这点）<br>验证过程实际是签名过程的逆运算，用代码表示大概过程是这样的：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#参数1为签名信息</span></span><br><span class="line"><span class="comment">#参数2为付款方地址</span></span><br><span class="line"><span class="comment">#返回交易摘要</span></span><br><span class="line">verify("3cdferdadgadg", "2A39CBa2390FDe") -&gt; "8aDB23CDEA6"</span><br></pre></td></tr></table></figure><p>如果验证输出的信息和原始交易信息的hash一致，则验证通过，记录账本，用代码表示大概是这样：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(verify(<span class="string">"3cdferdadgadg"</span>, <span class="string">"2A39CBa2390FDe"</span>)</span><br><span class="line">    == hash(<span class="string">'&#123;"付款地址"："2A39CBa2390FDe",</span></span><br><span class="line"><span class="string">              "收款地址"："AAC9CBa239aFcc",</span></span><br><span class="line"><span class="string">              "金额"："0.2btc"&#125;'</span>)) :</span><br><span class="line">    <span class="comment"># 写入账本 </span></span><br><span class="line">    <span class="comment"># 广播</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">   <span class="comment"># donothing</span></span><br></pre></td></tr></table></figure><p>大家可以理解为付款地址为公钥，签名过程即为用私钥对交易摘要的加密过程，验证过程为用公钥解密的过程(为方便大家理解，严格来讲是不准确的)。</p><h3 id="补充说明"><a href="#补充说明" class="headerlink" title="补充说明"></a>补充说明</h3><p>上面为了更好的理解，我对一些信息进行了简化。</p><p>比特币系统使用了椭圆曲线签名算法，算法的私钥由32个字节随机数组成，通过私钥可以计算出公钥，公钥经过一序列哈希算法和编码算法得到比特币地址，地址也可以理解为公钥的摘要。</p><p><a href="https://learnblockchain.cn/">深入浅出区块链</a> - 系统学习区块链，打造最好的区块链技术博客<br>我的<strong><a href="https://t.xiaomiquan.com/RfAu7uj" target="_blank" rel="noopener">知识星球</a></strong>为各位解答区块链技术问题，欢迎加入讨论。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt; 比特币系统是如何确定某个账户的比特币是属于谁的？谁可以支付这个账户比特币？&lt;br&gt; 如果你对这个问题还不是很明白，那就一起来看看吧。&lt;/p&gt;
    
    </summary>
    
      <category term="比特币" scheme="https://learnblockchain.cn/categories/bitcoin/"/>
    
    
      <category term="非对称加密" scheme="https://learnblockchain.cn/tags/%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/"/>
    
      <category term="比特币" scheme="https://learnblockchain.cn/tags/%E6%AF%94%E7%89%B9%E5%B8%81/"/>
    
      <category term="所有权问题" scheme="https://learnblockchain.cn/tags/%E6%89%80%E6%9C%89%E6%9D%83%E9%97%AE%E9%A2%98/"/>
    
      <category term="隐私问题" scheme="https://learnblockchain.cn/tags/%E9%9A%90%E7%A7%81%E9%97%AE%E9%A2%98/"/>
    
  </entry>
  
</feed>
