<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>深入浅出区块链</title>
  
  <subtitle>系统学习区块链技术</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://learnblockchain.cn/"/>
  <updated>2018-03-26T01:58:47.076Z</updated>
  <id>https://learnblockchain.cn/</id>
  
  <author>
    <name>Tiny熊</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>剖析非同质化代币ERC721-全面解析ERC721标准</title>
    <link href="https://learnblockchain.cn/2018/03/23/token-erc721/"/>
    <id>https://learnblockchain.cn/2018/03/23/token-erc721/</id>
    <published>2018-03-23T13:54:50.000Z</published>
    <updated>2018-03-26T01:58:47.076Z</updated>
    
    <content type="html"><![CDATA[<p>什么是ERC-721？现在我们看到的各种加密猫猫狗狗都是基于ERC-721创造出来的，每只都是一个独一无二的ERC-721代币，不过ERC-721在区块链世界远不止猫猫狗狗，它更大的想象空间在于将物理世界的资产映射到区块链上。本文就来剖析下什么是ERC721.</p><a id="more"></a><h2 id="ERC721是什么"><a href="#ERC721是什么" class="headerlink" title="ERC721是什么"></a>ERC721是什么</h2><p>在<a href="https://learnblockchain.cn/2018/01/12/create_token/">创建代币</a>一篇，我们讲到过ERC20代币，<br>和ERC20一样，ERC721同样是一个代币标准，ERC721官方简要解释是Non-Fungible Tokens，简写为NFTs，多翻译为非同质代币。 </p><blockquote><p>ERC721 是由Dieter Shirley 在2017年9月提出。Dieter Shirley 正是谜恋猫CryptoKitties背后的公司Axiom Zen的技术总监。因此谜恋猫也是第一个实现了ERC721 标准的去中心化应用。ERC721号提议已经被以太坊作为标准接受，但该标准仍处于草稿阶段。本文介绍的ERC721标准基于最新(2018/03/23官方提议。</p></blockquote><p>那怎么理解<strong>非同质</strong>代币呢?</p><p>非同质代表独一无二，谜恋猫为例，每只猫都被赋予拥有基因，是独一无二的（一只猫就是一个NFTs），猫之间是不能置换的。这种独特性使得某些稀有猫具有收藏价值，也因此受到追捧。</p><p>ERC20代币是可置换的，且可细分为N份（1 = 10 * 0.1）, 而ERC721的Token最小的单位为1，无法再分割。</p><blockquote><p>如果同一个集合的两个物品具有不同的特征，这两个物品是非同质的，而同质是某个部分或数量可以被另一个同等部分或数量所代替。</p></blockquote><p>非同质性其实广泛存在于我们的生活中，如图书馆的每一本，宠物商店的每一只宠物，歌手所演唱的歌曲，花店里不同的花等等，因此ERC721合约必定有广泛的应用场景。通过这样一个标准，也可建立跨功能的NFTs管理和销售平台（就像有支持ERC20的交易所和钱包一样），使生态更加强大。</p><h2 id="ERC721标准"><a href="#ERC721标准" class="headerlink" title="ERC721标准"></a>ERC721标准</h2><p>ERC721最为一个合约标准，提供了在实现ERC721代币时必须要遵守的协议，要求每个ERC721标准合约需要实现ERC721及ERC165接口，接口定义如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.20</span>;</span><br><span class="line"></span><br><span class="line">interface ERC721 <span class="comment">/* is ERC165 */</span> &#123;</span><br><span class="line"></span><br><span class="line">    event Transfer(address indexed _from, address indexed _to, uint256 _tokenId);</span><br><span class="line">    event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId);</span><br><span class="line">    event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">balanceOf</span>(<span class="params">address _owner</span>) <span class="title">external</span> <span class="title">view</span> <span class="title">returns</span> (<span class="params">uint256</span>);</span></span><br><span class="line"><span class="function">    <span class="title">function</span> <span class="title">ownerOf</span>(<span class="params">uint256 _tokenId</span>) <span class="title">external</span> <span class="title">view</span> <span class="title">returns</span> (<span class="params">address</span>);</span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function">    <span class="title">function</span> <span class="title">safeTransferFrom</span>(<span class="params">address _from, address _to, uint256 _tokenId, bytes data</span>) <span class="title">external</span> <span class="title">payable</span>;</span></span><br><span class="line"><span class="function">    <span class="title">function</span> <span class="title">safeTransferFrom</span>(<span class="params">address _from, address _to, uint256 _tokenId</span>) <span class="title">external</span> <span class="title">payable</span>;</span></span><br><span class="line"><span class="function">    <span class="title">function</span> <span class="title">transferFrom</span>(<span class="params">address _from, address _to, uint256 _tokenId</span>) <span class="title">external</span> <span class="title">payable</span>;</span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function">    <span class="title">function</span> <span class="title">approve</span>(<span class="params">address _approved, uint256 _tokenId</span>) <span class="title">external</span> <span class="title">payable</span>;</span></span><br><span class="line"><span class="function">    <span class="title">function</span> <span class="title">setApprovalForAll</span>(<span class="params">address _operator, bool _approved</span>) <span class="title">external</span>;</span></span><br><span class="line"><span class="function">    <span class="title">function</span> <span class="title">getApproved</span>(<span class="params">uint256 _tokenId</span>) <span class="title">external</span> <span class="title">view</span> <span class="title">returns</span> (<span class="params">address</span>);</span></span><br><span class="line"><span class="function">    <span class="title">function</span> <span class="title">isApprovedForAll</span>(<span class="params">address _owner, address _operator</span>) <span class="title">external</span> <span class="title">view</span> <span class="title">returns</span> (<span class="params">bool</span>);</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure><p><strong>接口说明：</strong></p><ul><li>balanceOf(): 返回由_owner 持有的NFTs的数量。</li><li>ownerOf(): 返回tokenId代币持有者的地址。</li><li>approve(): 授予地址_to具有_tokenId的控制权，方法成功后需触发Approval 事件。</li><li>setApprovalForAll(): 授予地址_operator具有所有NFTs的控制权，成功后需触发ApprovalForAll事件。</li><li><p>getApproved()、isApprovedForAll(): 用来查询授权。</p></li><li><p>safeTransferFrom(): 转移NFT所有权，一次成功的转移操作必须发起 Transer 事件。函数的实现需要做一下几种检查：</p></li></ul><ol><li>调用者msg.sender应该是当前tokenId的所有者或被授权的地址</li><li>_from 必须是 _tokenId的所有者</li><li>_tokenId 应该是当前合约正在监测的NFTs 中的任何一个</li><li>_to 地址不应该为 0</li><li>如果_to 是一个合约应该调用其onERC721Received方法, 并且检查其返回值，如果返回值不为<code>bytes4(keccak256(&quot;onERC721Received(address,uint256,bytes)&quot;))</code>抛出异常。<br>一个可接收NFT的合约必须实现ERC721TokenReceiver接口：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">interface ERC721TokenReceiver &#123;</span><br><span class="line">    <span class="comment">/// @return `bytes4(keccak256("onERC721Received(address,uint256,bytes)"))`</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">onERC721Received</span>(<span class="params">address _from, uint256 _tokenId, bytes data</span>) <span class="title">external</span> <span class="title">returns</span>(<span class="params">bytes4</span>);</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure></li></ol><ul><li>transferFrom(): 用来转移NFTs, 方法成功后需触发Transfer事件。调用者自己确认_to地址能正常接收NFT，否则将丢失此NFT。此函数实现时需要检查上面条件的前4条。</li></ul><h2 id="ERC165-标准"><a href="#ERC165-标准" class="headerlink" title="ERC165 标准"></a>ERC165 标准</h2><p>ERC721标准同时要求必须符合ERC165标准 ，其接口如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">interface ERC165 &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">supportsInterface</span>(<span class="params">bytes4 interfaceID</span>) <span class="title">external</span> <span class="title">view</span> <span class="title">returns</span> (<span class="params">bool</span>);</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure></p><p><a href="https://github.com/ethereum/EIPs/blob/master/EIPS/eip-165.md" target="_blank" rel="noopener">ERC165</a>同样是一个合约标准，这个标准要求合约提供其实现了哪些接口，这样再与合约进行交互的时候可以先调用此接口进行查询。<br>interfaceID为函数选择器，计算方式有两种，如：<code>bytes4(keccak256(&#39;supportsInterface(bytes4)&#39;));</code>或<code>ERC165.supportsInterface.selector</code>，多个函数的接口ID为函数选择器的异或值。<br>关于ERC165，这里不深入介绍，有兴趣的同学可以阅读<a href="https://github.com/ethereum/EIPs/blob/master/EIPS/eip-165.md" target="_blank" rel="noopener">官方提案</a>。</p><h2 id="可选实现接口：ERC721Metadata"><a href="#可选实现接口：ERC721Metadata" class="headerlink" title="可选实现接口：ERC721Metadata"></a>可选实现接口：ERC721Metadata</h2><p>ERC721Metadata 接口用于提供合约的元数据：name , symbol 及 URI（NFT所对应的资源）。<br>其接口定义如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">interface ERC721Metadata <span class="comment">/* is ERC721 */</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">name</span>(<span class="params"></span>) <span class="title">external</span> <span class="title">pure</span> <span class="title">returns</span> (<span class="params">string _name</span>);</span></span><br><span class="line"><span class="function">    <span class="title">function</span> <span class="title">symbol</span>(<span class="params"></span>) <span class="title">external</span> <span class="title">pure</span> <span class="title">returns</span> (<span class="params">string _symbol</span>);</span></span><br><span class="line"><span class="function">    <span class="title">function</span> <span class="title">tokenURI</span>(<span class="params">uint256 _tokenId</span>) <span class="title">external</span> <span class="title">view</span> <span class="title">returns</span> (<span class="params">string</span>);</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure></p><p><strong>接口说明：</strong></p><ul><li>name(): 返回合约名字，尽管是可选，但强烈建议实现，即便是返回空字符串。</li><li>symbol(): 返回合约代币符号，尽管是可选，但强烈建议实现，即便是返回空字符串。</li><li>tokenURI(): 返回_tokenId所对应的外部资源文件的URI（通常是IPFS或HTTP(S)路径）。外部资源文件需要包含名字、描述、图片，其格式的要求如下：<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"title"</span>: <span class="string">"Asset Metadata"</span>,</span><br><span class="line">    <span class="attr">"type"</span>: <span class="string">"object"</span>,</span><br><span class="line">    <span class="attr">"properties"</span>: &#123;</span><br><span class="line">        <span class="attr">"name"</span>: &#123;</span><br><span class="line">            <span class="attr">"type"</span>: <span class="string">"string"</span>,</span><br><span class="line">            <span class="attr">"description"</span>: <span class="string">"Identifies the asset to which this NFT represents"</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">"description"</span>: &#123;</span><br><span class="line">            <span class="attr">"type"</span>: <span class="string">"string"</span>,</span><br><span class="line">            <span class="attr">"description"</span>: <span class="string">"Describes the asset to which this NFT represents"</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">"image"</span>: &#123;</span><br><span class="line">            <span class="attr">"type"</span>: <span class="string">"string"</span>,</span><br><span class="line">            <span class="attr">"description"</span>: <span class="string">"A URI pointing to a resource with mime type image/* representing the asset to which this NFT represents. Consider making any images at a width between 320 and 1080 pixels and aspect ratio between 1.91:1 and 4:5 inclusive."</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>tokenURI通常是被web3调用，以便在应用层做相应的查询和展示。</p><h2 id="可选实现接口：ERC721Enumerable"><a href="#可选实现接口：ERC721Enumerable" class="headerlink" title="可选实现接口：ERC721Enumerable"></a>可选实现接口：ERC721Enumerable</h2><p>ERC721Enumerable的主要目的是提高合约中NTF的可访问性，其接口定义如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">interface ERC721Enumerable <span class="comment">/* is ERC721 */</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">totalSupply</span>(<span class="params"></span>) <span class="title">external</span> <span class="title">view</span> <span class="title">returns</span> (<span class="params">uint256</span>);</span></span><br><span class="line"><span class="function">    <span class="title">function</span> <span class="title">tokenByIndex</span>(<span class="params">uint256 _index</span>) <span class="title">external</span> <span class="title">view</span> <span class="title">returns</span> (<span class="params">uint256</span>);</span></span><br><span class="line"><span class="function">    <span class="title">function</span> <span class="title">tokenOfOwnerByIndex</span>(<span class="params">address _owner, uint256 _index</span>) <span class="title">external</span> <span class="title">view</span> <span class="title">returns</span> (<span class="params">uint256</span>);</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure></p><p><strong>接口说明：</strong></p><ul><li>totalSupply(): 返回NFT总量</li><li>tokenByIndex(): 通过索引返回对应的tokenId。</li><li>tokenOfOwnerByIndex(): 所有者可以一次拥有多个的NFT, 此函数返回_owner拥有的NFT列表中对应索引的tokenId。</li></ul><h2 id="补充说明"><a href="#补充说明" class="headerlink" title="补充说明"></a>补充说明</h2><h3 id="NTF-IDs"><a href="#NTF-IDs" class="headerlink" title="NTF IDs"></a>NTF IDs</h3><p>NTF ID，即tokenId，在合约中用唯一的uint265进行标识，每个NFT的ID在智能合约的生命周期内不允许改变。推荐的实现方式有：</p><ol><li>从0开始，每新加一个NFT，NTF ID加1</li><li>使用sha3后uuid 转换为 NTF ID</li></ol><h3 id="与ERC-20的兼容性"><a href="#与ERC-20的兼容性" class="headerlink" title="与ERC-20的兼容性"></a>与ERC-20的兼容性</h3><p>ERC721标准尽可能遵循 ERC-20 的语义，但由于同质代币与非同质代币之间的根本差异，并不能完全兼容ERC-20。</p><h3 id="交易、挖矿、销毁"><a href="#交易、挖矿、销毁" class="headerlink" title="交易、挖矿、销毁"></a>交易、挖矿、销毁</h3><p>在实现transter相关接口时除了满足上面的的条件外，我们可以根据需要添加自己的逻辑，如加入黑名单等。<br>同时挖矿、销毁尽管不是标准的一部分，我们可以根据需要实现。</p><h2 id="参考实现"><a href="#参考实现" class="headerlink" title="参考实现"></a>参考实现</h2><p>参考实现为订阅用户专有福利，请订阅我的小专栏：<a href="https://xiaozhuanlan.com/blockchaincore" target="_blank" rel="noopener">区块链技术</a>查看。<br><!-- 1. [CryptoKitties Deployed Contract.](https://ethfiddle.com/09YbyJRfiI) 2. [XXXXERC721](https://github.com/fulldecent/erc721-example)3. [ERC721ExampleDeed](https://github.com/nastassiasachs/ERC721ExampleDeed) --></p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol><li><a href="https://github.com/ethereum/EIPs/blob/master/EIPS/eip-165.md" target="_blank" rel="noopener">EIPS-165</a></li><li><a href="https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md" target="_blank" rel="noopener">EIPS-721</a></li></ol><p>欢迎来我的知识星球<a href="https://t.xiaomiquan.com/RfAu7uj" target="_blank" rel="noopener"><strong>深入浅出区块链</strong></a>讨论区块链，作为星友福利，星友可加入区块链技术付费交流群。<br><a href="https://learnblockchain.cn/">深入浅出区块链</a> - 系统学习区块链，打造最好的区块链技术博客。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;什么是ERC-721？现在我们看到的各种加密猫猫狗狗都是基于ERC-721创造出来的，每只都是一个独一无二的ERC-721代币，不过ERC-721在区块链世界远不止猫猫狗狗，它更大的想象空间在于将物理世界的资产映射到区块链上。本文就来剖析下什么是ERC721.&lt;/p&gt;
    
    </summary>
    
      <category term="以太坊" scheme="https://learnblockchain.cn/categories/ethereum/"/>
    
      <category term="智能合约" scheme="https://learnblockchain.cn/categories/ethereum/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/"/>
    
    
      <category term="智能合约" scheme="https://learnblockchain.cn/tags/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/"/>
    
      <category term="Token" scheme="https://learnblockchain.cn/tags/Token/"/>
    
      <category term="ERC721" scheme="https://learnblockchain.cn/tags/ERC721/"/>
    
  </entry>
  
  <entry>
    <title>如何搭建以太坊私有链</title>
    <link href="https://learnblockchain.cn/2018/03/18/create_private_blockchain/"/>
    <id>https://learnblockchain.cn/2018/03/18/create_private_blockchain/</id>
    <published>2018-03-18T12:05:59.000Z</published>
    <updated>2018-03-19T02:13:22.401Z</updated>
    
    <content type="html"><![CDATA[<p>在开发以太坊时，很多时候需要搭建一条以太坊私有链，通过本文一起看看如何在Mac上进行搭建。</p><a id="more"></a><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>阅读本文前，你应该对以太坊语言有所了解，如果你还不了解，建议你先看<a href="https://learnblockchain.cn/2017/11/20/whatiseth/">以太坊是什么</a></p><h2 id="go-ethereum客户端安装"><a href="#go-ethereum客户端安装" class="headerlink" title="go-ethereum客户端安装"></a>go-ethereum客户端安装</h2><p>Go-ethereum客户端通常被称为Geth，它是个命令行界面，执行在Go上实现的完整以太坊节点。Geth得益于Go语言的多平台特性，支持在多个平台上使用(比如Windows、Linux、Mac)。Geth是以太坊协议的具体落地实现，通过Geth，你可以实现以太坊的各种功能，如账户的新建编辑删除，开启挖矿，ether币的转移，智能合约的部署和执行等等。所以，我们选择geth工具来进行开发。由于本人是mac，所以优先使用mac进行开发啦。mac中geth安装如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">brew tap ethereum/ethereum</span><br><span class="line">brew install ethereum</span><br></pre></td></tr></table></figure><p>检查是否安装成功</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">geth --help</span><br></pre></td></tr></table></figure><p>如果输出一些帮助提示命令，则说明安装成功。<br>其他平台可参考<a href="https://github.com/ethereum/go-ethereum/wiki/Building-Ethereum" target="_blank" rel="noopener">Geth 安装</a></p><h2 id="搭建私有链"><a href="#搭建私有链" class="headerlink" title="搭建私有链"></a>搭建私有链</h2><p>以太坊支持自定义创世区块，要运行私有链，我们就需要定义自己的创世区块，创世区块信息写在一个json格式的配置文件中。首先将下面的内容保存到一个json文件中，例如genesis.json。<br>json文件内容如下:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"config"</span>: &#123;</span><br><span class="line">        <span class="attr">"chainId"</span>: <span class="number">10</span>, </span><br><span class="line">        <span class="attr">"homesteadBlock"</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="attr">"eip155Block"</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="attr">"eip158Block"</span>: <span class="number">0</span></span><br><span class="line">    &#125;,</span><br><span class="line">  <span class="attr">"alloc"</span>      : &#123;&#125;,</span><br><span class="line">  <span class="attr">"coinbase"</span>   : <span class="string">"0x0000000000000000000000000000000000000000"</span>,</span><br><span class="line">  <span class="attr">"difficulty"</span> : <span class="string">"0x20000"</span>,</span><br><span class="line">  <span class="attr">"extraData"</span>  : <span class="string">""</span>,</span><br><span class="line">  <span class="attr">"gasLimit"</span>   : <span class="string">"0x2fefd8"</span>,</span><br><span class="line">  <span class="attr">"nonce"</span>      : <span class="string">"0x0000000000000042"</span>,</span><br><span class="line">  <span class="attr">"mixhash"</span>    : <span class="string">"0x0000000000000000000000000000000000000000000000000000000000000000"</span>,</span><br><span class="line">  <span class="attr">"parentHash"</span> : <span class="string">"0x0000000000000000000000000000000000000000000000000000000000000000"</span>,</span><br><span class="line">  <span class="attr">"timestamp"</span>  : <span class="string">"0x00"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="初始化：写入创世区块"><a href="#初始化：写入创世区块" class="headerlink" title="初始化：写入创世区块"></a>初始化：写入创世区块</h2><p>准备好创世区块json配置文件后，需要初始化区块链，将上面的创世区块信息写入到区块链中。首先要新建一个目录data0用来存放区块链数据(其实，这个目录data0就相当于一个根节点。当我们基于genesis.json生成根节点后，其他人就可以来连接此根节点，从而能进行交易)。data0目录结构如图所示：</p><p><img src="/images/create_private_blockchain_1.png" alt=""></p><p>接下来进入privatechain目录中，执行初始化命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd privatechain</span><br><span class="line">geth --datadir data0 init genesis.json</span><br></pre></td></tr></table></figure><p>上面的命令的主体是 geth init，表示初始化区块链，命令可以带有选项和参数，其中–datadir选项后面跟一个目录名，这里为 data0，表示指定数据存放目录为 data0， genesis.json是init命令的参数。</p><p>运行上面的命令，会读取genesis.json文件，根据其中的内容，将创世区块写入到区块链中。如果看到log信息中含有<code>Successfully wrote genesis state</code>字样，说明初始化成功。</p><p>初始化成功后的目录如下：<br><img src="/images/create_private_blockchain_2.png" alt=""><br>其中geth/chaindata中存放的是区块数据，keystore中存放的是账户数据。</p><h2 id="启动私有链节点"><a href="#启动私有链节点" class="headerlink" title="启动私有链节点"></a>启动私有链节点</h2><p>初始化完成后，就有了一条自己的私有链，之后就可以启动自己的私有链节点并做一些操作，在终端中输入以下命令即可启动节点：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">geth --datadir data0 --networkid 1108 console</span><br></pre></td></tr></table></figure><p>上面命令的主体是geth console，表示启动节点并进入交互式控制台，–datadir选项指定使用data0作为数据目录，–networkid选项后面跟一个数字，这里是1108，表示指定这个私有链的网络id为1108。网络id在连接到其他节点的时候会用到，以太坊公网的网络id是1，为了不与公有链网络冲突，运行私有链节点的时候要指定自己的网络id(上面命令可能会运行失败，我直接重启mac，再进入到privateChain目录中，简单粗暴)。</p><p>运行上面的命令后，就启动了区块链节点并进入了Javascript Console：<br><img src="/images/create_private_blockchain_3.png" alt=""><br>这是一个交互式的Javascript执行环境，在这里面可以执行Javascript代码，其中&gt;是命令提示符。在这个环境里也内置了一些用来操作以太坊的Javascript对象，可以直接使用这些对象。这些对象主要包括：</p><p><strong>eth：</strong>包含一些跟操作区块链相关的方法<br><strong>net：</strong>包含以下查看p2p网络状态的方法<br><strong>admin：</strong>包含一些与管理节点相关的方法<br><strong>miner：</strong>包含启动&amp;停止挖矿的一些方法<br><strong>personal：</strong>主要包含一些管理账户的方法<br><strong>txpool：</strong>包含一些查看交易内存池的方法<br><strong>web3：</strong>包含了以上对象，还包含一些单位换算的方法</p><h2 id="玩转Javascript-Console"><a href="#玩转Javascript-Console" class="headerlink" title="玩转Javascript Console"></a>玩转Javascript Console</h2><p>进入以太坊Javascript Console后，就可以使用里面的内置对象做一些操作，这些内置对象提供的功能很丰富，比如查看区块和交易、创建账户、挖矿、发送交易、部署智能合约等。接下来介绍几个常用功能，下面的操作中，前面带&gt;的表示在Javascript Console中执行的命令。</p><h3 id="创建账户"><a href="#创建账户" class="headerlink" title="创建账户"></a>创建账户</h3><p>前面只是搭建了私有链，并没有自己的账户，可以在js console中输入eth.accounts来验证：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; eth.accounts</span><br><span class="line">[]</span><br></pre></td></tr></table></figure><p>此时没有账户，接下来使用personal对象来创建一个账户：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; personal.newAccount()</span><br><span class="line">&gt; Passphrase:</span><br><span class="line">&gt; Repeat passphrase:</span><br><span class="line">&quot;0x4a3b0216e1644c1bbabda527a6da7fc5d178b58f&quot;</span><br></pre></td></tr></table></figure><p>Passphrase其实就是密码的意思，输入两次密码后，就创建了一个账户。再次执行命令:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; personal.newAccount()</span><br><span class="line">&gt; Passphrase:</span><br><span class="line">&gt; Repeat passphrase:</span><br><span class="line">&quot;0x46b24d04105551498587e3c6ce2c3341d5988938&quot;</span><br></pre></td></tr></table></figure><p>这时候再去看账户，就有两个了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; eth.accounts</span><br><span class="line">[&quot;0x4a3b0216e1644c1bbabda527a6da7fc5d178b58f&quot;, &quot;0x46b24d04105551498587e3c6ce2c3341d5988938&quot;]</span><br></pre></td></tr></table></figure><p>账户默认会保存在数据目录的keystore文件夹中。查看目录结构，发现data0/keystore中多了两个文件，这两个文件就对应刚才创建的两个账户，这是json格式的文本文件，可以打开查看，里面存的是私钥经过密码加密后的信息。</p><p><img src="/images/create_private_blockchain_4.png" alt=""><br>json文件中信息格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;address&quot;: &quot;4a3b0216e1644c1bbabda527a6da7fc5d178b58f&quot;,</span><br><span class="line">  &quot;crypto&quot;: &#123;</span><br><span class="line">    &quot;cipher&quot;: &quot;aes-128-ctr&quot;,</span><br><span class="line">    &quot;ciphertext&quot;: &quot;238d6d48126b762c8f13e84622b1bbb7713f7244c2f24555c99b76396fae8355&quot;,</span><br><span class="line">    &quot;cipherparams&quot;: &#123;</span><br><span class="line">      &quot;iv&quot;: &quot;d0f5a3d3e6c1eeec77bf631bc938725d&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;kdf&quot;: &quot;scrypt&quot;,</span><br><span class="line">    &quot;kdfparams&quot;: &#123;</span><br><span class="line">      &quot;dklen&quot;: 32,</span><br><span class="line">      &quot;n&quot;: 262144,</span><br><span class="line">      &quot;p&quot;: 1,</span><br><span class="line">      &quot;r&quot;: 8,</span><br><span class="line">      &quot;salt&quot;: &quot;70dc72c4eb63bea50f7637d9ff85bb53f6ca8ace17f4245feae9c0bc9abaad82&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;mac&quot;: &quot;bd7fc0c937c39f1cbbf1ca654c33b53d7f9c644c6dacfeefe1641d2f3decea04&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;id&quot;: &quot;57803d82-0cd4-4a78-9c29-9f9252fdcf60&quot;,</span><br><span class="line">  &quot;version&quot;: 3</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="查看账户余额"><a href="#查看账户余额" class="headerlink" title="查看账户余额"></a>查看账户余额</h3><p>eth对象提供了查看账户余额的方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; eth.getBalance(eth.accounts[0])</span><br><span class="line">0</span><br><span class="line">&gt; eth.getBalance(eth.accounts[1])</span><br><span class="line">0</span><br></pre></td></tr></table></figure><p>目前两个账户的以太币余额都是0，要使账户有余额，可以从其他账户转账过来，或者通过挖矿来获得以太币奖励。</p><h3 id="启动-amp-停止挖矿"><a href="#启动-amp-停止挖矿" class="headerlink" title="启动&amp;停止挖矿"></a>启动&amp;停止挖矿</h3><p>通过miner.start()来启动挖矿：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; miner.start(10)</span><br></pre></td></tr></table></figure><p>其中start的参数表示挖矿使用的线程数。第一次启动挖矿会先生成挖矿所需的DAG文件，这个过程有点慢，等进度达到100%后，就会开始挖矿，此时屏幕会被挖矿信息刷屏。</p><p>如果想停止挖矿，并且进度已经达到100%之后，可以在js console中输入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">miner.stop()：</span><br></pre></td></tr></table></figure><p>注意：输入的字符会被挖矿刷屏信息冲掉，没有关系，只要输入完整的miner.stop()之后回车，即可停止挖矿。</p><p>挖到一个区块会奖励5个以太币，挖矿所得的奖励会进入矿工的账户，这个账户叫做coinbase，默认情况下coinbase是本地账户中的第一个账户：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; eth.coinbase</span><br><span class="line">&quot;0x4a3b0216e1644c1bbabda527a6da7fc5d178b58f&quot;</span><br></pre></td></tr></table></figure><p>现在的coinbase是账户0，要想使挖矿奖励进入其他账户，通过miner.setEtherbase()将其他账户设置成coinbase即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; miner.setEtherbase(eth.accounts[1])</span><br><span class="line">true</span><br><span class="line">&gt; eth.coinbase</span><br><span class="line">&quot;0x46b24d04105551498587e3c6ce2c3341d5988938&quot;</span><br></pre></td></tr></table></figure><p>挖到区块以后，账户0里面应该就有余额了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; eth.getBalance(eth.accounts[0])</span><br><span class="line">2.31e+21</span><br></pre></td></tr></table></figure><p>getBalance()返回值的单位是wei，wei是以太币的最小单位，1个以太币=10的18次方个wei。要查看有多少个以太币，可以用web3.fromWei()将返回值换算成以太币：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; web3.fromWei(eth.getBalance(eth.accounts[0]),&apos;ether&apos;)</span><br><span class="line">2310</span><br></pre></td></tr></table></figure><h3 id="发送交易"><a href="#发送交易" class="headerlink" title="发送交易"></a>发送交易</h3><p>截止目前，账户一的余额还是0：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; eth.getBalance(eth.accounts[1])</span><br><span class="line">0</span><br></pre></td></tr></table></figure><p>可以通过发送一笔交易，从账户0转移10个以太币到账户1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; amount = web3.toWei(10,&apos;ether&apos;)</span><br><span class="line">&quot;10000000000000000000&quot;</span><br><span class="line">&gt; eth.sendTransaction(&#123;from:eth.accounts[0],to:eth.accounts[1],value:amount&#125;)</span><br><span class="line">Error: authentication needed: password or unlock</span><br><span class="line">    at web3.js:3143:20</span><br><span class="line">    at web3.js:6347:15</span><br><span class="line">    at web3.js:5081:36</span><br><span class="line">    at &lt;anonymous&gt;:1:1</span><br></pre></td></tr></table></figure><p>这里报错了，原因是账户每隔一段时间就会被锁住，要发送交易，必须先解锁账户，由于我们要从账户0发送交易，所以要解锁账户0：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; personal.unlockAccount(eth.accounts[0])</span><br><span class="line">Unlock account 0x4a3b0216e1644c1bbabda527a6da7fc5d178b58f</span><br><span class="line">Passphrase: </span><br><span class="line">true</span><br></pre></td></tr></table></figure><p>输入创建账户时设置的密码，就可以成功解锁账户。然后再发送交易：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; amount = web3.toWei(10,&apos;ether&apos;)</span><br><span class="line">&quot;10000000000000000000&quot;</span><br><span class="line">&gt; eth.sendTransaction(&#123;from:eth.accounts[0],to:eth.accounts[1],value:amount&#125;)</span><br><span class="line">INFO [03-07|11:13:11] Submitted transaction                    fullhash=0x1b21bba16dd79b659c83594b0c41de42debb2738b447f6b24e133d51149ae2a6 recipient=0x46B24d04105551498587e3C6CE2c3341d5988938</span><br><span class="line">&quot;0x1b21bba16dd79b659c83594b0c41de42debb2738b447f6b24e133d51149ae2a6&quot;</span><br></pre></td></tr></table></figure><p>我们去查看账户1中的余额：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; eth.getBalance(eth.accounts[1])</span><br><span class="line">0</span><br></pre></td></tr></table></figure><p>发现还没转过去，此时交易已经提交到区块链，但还未被处理，这可以通过查看txpool来验证：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; txpool.status</span><br><span class="line">&#123;</span><br><span class="line">  pending: 1,</span><br><span class="line">  queued: 0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中有一条pending的交易，pending表示已提交但还未被处理的交易。</p><p>要使交易被处理，必须要挖矿。这里我们启动挖矿，然后等待挖到一个区块之后就停止挖矿：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; miner.start(1);admin.sleepBlocks(1);miner.stop();</span><br></pre></td></tr></table></figure><p>当miner.stop()返回true后，txpool中pending的交易数量应该为0了，说明交易已经被处理了，而账户1应该收到币了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; web3.fromWei(eth.getBalance(eth.accounts[1]),&apos;ether&apos;)</span><br><span class="line">10</span><br></pre></td></tr></table></figure><h3 id="查看交易和区块"><a href="#查看交易和区块" class="headerlink" title="查看交易和区块"></a>查看交易和区块</h3><p>eth对象封装了查看交易和区块信息的方法。</p><p>查看当前区块总数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; eth.blockNumber</span><br><span class="line">463</span><br></pre></td></tr></table></figure><p>通过区块号查看区块：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&gt; eth.getBlock(66)</span><br><span class="line">&#123;</span><br><span class="line">  difficulty: 135266,</span><br><span class="line">  extraData: &quot;0xd783010802846765746886676f312e31308664617277696e&quot;,</span><br><span class="line">  gasLimit: 3350537,</span><br><span class="line">  gasUsed: 0,</span><br><span class="line">  hash: &quot;0x265dfcc0649bf6240812256b2b9b4e3ae48d51fd8e43e25329ac111556eacdc8&quot;,</span><br><span class="line">  logsBloom: &quot;0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000&quot;,</span><br><span class="line">  miner: &quot;0x4a3b0216e1644c1bbabda527a6da7fc5d178b58f&quot;,</span><br><span class="line">  mixHash: &quot;0xaf755722f62cac9b483d3437dbc795f2d3a02e28ec03d39d8ecbb6012906263c&quot;,</span><br><span class="line">  nonce: &quot;0x3cd80f6ec5c2f3e9&quot;,</span><br><span class="line">  number: 66,</span><br><span class="line">  parentHash: &quot;0x099776a52223b892d13266bb3aec3cc04c455dc797185f0b3300d39f9fc0a8ec&quot;,</span><br><span class="line">  receiptsRoot: &quot;0x56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421&quot;,</span><br><span class="line">  sha3Uncles: &quot;0x1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347&quot;,</span><br><span class="line">  size: 535,</span><br><span class="line">  stateRoot: &quot;0x0c9feec5a201c8c98618331aecbfd2d4d93da1c6064abd0c41ae649fc08d8d06&quot;,</span><br><span class="line">  timestamp: 1520391527,</span><br><span class="line">  totalDifficulty: 8919666,</span><br><span class="line">  transactions: [],</span><br><span class="line">  transactionsRoot: &quot;0x56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421&quot;,</span><br><span class="line">  uncles: []</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过交易hash查看交易：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&gt; eth.getTransaction(&quot;0x1b21bba16dd79b659c83594b0c41de42debb2738b447f6b24e133d51149ae2a6&quot;)</span><br><span class="line">&#123;</span><br><span class="line">  blockHash: &quot;0x1cb368a27cc23c786ff5cdf7cd4351d48f4c8e8aea2e084a5e9d7c480449c79a&quot;,</span><br><span class="line">  blockNumber: 463,</span><br><span class="line">  from: &quot;0x4a3b0216e1644c1bbabda527a6da7fc5d178b58f&quot;,</span><br><span class="line">  gas: 90000,</span><br><span class="line">  gasPrice: 18000000000,</span><br><span class="line">  hash: &quot;0x1b21bba16dd79b659c83594b0c41de42debb2738b447f6b24e133d51149ae2a6&quot;,</span><br><span class="line">  input: &quot;0x&quot;,</span><br><span class="line">  nonce: 0,</span><br><span class="line">  r: &quot;0x31d22686e0d408a16497becf6d47fbfdffe6692d91727e5b7ed3d73ede9e66ea&quot;,</span><br><span class="line">  s: &quot;0x7ff7c14a20991e2dfdb813c2237b08a5611c8c8cb3c2dcb03a55ed282ce4d9c3&quot;,</span><br><span class="line">  to: &quot;0x46b24d04105551498587e3c6ce2c3341d5988938&quot;,</span><br><span class="line">  transactionIndex: 0,</span><br><span class="line">  v: &quot;0x38&quot;,</span><br><span class="line">  value: 10000000000000000000</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://learnblockchain.cn/">深入浅出区块链</a> - 系统学习区块链，打造最好的区块链技术博客。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在开发以太坊时，很多时候需要搭建一条以太坊私有链，通过本文一起看看如何在Mac上进行搭建。&lt;/p&gt;
    
    </summary>
    
      <category term="以太坊" scheme="https://learnblockchain.cn/categories/ethereum/"/>
    
      <category term="私有链" scheme="https://learnblockchain.cn/categories/ethereum/%E7%A7%81%E6%9C%89%E9%93%BE/"/>
    
    
      <category term="以太坊" scheme="https://learnblockchain.cn/tags/%E4%BB%A5%E5%A4%AA%E5%9D%8A/"/>
    
      <category term="私有链" scheme="https://learnblockchain.cn/tags/%E7%A7%81%E6%9C%89%E9%93%BE/"/>
    
  </entry>
  
  <entry>
    <title>如何编写一个可升级的智能合约</title>
    <link href="https://learnblockchain.cn/2018/03/15/contract-upgrade/"/>
    <id>https://learnblockchain.cn/2018/03/15/contract-upgrade/</id>
    <published>2018-03-15T08:14:01.000Z</published>
    <updated>2018-03-19T02:07:02.499Z</updated>
    
    <content type="html"><![CDATA[<p>区块链信任基础的数据不可修改的特性，让它传统应用程序有一个很大的不同的地方是一经发布于区块链上就无法修改（不能直接在原有的合约上直接修改再重新发布）。</p><a id="more"></a><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>阅读本文前，你应该对以太坊、智能合约及<a href="https://learnblockchain.cn/categories/ethereum/Solidity/">Solidity语言</a>有所了解，如果你还不了解，建议你先看<a href="https://learnblockchain.cn/2017/11/20/whatiseth/">以太坊是什么</a></p><h2 id="当智能合约出现bug"><a href="#当智能合约出现bug" class="headerlink" title="当智能合约出现bug"></a>当智能合约出现bug</h2><p>一方面正式由于智能合约的不可修改的特性，因为只要规则确定之后，没人能够修改它，大家才能够信任它。但另一方面，如果规则的实现有Bug, 可能会造成代币被盗，或是调用消耗大量的gas。这时就需要我们去修复错误。</p><p>我们知道一个智能合约包含两部分： 代码逻辑和数据，而代码逻辑又是最容易出问题的部分, 如在实现如下合约时，由于手抖在写addTen()时，10写成了11。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.18</span>;</span><br><span class="line"></span><br><span class="line">contract MyContract &#123;</span><br><span class="line">    mapping (<span class="function"><span class="params">address</span> =&gt;</span> uint256) public balanceOf;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">setBlance</span>(<span class="params">address _address,uint256 v</span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">        balanceOf[_address] = v;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">addTen</span>(<span class="params">address addr</span>) <span class="title">public</span> <span class="title">returns</span> (<span class="params">uint</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> balanceOf[addr] + <span class="number">11</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假如我们在部署之后发现了这个问题，想要修复这个bug的话，只好重新部署合约，可是这时会有一个尴尬的问题，原来的合约已经有很多人使用，如果部署新的合约，老合约的数据将会丢失。</p><h2 id="数据合约及控制合约"><a href="#数据合约及控制合约" class="headerlink" title="数据合约及控制合约"></a>数据合约及控制合约</h2><p>那么如何解决上面的问题了，一个解决方案是分离合约中的数据，使用一个单独的合约来存储数据（下文称数据合约），使用一个单独的合约写业务逻辑（下文称控制合约）。<br>我们来看看代码如何实现。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.18</span>;</span><br><span class="line"></span><br><span class="line">contract DataContract &#123;</span><br><span class="line">    mapping (<span class="function"><span class="params">address</span> =&gt;</span> uint256) public balanceOf;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">setBlance</span>(<span class="params">address _address,uint256 v</span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">        balanceOf[_address] = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract ControlContract &#123;</span><br><span class="line"></span><br><span class="line">    DataContract dataContract;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">ControlContract</span>(<span class="params">address _dataContractAddr</span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">        dataContract = DataContract(_dataContractAddr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">addTen</span>(<span class="params">address addr</span>) <span class="title">public</span> <span class="title">returns</span> (<span class="params">uint</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dataContract.balanceOf(addr) + <span class="number">11</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们有两个合约DataContract 专门用来存数据，ControlContract用来处理逻辑，并利用DataContract来读写数据。通过这样的设计，可以在更新控制合约后保持数据合约不变，这样就不会丢失数据，也不用迁移数据。</p><h2 id="读写控制"><a href="#读写控制" class="headerlink" title="读写控制"></a>读写控制</h2><p>通过DataContract我们可以单独更新合约逻辑，不过你也许发现了一个新的问题，DataContract的数据不仅仅可以被ControlContract读写，还可以被其他的合约读写，因此需要对DataContract添加读写控制。我们给DataContract添加一个mapping, 用来控制哪些地址可以访问数据，同时添加了修饰器及设置访问的方法，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.18</span>;</span><br><span class="line"></span><br><span class="line">contract DataContract &#123;</span><br><span class="line">    mapping (<span class="function"><span class="params">address</span> =&gt;</span> uint256) public balanceOf;</span><br><span class="line">    mapping (<span class="function"><span class="params">address</span> =&gt;</span> bool) accessAllowed;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">DataContract</span>(<span class="params"></span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">        accessAllowed[msg.sender] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">setBlance</span>(<span class="params">address _address,uint256 v</span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">        balanceOf[_address] = v;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    modifier platform() &#123;</span><br><span class="line">        <span class="built_in">require</span>(accessAllowed[msg.sender] == <span class="literal">true</span>);</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">allowAccess</span>(<span class="params">address _addr</span>) <span class="title">platform</span> <span class="title">public</span> </span>&#123;</span><br><span class="line">        accessAllowed[_addr] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">denyAccess</span>(<span class="params">address _addr</span>) <span class="title">platform</span> <span class="title">public</span> </span>&#123;</span><br><span class="line">        accessAllowed[_addr] = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>订阅我的<a href="https://xiaozhuanlan.com/blockchaincore" target="_blank" rel="noopener">小专栏</a>可参看合约的完整代码。</p><p>部署方法如下：</p><ol><li>先部署DataContract合约</li><li>使用DataContract合约地址作为部署ControlContract合约的参数</li><li>用ControlContract合约地址作为参数调用DataContract合约的allowAccess方法。<br>如果需要更新控制合约(如修复了addTen)则重新执行第2-3步，同时对老的控制合约执行denyAccess()。</li></ol><h2 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h2><p>当我们在实现数据合约时，它包含的逻辑应该越少越好，并且应该是严格测试过的，因为一旦数据合约部署之后，就没法更改。<br>大多数情况下，和用户交互的是DApp， 因此当控制合约升级之后，需要升级DApp，使之关联新的控制合约。</p><p>尽管合约可以通过本文的方式升级，但我们依然要谨慎升级，因为升级表示你可以重写逻辑，会降低用户对你的信任度。<br>本文介绍升级方法更多的是一种思路，实际项目中可能会对应多个控制合约及数据合约。</p><p>欢迎来我的<strong><a href="https://t.xiaomiquan.com/RfAu7uj" target="_blank" rel="noopener">知识星球</a></strong>讨论区块链技术。</p><p><a href="https://learnblockchain.cn/">深入浅出区块链</a> - 系统学习区块链，打造最好的区块链技术博客。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;区块链信任基础的数据不可修改的特性，让它传统应用程序有一个很大的不同的地方是一经发布于区块链上就无法修改（不能直接在原有的合约上直接修改再重新发布）。&lt;/p&gt;
    
    </summary>
    
      <category term="以太坊" scheme="https://learnblockchain.cn/categories/ethereum/"/>
    
      <category term="智能合约" scheme="https://learnblockchain.cn/categories/ethereum/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/"/>
    
    
      <category term="智能合约" scheme="https://learnblockchain.cn/tags/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/"/>
    
  </entry>
  
  <entry>
    <title>智能合约语言 Solidity 教程系列8 - Solidity API</title>
    <link href="https://learnblockchain.cn/2018/03/14/solidity-api/"/>
    <id>https://learnblockchain.cn/2018/03/14/solidity-api/</id>
    <published>2018-03-14T15:04:43.000Z</published>
    <updated>2018-03-18T13:55:32.193Z</updated>
    
    <content type="html"><![CDATA[<p>这是Solidity教程系列文章第8篇介绍Solidity API，它们主要表现为内置的特殊的变量及函数，存在于全局命名空间里。</p><p>Solidity 系列完整的文章列表请查看<a href="https://learnblockchain.cn/categories/ethereum/Solidity/">分类-Solidity</a>。</p><a id="more"></a><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>Solidity 是以太坊智能合约编程语言，阅读本文前，你应该对以太坊、智能合约有所了解，<br>如果你还不了解，建议你先看<a href="https://learnblockchain.cn/2017/11/20/whatiseth/">以太坊是什么</a></p><p>欢迎订阅<a href="https://xiaozhuanlan.com/blockchaincore" target="_blank" rel="noopener">区块链技术专栏</a>阅读更全面的分析文章。</p><p>Solidity API 主要表现为Solidity 内置的特殊的变量及函数，他们存在于全局命名空间里，主要分为以下几类：</p><ol><li>有关区块和交易的属性</li><li>有关错误处理</li><li>有关数学及加密功能</li><li>地址相关</li><li>合约相关</li></ol><p>下面详细讲解下</p><h2 id="区块和交易的属性（Block-And-Transaction-Properties）"><a href="#区块和交易的属性（Block-And-Transaction-Properties）" class="headerlink" title="区块和交易的属性（Block And Transaction Properties）"></a>区块和交易的属性（Block And Transaction Properties）</h2><p>用来提供一些区块链当前的信息。</p><ul><li>block.blockhash(uint blockNumber) returns (bytes32)：返回给定区块号的哈希值，只支持最近256个区块，且不包含当前区块。</li><li>block.coinbase (address): 当前块矿工的地址。</li><li>block.difficulty (uint):当前块的难度。</li><li>block.gaslimit (uint):当前块的gaslimit。</li><li>block.number (uint):当前区块的块号。</li><li>block.timestamp (uint): 当前块的Unix时间戳（从1970/1/1 00:00:00 UTC开始所经过的秒数）</li><li>msg.data (bytes): 完整的调用数据（calldata）。</li><li>msg.gas (uint): 当前还剩的gas。</li><li>msg.sender (address): 当前调用发起人的地址。</li><li>msg.sig (bytes4):调用数据(calldata)的前四个字节（例如为：函数标识符）。</li><li>msg.value (uint): 这个消息所附带的以太币，单位为wei。</li><li>now (uint): 当前块的时间戳(block.timestamp的别名)</li><li>tx.gasprice (uint) : 交易的gas价格。</li><li>tx.origin (address): 交易的发送者（全调用链）</li></ul><p>注意：<br>msg的所有成员值，如msg.sender,msg.value的值可以因为每一次外部函数调用，或库函数调用发生变化（因为msg就是和调用相关的全局变量）。</p><p>不应该依据 block.timestamp, now 和 block.blockhash来产生一个随机数（除非你确实需要这样做），这几个值在一定程度上被矿工影响（比如在赌博合约里，不诚实的矿工可能会重试去选择一个对自己有利的hash）。</p><p>对于同一个链上连续的区块来说，当前区块的时间戳（timestamp）总是会大于上一个区块的时间戳。</p><p>为了可扩展性的原因，你只能查最近256个块，所有其它的将返回0.</p><h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><ul><li>assert(bool condition)<br>用于判断内部错误，条件不满足时抛出异常</li><li>require(bool condition):<br>用于判断输入或外部组件错误，条件不满足时抛出异常</li><li>revert():<br>终止执行并还原改变的状态</li></ul><h2 id="数学及加密功能"><a href="#数学及加密功能" class="headerlink" title="数学及加密功能"></a>数学及加密功能</h2><ul><li>addmod(uint x, uint y, uint k) returns (uint):<br>计算(x + y) % k，加法支持任意的精度且不会在2**256处溢出，从0.5.0版本开始断言k != 0。</li><li>mulmod(uint x, uint y, uint k) returns (uint):<br>计算 (x <em> y) % k， 乘法支持任意的精度且不会在2*</em>256处溢出， 从0.5.0版本开始断言k != 0。</li><li>keccak256(…) returns (bytes32):<br>使用以太坊的（Keccak-256）计算HASH值。紧密打包参数。</li><li>sha256(…) returns (bytes32):<br>使用SHA-256计算hash值，紧密打包参数。</li><li>sha3(…) returns (bytes32):<br>keccak256的别名</li><li>ripemd160(…) returns (bytes20):<br>使用RIPEMD-160计算HASH值。紧密打包参数。</li><li>ecrecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) returns (address):<br>通过椭圆曲线签名来恢复与公钥关联的地址，或者在错误时返回零。可用于签名数据的校验，如果返回结果是签名者的公匙地址，那么说明数据是正确的。<blockquote><p>ecrecover函数需要四个参数，需要被签名数据的哈希结果值，r，s，v分别来自签名结果串。<br>r = signature[0:64]<br>s = signature[64:128]<br>v = signature[128:130]<br>其中v取出来的值或者是00或01。要使用时，我们先要将其转为整型，再加上27，所以我们将得到27或28。在调用函数时v将填入27或28。</p></blockquote></li></ul><p>用javascript表达如下:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> msg = <span class="string">'0x8CbaC5e4d803bE2A3A5cd3DbE7174504c6DD0c1C'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> hash = web3.sha3(msg)</span><br><span class="line"><span class="keyword">var</span> sig = web3.eth.sign(address, h).slice(<span class="number">2</span>)</span><br><span class="line"><span class="keyword">var</span> r = <span class="string">`0x<span class="subst">$&#123;sig.slice(<span class="number">0</span>, <span class="number">64</span>)&#125;</span>`</span></span><br><span class="line"><span class="keyword">var</span> s = <span class="string">`0x<span class="subst">$&#123;sig.slice(<span class="number">64</span>, <span class="number">128</span>)&#125;</span>`</span></span><br><span class="line"><span class="keyword">var</span> v = web3.toDecimal(sig.slice(<span class="number">128</span>, <span class="number">130</span>)) + <span class="number">27</span></span><br></pre></td></tr></table></figure></p><p>订阅<a href="https://xiaozhuanlan.com/blockchaincore" target="_blank" rel="noopener">区块链技术专栏</a>可以参考到完整的使用例子。<br><!-- [例子](https://ethereum.stackexchange.com/questions/1777/workflow-on-signing-a-string-with-private-key-followed-by-signature-verificatio)： --></p><p>紧密打包参数（tightly packed）意思是说参数不会补位，是直接连接在一起的，下面几个是相等的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">keccak256(&quot;ab&quot;, &quot;c&quot;)</span><br><span class="line">keccak256(&quot;abc&quot;)</span><br><span class="line"></span><br><span class="line">keccak256(0x616263)  // hex</span><br><span class="line">keccak256(6382179)</span><br><span class="line">keccak256(97, 98, 99)   //ascii</span><br></pre></td></tr></table></figure><p>如果需要填充，可以使用显式类型转换：keccak256(“\x00\x12”) 与keccak256(uint16(0x12))相同。</p><p>注意，常量将使用存储它们所需的最少字节数来打包，例如keccak256(0) == keccak256(uint8(0))和keccak256(0x12345678) == keccak256(uint32(0x12345678))</p><p>在私链(private blockchain)上运行sha256,ripemd160或ecrecover可能会出现Out-Of-Gas报错。因为私链实现了一种预编译合约，合约要在收到第一个消息后才会真正存在（虽然他们的合约代码是硬编码的）。而向一个不存在的合约发送消息，所以才会导致Out-Of-Gas的问题。一种解决办法（workaround）是每个在你真正使用它们之前先发送1 wei到这些合约上来完成初始化。在官方和测试链上没有这个问题。</p><h2 id="地址相关"><a href="#地址相关" class="headerlink" title="地址相关"></a>地址相关</h2><ul><li><p><address>.balance (uint256):<br>Address的余额，以wei为单位。</address></p></li><li><p><address>.transfer(uint256 amount):<br>发送给定数量的ether到某个地址，以wei为单位。失败时抛出异常。</address></p></li><li><p><address>.send(uint256 amount) returns (bool):<br>发送给定数量的ether到某个地址，以wei为单位, 失败时返回false。</address></p></li><li><p><address>.call(…) returns (bool):<br>发起底层的call调用。失败时返回false。</address></p></li><li><p><address>.callcode(…) returns (bool):<br>发起底层的callcode调用，失败时返回false。<br>不鼓励使用，未来可能会移除。</address></p></li><li><p><address>.delegatecall(…) returns (bool):<br>发起底层的delegatecall调用，失败时返回false</address></p></li></ul><p>更多信息参考<a href="https://xiaozhuanlan.com/topic/7921803456" target="_blank" rel="noopener">地址篇</a>。</p><p><strong>警告</strong>：send() 执行有一些风险：如果调用栈的深度超过1024或gas耗光，交易都会失败。因此，为了保证安全，必须检查send的返回值，如果交易失败，会回退以太币。如果用transfer会更好。</p><h2 id="合约相关"><a href="#合约相关" class="headerlink" title="合约相关"></a>合约相关</h2><ul><li>this（当前合约的类型）:<br>表示当前合约，可以显式的转换为Address</li><li>selfdestruct(address recipient):<br>销毁当前合约，并把它所有资金发送到给定的地址。</li><li>suicide(address recipient):<br>selfdestruct的别名</li></ul><p>另外，当前合约里的所有函数均可支持调用，包括当前函数本身。</p><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul><li><a href="https://solidity.readthedocs.io/en/develop/units-and-global-variables.html#units-and-globally-available-variables" target="_blank" rel="noopener">Special Variables and Functions</a></li></ul><p><a href="https://learnblockchain.cn/">深入浅出区块链</a> - 系统学习区块链，打造最好的区块链技术博客。<br>如果想与我有更密切的交流可以选择加入我的<a href="https://t.xiaomiquan.com/RfAu7uj" target="_blank" rel="noopener">知识星球</a>（星球成员可加入微信技术交流群）</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是Solidity教程系列文章第8篇介绍Solidity API，它们主要表现为内置的特殊的变量及函数，存在于全局命名空间里。&lt;/p&gt;
&lt;p&gt;Solidity 系列完整的文章列表请查看&lt;a href=&quot;https://learnblockchain.cn/categories/ethereum/Solidity/&quot;&gt;分类-Solidity&lt;/a&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="以太坊" scheme="https://learnblockchain.cn/categories/ethereum/"/>
    
      <category term="Solidity" scheme="https://learnblockchain.cn/categories/ethereum/Solidity/"/>
    
    
      <category term="Solidity手册" scheme="https://learnblockchain.cn/tags/Solidity%E6%89%8B%E5%86%8C/"/>
    
  </entry>
  
  <entry>
    <title>如何通过以太坊智能合约来进行众筹（ICO）</title>
    <link href="https://learnblockchain.cn/2018/02/28/ico-crowdsale/"/>
    <id>https://learnblockchain.cn/2018/02/28/ico-crowdsale/</id>
    <published>2018-02-28T12:30:42.000Z</published>
    <updated>2018-02-28T16:33:01.740Z</updated>
    
    <content type="html"><![CDATA[<p>前面我们有两遍文章写了如何发行代币，今天我们讲一下如何使用代币来公开募资，即编写一个募资合约。</p><a id="more"></a><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>本文所讲的代币是使用以太坊智能合约创建，阅读本文前，你应该对以太坊、智能合约有所了解，如果你还不了解，建议你先看<a href="https://learnblockchain.cn/2017/11/20/whatiseth/">以太坊是什么</a></p><h2 id="众筹"><a href="#众筹" class="headerlink" title="众筹"></a>众筹</h2><p>先简单说下众筹的概念：一般是这样的，我一个非常好的想法，但是我没有钱来做这事，于是我把这个想法发给大家看，说：我做这件事需要5百万，大家有没有兴趣投些钱，如果大家在30天内投够了5百万我就开始做，到时大家都是原始股东，如果募资额不到5百万，大家投的钱就还给大家。</p><p>现在ICO众筹已经被各路大佬拿来割韭菜而被玩坏了（不管有无达标，都把钱卷走）。</p><p>其实区块链技术本事非常适合解决众筹的信任问题，借助于智能合约，可以实现当募资额完成时，募资款自动打到指定账户，当募资额未完成时，可退款。这个过程不需要看众筹大佬的人品，不用依靠第三方平台信用担保。</p><h2 id="代币"><a href="#代币" class="headerlink" title="代币"></a>代币</h2><p>传统的众筹在参与之后通常不容易交易（参与之后无法转给其他人），而通过用代币来参与众筹，则很容易进行交易，众筹的参与人可随时进行买卖，待众筹项目实施完成的时候，完全根据代币持有量进行回馈。</p><p>举个例子说明下，大家会更容易理解，有这一个众筹：A有技术做一个能监测健康的指环，为此向公众募资200百万，募资时100块对应一个代币，约定在指环上市之后，代币的持有人可以用一个代币来兑换一个指环。而指环的研发周期是一年，因此在指环还未上市的一年里，众筹的参与人可以随时交易所持有的代币。</p><h2 id="众筹智能合约代码"><a href="#众筹智能合约代码" class="headerlink" title="众筹智能合约代码"></a>众筹智能合约代码</h2><p>接下来就看看如何实现一个众筹智能合约。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.16</span>;</span><br><span class="line"></span><br><span class="line">interface token &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">transfer</span>(<span class="params">address receiver, uint amount</span>);</span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">contract</span> <span class="title">Crowdsale</span> </span>&#123;</span><br><span class="line">    address public beneficiary;  <span class="comment">// 募资成功后的收款方</span></span><br><span class="line">    uint public fundingGoal;   <span class="comment">// 募资额度</span></span><br><span class="line">    uint public amountRaised;   <span class="comment">// 参与数量</span></span><br><span class="line">    uint public deadline;      <span class="comment">// 募资截止期</span></span><br><span class="line"></span><br><span class="line">    uint public price;    <span class="comment">//  token 与以太坊的汇率 , token卖多少钱</span></span><br><span class="line">    token public tokenReward;   <span class="comment">// 要卖的token</span></span><br><span class="line"></span><br><span class="line">    mapping(<span class="function"><span class="params">address</span> =&gt;</span> uint256) public balanceOf;</span><br><span class="line"></span><br><span class="line">    bool fundingGoalReached = <span class="literal">false</span>;  <span class="comment">// 众筹是否达到目标</span></span><br><span class="line">    bool crowdsaleClosed = <span class="literal">false</span>;   <span class="comment">//  众筹是否结束</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 事件可以用来跟踪信息</span></span><br><span class="line"><span class="comment">    **/</span></span><br><span class="line">    event GoalReached(address recipient, uint totalAmountRaised);</span><br><span class="line">    event FundTransfer(address backer, uint amount, bool isContribution);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造函数, 设置相关属性</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Crowdsale</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">        address ifSuccessfulSendTo,</span></span></span><br><span class="line"><span class="function"><span class="params">        uint fundingGoalInEthers,</span></span></span><br><span class="line"><span class="function"><span class="params">        uint durationInMinutes,</span></span></span><br><span class="line"><span class="function"><span class="params">        uint finneyCostOfEachToken,</span></span></span><br><span class="line"><span class="function"><span class="params">        address addressOfTokenUsedAsReward</span>) </span>&#123;</span><br><span class="line">            beneficiary = ifSuccessfulSendTo;</span><br><span class="line">            fundingGoal = fundingGoalInEthers * <span class="number">1</span> ether;</span><br><span class="line">            deadline = now + durationInMinutes * <span class="number">1</span> minutes;</span><br><span class="line">            price = finneyCostOfEachToken * <span class="number">1</span> finney;</span><br><span class="line">            tokenReward = token(addressOfTokenUsedAsReward);   <span class="comment">// 传入已发布的 token 合约的地址来创建实例</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 无函数名的Fallback函数，</span></span><br><span class="line"><span class="comment">     * 在向合约转账时，这个函数会被调用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> (<span class="params"></span>) <span class="title">payable</span> </span>&#123;</span><br><span class="line">        <span class="built_in">require</span>(!crowdsaleClosed);</span><br><span class="line">        uint amount = msg.value;</span><br><span class="line">        balanceOf[msg.sender] += amount;</span><br><span class="line">        amountRaised += amount;</span><br><span class="line">        tokenReward.transfer(msg.sender, amount / price);</span><br><span class="line">        FundTransfer(msg.sender, amount, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    *  定义函数修改器modifier（作用和Python的装饰器很相似）</span></span><br><span class="line"><span class="comment">    * 用于在函数执行前检查某种前置条件（判断通过之后才会继续执行该方法）</span></span><br><span class="line"><span class="comment">    * _ 表示继续执行之后的代码</span></span><br><span class="line"><span class="comment">    **/</span></span><br><span class="line">    modifier afterDeadline() &#123; <span class="keyword">if</span> (now &gt;= deadline) _; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断众筹是否完成融资目标， 这个方法使用了afterDeadline函数修改器</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">checkGoalReached</span>(<span class="params"></span>) <span class="title">afterDeadline</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (amountRaised &gt;= fundingGoal) &#123;</span><br><span class="line">            fundingGoalReached = <span class="literal">true</span>;</span><br><span class="line">            GoalReached(beneficiary, amountRaised);</span><br><span class="line">        &#125;</span><br><span class="line">        crowdsaleClosed = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 完成融资目标时，融资款发送到收款方</span></span><br><span class="line"><span class="comment">     * 未完成融资目标时，执行退款</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">safeWithdrawal</span>(<span class="params"></span>) <span class="title">afterDeadline</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!fundingGoalReached) &#123;</span><br><span class="line">            uint amount = balanceOf[msg.sender];</span><br><span class="line">            balanceOf[msg.sender] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (amount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (msg.sender.send(amount)) &#123;</span><br><span class="line">                    FundTransfer(msg.sender, amount, <span class="literal">false</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    balanceOf[msg.sender] = amount;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (fundingGoalReached &amp;&amp; beneficiary == msg.sender) &#123;</span><br><span class="line">            <span class="keyword">if</span> (beneficiary.send(amountRaised)) &#123;</span><br><span class="line">                FundTransfer(beneficiary, amountRaised, <span class="literal">false</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//If we fail to send the funds to beneficiary, unlock funders balance</span></span><br><span class="line">                fundingGoalReached = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="部署及说明"><a href="#部署及说明" class="headerlink" title="部署及说明"></a>部署及说明</h2><p>在部署这个合约之前，我们需要先部署一个代币合约，请参考<a href="https://learnblockchain.cn/2018/01/12/create_token/">一步步教你创建自己的数字货币</a>。</p><ol><li><p>创建众筹合约我们需要提供一下几个参数：<br>ifSuccessfulSendTo： 募资成功后的收款方（其实这里可以默认为合约创建者）<br>fundingGoalInEthers： 募资额度， 为了方便我们仅募3个ether<br>durationInMinutes： 募资时间<br>finneyCostOfEachToken 每个代币的价格, 这里为了方便使用了<a href="https://learnblockchain.cn/2018/02/02/solidity-unit/">单位finney</a>及值为：1 （1 ether =  1000 finney）<br>addressOfTokenUsedAsReward： 代币合约地址。<br>如：<br><img src="https://learnblockchain.cn/images/crowdsale_create.jpeg" alt=""><br>本文使用的参数为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;0xc6f9ea59d424733e8e1902c7837ea75e20abfb49&quot;,3, 100, 1,&quot;0xad8972e2b583f580fc52f737b98327eb65d08f8c&quot;</span><br></pre></td></tr></table></figure></li><li><p>参与人投资的时候实际购买众筹合约代币，所有需要先向合约预存代币，代币的数量为：募资额度 / 代币的价格 ， 这里为：3 * 1000/1 = 3000 （当能也可以大于3000）。<br>向合约预存代币可以使用<a href="https://www.myetherwallet.com/#send-transaction" target="_blank" rel="noopener">myetherwallet</a>钱包，或在remix中重新加载代币合约，执行代币合约tranfer()函数进行代币转账。如使用myetherwallet转账如图：<br><img src="https://learnblockchain.cn//images/crowdsale_send_token.jpeg" alt=""></p></li><li><p>参与人投资行为即是向买众筹合约转账，转账时，会执行Fallback回退函数（即无名函数）向其账户打回相应的代币。</p></li><li><p>safeWithdrawl() 可以被参与人或收益人执行，如果融资不达标参与人可收回之前投资款，如果融资达标收益人可以拿到所有的融资款。</p></li></ol><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>上面是一个很正规的募资合约。接下来讲两个募资合约的扩展，如何实现无限募资合约及割韭菜合约。<br>这部分内容独家发布在我的小专栏<a href="https://xiaozhuanlan.com/blockchaincore" target="_blank" rel="noopener">区块链技术</a></p><p>如果你在学习中遇到问题，欢迎到我的<strong><a href="https://t.xiaomiquan.com/RfAu7uj" target="_blank" rel="noopener">知识星球</a></strong>提问，作为星球成员福利，成员可加入区块链技术付费交流群。</p><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul><li><a href="https://ethereum.org/crowdsale" target="_blank" rel="noopener">Create a crowdsale</a></li></ul><p><a href="https://learnblockchain.cn/">深入浅出区块链</a> - 系统学习区块链，打造最好的区块链技术博客。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前面我们有两遍文章写了如何发行代币，今天我们讲一下如何使用代币来公开募资，即编写一个募资合约。&lt;/p&gt;
    
    </summary>
    
      <category term="以太坊" scheme="https://learnblockchain.cn/categories/ethereum/"/>
    
      <category term="智能合约" scheme="https://learnblockchain.cn/categories/ethereum/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/"/>
    
    
      <category term="智能合约" scheme="https://learnblockchain.cn/tags/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/"/>
    
      <category term="Token" scheme="https://learnblockchain.cn/tags/Token/"/>
    
      <category term="ICO" scheme="https://learnblockchain.cn/tags/ICO/"/>
    
  </entry>
  
  <entry>
    <title>什么是拜占庭将军问题</title>
    <link href="https://learnblockchain.cn/2018/02/05/bitcoin-byzantine/"/>
    <id>https://learnblockchain.cn/2018/02/05/bitcoin-byzantine/</id>
    <published>2018-02-04T16:00:00.000Z</published>
    <updated>2018-02-07T03:46:38.920Z</updated>
    
    <content type="html"><![CDATA[<p>接触区块链的同学，多少都听说过拜占庭将军问题，经常看到或听到某某区块链使用某某算法解决了拜占庭将军问题，那么究竟什么是拜占庭将军问题呢?</p><a id="more"></a><h2 id="什么是拜占庭将军问题"><a href="#什么是拜占庭将军问题" class="headerlink" title="什么是拜占庭将军问题"></a>什么是拜占庭将军问题</h2><p>也被称为“拜占庭容错”、“拜占庭将军问题”。<br>拜占庭将军问题是Leslie Lamport（2013年的图灵讲得住）用来为描述<strong>分布式系统一致性问题</strong>（Distributed Consensus）在<a href="http://lamport.azurewebsites.net/pubs/byz.pdf" target="_blank" rel="noopener">论文</a>中抽象出来一个著名的例子。</p><p>这个例子大意是这样的：</p><p>拜占庭帝国想要进攻一个强大的敌人，为此派出了10支军队去包围这个敌人。这个敌人虽不比拜占庭帝国，但也足以抵御5支常规拜占庭军队的同时袭击。这10支军队在分开的包围状态下同时攻击。他们任一支军队单独进攻都毫无胜算，除非有至少6支军队（一半以上）同时袭击才能攻下敌国。他们分散在敌国的四周，依靠通信兵骑马相互通信来协商进攻意向及进攻时间。困扰这些将军的问题是，他们不确定他们中是否有叛徒，叛徒可能擅自变更进攻意向或者进攻时间。在这种状态下，拜占庭将军们才能保证有多于6支军队在同一时间一起发起进攻，从而赢取战斗？</p><blockquote><p>拜占庭将军问题中并不去考虑通信兵是否会被截获或无法传达信息等问题，即消息传递的信道绝无问题。Lamport已经证明了在消息可能丢失的不可靠信道上试图通过消息传递的方式达到一致性是不可能的。所以，在研究拜占庭将军问题的时候，已经假定了信道是没有问题的.</p></blockquote><h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><p>单从上面的说明可能无法理解这个问题的复杂性，我们来简单分析一下：</p><ol><li><p>先看在没有叛徒情况下，假如一个将军A提一个进攻提议（如：明日下午1点进攻，你愿意加入吗？）由通信兵通信分别告诉其他的将军，如果幸运中的幸运，他收到了其他6位将军以上的同意，发起进攻。如果不幸，其他的将军也在此时发出不同的进攻提议（如：明日下午2点、3点进攻，你愿意加入吗？），由于时间上的差异，不同的将军收到（并认可）的进攻提议可能是不一样的，这是可能出现A提议有3个支持者，B提议有4个支持者，C提议有2个支持者等等。</p></li><li><p>再加一点复杂性，在有叛徒情况下，一个叛徒会向不同的将军发出不同的进攻提议（通知A明日下午1点进攻， 通知B明日下午2点进攻等等），一个叛徒也会可能同意多个进攻提议（即同意下午1点进攻又同意下午2点进攻）。</p><blockquote><p>叛徒发送前后不一致的进攻提议，被称为“拜占庭错误”，而能够处理拜占庭错误的这种容错性称为「Byzantine fault tolerance」，简称为BFT。</p></blockquote></li></ol><p>相信大家已经可以明白这个问题的复杂性了。</p><h2 id="中本聪的解决方案"><a href="#中本聪的解决方案" class="headerlink" title="中本聪的解决方案"></a>中本聪的解决方案</h2><p>在出现比特币之前，解决分布式系统一致性问题主要是Lamport提出的Paxos算法或其衍生算法。Paxos类算法仅适用于中心化的分布式系统，这样的系统的没有不诚实的节点（不会发送虚假错误消息，但允许出现网络不通或宕机出现的消息延迟）。</p><p>中本聪在比特币中创造性的引入了“工作量证明（POW : Proof of Work）”来解决这个问题，有兴趣可进一步阅读<a href="https://learnblockchain.cn/2017/11/04/bitcoin-pow/">工作量证明</a>。<br>通过工作量证明就增加了发送信息的成本，降低节点发送消息速率，这样就以保证在一个时间只有一个节点(或是很少)在进行广播，同时在广播时会附上自己的签名。<br>这个过程就像一位将军A在向其他的将军（B、C、D…）发起一个进攻提议一样，将军B、C、D…看到将军A签过名的进攻提议书，如果是诚实的将军就会立刻同意进攻提议，而不会发起自己新的进攻提议。</p><p>以上就是比特币网络中是单个区块（账本）达成共识的方法（取得一致性）。</p><p>理解了单个区块取得一致性的方法，那么整个区块链（总账本）如果达成一致也好理解。<br>我们稍微把将军问题改一下：假设攻下一个城堡需要多次的进攻，每次进攻的提议必须基于之前最多次数的胜利进攻下提出的（只有这样敌方已有损失最大，我方进攻胜利的可能性就更大），这样约定之后，将军A在收到进攻提议时，就会检查一下这个提议是不是基于最多的胜利提出的，如果不是（基于最多的胜利）将军A就不会同意这样的提议，如果是的，将军A就会把这次提议记下来。</p><p>这就是比特币网络<a href="https://xiaozhuanlan.com/topic/0298513746" target="_blank" rel="noopener">最长链选择</a>。</p><h2 id="经济学分析"><a href="#经济学分析" class="headerlink" title="经济学分析"></a>经济学分析</h2><p>工作量证明其实相当于提高了做叛徒（发布虚假区块）的成本，在工作量证明下，只有第一个完成证明的节点才能广播区块，竞争难度非常大，需要很高的算力，如果不成功其算力就白白的耗费了（算力是需要成本的），如果有这样的算力作为诚实的节点，同样也可以获得很大的收益（这就是矿工所作的工作），这也实际就不会有做叛徒的动机，整个系统也因此而更稳定。</p><p>很多人批评工作量证明造成巨大的电力浪费，促使人们去探索新的解决一致性（共识）问题的机制：权益证明机制（POS: Proof of Stake）是一个代表。在拜占庭将军问题的角度来看，它同样提高了做叛徒的成本，因为账户需要首先持有大量余额才能有更多的几率广播区块，POS不是本文重点，以后在讲。</p><blockquote><p>共识算法的核心就是解决拜占庭将军问题（分布式网络一致性问题）。</p></blockquote><h2 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h2><p><a href="http://lamport.azurewebsites.net/pubs/byz.pdf" target="_blank" rel="noopener">The Byzantine Generals Problem</a></p><p><a href="https://learnblockchain.cn/">深入浅出区块链</a> - 系统学习区块链，打造最好的区块链技术博客。<br>如果想与我有更密切的交流可以选择加入我的<a href="https://t.xiaomiquan.com/RfAu7uj" target="_blank" rel="noopener">知识星球</a>（星球成员可加入微信技术交流群）</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;接触区块链的同学，多少都听说过拜占庭将军问题，经常看到或听到某某区块链使用某某算法解决了拜占庭将军问题，那么究竟什么是拜占庭将军问题呢?&lt;/p&gt;
    
    </summary>
    
      <category term="比特币" scheme="https://learnblockchain.cn/categories/bitcoin/"/>
    
    
      <category term="比特币" scheme="https://learnblockchain.cn/tags/%E6%AF%94%E7%89%B9%E5%B8%81/"/>
    
      <category term="共识协议" scheme="https://learnblockchain.cn/tags/%E5%85%B1%E8%AF%86%E5%8D%8F%E8%AE%AE/"/>
    
  </entry>
  
  <entry>
    <title>智能合约语言 Solidity 教程系列7 - 以太单位及时间单位</title>
    <link href="https://learnblockchain.cn/2018/02/02/solidity-unit/"/>
    <id>https://learnblockchain.cn/2018/02/02/solidity-unit/</id>
    <published>2018-02-02T11:51:03.000Z</published>
    <updated>2018-03-19T03:26:58.537Z</updated>
    
    <content type="html"><![CDATA[<p>这是Solidity教程系列文章第7篇介绍以太单位及时间单位，系列带你全面深入理解Solidity语言。<br>Solidity 系列完整的文章列表请查看<a href="https://learnblockchain.cn/categories/ethereum/Solidity/">分类-Solidity</a>。</p><a id="more"></a><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>Solidity 是以太坊智能合约编程语言，阅读本文前，你应该对以太坊、智能合约有所了解，<br>如果你还不了解，建议你先看<a href="https://learnblockchain.cn/2017/11/20/whatiseth/">以太坊是什么</a></p><p>欢迎订阅<a href="https://xiaozhuanlan.com/blockchaincore" target="_blank" rel="noopener">区块链技术专栏</a>阅读更全面的分析文章。</p><h2 id="货币单位（Ether-Units）"><a href="#货币单位（Ether-Units）" class="headerlink" title="货币单位（Ether Units）"></a>货币单位（Ether Units）</h2><p>一个数字常量（字面量）后面跟随一个后缀<strong>wei</strong>, <strong>finney</strong>,<strong>szabo</strong>或<strong>ether</strong>，这个后缀就是货币单位。不同的单位可以转换。不含任何后缀的默认单位是wei。<br>不同的以太币单位转换关系如下：</p><ul><li>1 ether == 10^3 finney == 1000 finney</li><li>1 ether == 10^6 szabo</li><li>1 ether == 10^18 wei</li></ul><blockquote><p>插曲：以太币单位其实是密码学家的名字，是以太坊创始人为了纪念他们在数字货币的领域的贡献。他们分别是：<br>wei:  Wei Dai  戴伟 密码学家 ，发表 B-money<br>finney: Hal Finney   芬尼  密码学家、工作量证明机制（POW）提出<br>szabo:  Nick Szabo  尼克萨博  密码学家、智能合约的提出者</p></blockquote><p>我们可以使用一下代码验证一个转换关系：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.16</span>;</span><br><span class="line"></span><br><span class="line">contract testUnit &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">tf</span>(<span class="params"></span>) <span class="title">public</span> <span class="title">pure</span> <span class="title">returns</span> (<span class="params">bool</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="number">1</span> ether == <span class="number">1000</span> finney)&#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">ts</span>(<span class="params"></span>) <span class="title">public</span> <span class="title">pure</span> <span class="title">returns</span> (<span class="params">bool</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="number">1</span> ether == <span class="number">1000000</span> szabo)&#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">tgw</span>(<span class="params"></span>) <span class="title">public</span> <span class="title">pure</span> <span class="title">returns</span> (<span class="params">bool</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="number">1</span> ether == <span class="number">1000000000000000000</span> wei)&#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="时间单位（Time-Units）"><a href="#时间单位（Time-Units）" class="headerlink" title="时间单位（Time Units）"></a>时间单位（Time Units）</h2><p>时间单位: seconds, minutes, hours, days, weeks, years均可做为后缀，并进行相互转换，规则如下：</p><ul><li>1 == 1 seconds (默认是seconds为单位)</li><li>1 minutes == 60 seconds</li><li>1 hours == 60 minutes</li><li>1 days == 24 hours</li><li>1 weeks = 7 days</li><li>1 years = 365 days</li></ul><p>使用这些单位进行日期计算需要特别小心，因为不是每年都是365天，且并不是每天都有24小时，因为还有闰秒。由于无法预测闰秒，必须由外部的预言（oracle）来更新从而得到一个精确的日历库。</p><p>这些后缀不能用于变量。如果想对输入的变量说明其不同的单位，可以使用下面的方式：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.16</span>;</span><br><span class="line"></span><br><span class="line">contract testTUnit &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">currTimeInSeconds</span>(<span class="params"></span>) <span class="title">public</span> <span class="title">pure</span> <span class="title">returns</span> (<span class="params">uint256</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> now;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">uint start, uint daysAfter</span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (now &gt;= start + daysAfter * <span class="number">1</span> days) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul><li><a href="https://solidity.readthedocs.io/en/develop/units-and-global-variables.html#units-and-globally-available-variables" target="_blank" rel="noopener">units</a></li></ul><p><a href="https://learnblockchain.cn/">深入浅出区块链</a> - 系统学习区块链，打造最好的区块链技术博客。<br>如果想与我有更密切的交流可以选择加入我的<a href="https://t.xiaomiquan.com/RfAu7uj" target="_blank" rel="noopener">知识星球</a>（星球成员可加入微信技术交流群）</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是Solidity教程系列文章第7篇介绍以太单位及时间单位，系列带你全面深入理解Solidity语言。&lt;br&gt;Solidity 系列完整的文章列表请查看&lt;a href=&quot;https://learnblockchain.cn/categories/ethereum/Solidity/&quot;&gt;分类-Solidity&lt;/a&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="以太坊" scheme="https://learnblockchain.cn/categories/ethereum/"/>
    
      <category term="Solidity" scheme="https://learnblockchain.cn/categories/ethereum/Solidity/"/>
    
    
      <category term="Solidity手册" scheme="https://learnblockchain.cn/tags/Solidity%E6%89%8B%E5%86%8C/"/>
    
  </entry>
  
  <entry>
    <title>实现一个可管理、增发、兑换、冻结等高级功能的代币</title>
    <link href="https://learnblockchain.cn/2018/01/27/create-token2/"/>
    <id>https://learnblockchain.cn/2018/01/27/create-token2/</id>
    <published>2018-01-27T09:04:13.000Z</published>
    <updated>2018-02-08T12:34:25.998Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要介绍代币高级功能的实现: 代币管理、代币增发、代币兑换、资产冻结、Gas自动补充。<br><a id="more"></a></p><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>在<a href="https://learnblockchain.cn/2018/01/12/create_token/">上一篇：一步步教你创建自己的数字货币（代币）进行ICO</a>中我们实现一个最基本功能的代币，本文将在上一遍文章的基础上，讲解如果添加更多的高级功能。</p><h2 id="实现代币的管理者"><a href="#实现代币的管理者" class="headerlink" title="实现代币的管理者"></a>实现代币的管理者</h2><p>虽然区块链是去中心化的，但是实现对代币（合约）的管理，也在许多应用中有需求，为了对代币进行管理，首先需要给合约添加一个管理者。</p><p>我们来看看如果实现，先创建一个<strong>owned</strong>合约。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">contract owned &#123;</span><br><span class="line">    address public owner;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">owned</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        owner = msg.sender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    modifier onlyOwner &#123;</span><br><span class="line">        <span class="built_in">require</span>(msg.sender == owner);</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实现所有权转移</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">transferOwnership</span>(<span class="params">address newOwner</span>) <span class="title">onlyOwner</span> </span>&#123;</span><br><span class="line">        owner = newOwner;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个合约重要的是加入了一个函数修改器（Function Modifiers）<strong>onlyOwner</strong>，函数修改器是一个合约属性，可以被继承，还能被重写。它用于在函数执行前检查某种前置条件。</p><blockquote><p>如果熟悉Python的同学，会发现函数修改器的作用和Python的装饰器很相似。</p></blockquote><p>然后让代币合约继承owned以拥有<strong>onlyOwner</strong>修改器，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">contract MyToken is owned &#123;</span><br><span class="line">    function MyToken(</span><br><span class="line">        uint256 initialSupply,</span><br><span class="line">        string tokenName,</span><br><span class="line">        uint8 decimalUnits,</span><br><span class="line">        string tokenSymbol,</span><br><span class="line">        address centralMinter</span><br><span class="line">        ) &#123;</span><br><span class="line">        if(centralMinter != 0 ) owner = centralMinter;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="代币增发"><a href="#代币增发" class="headerlink" title="代币增发"></a>代币增发</h2><p>实现代币增发，代币增发就如同央行印钞票一样，想必很多人都需要这样的功能。</p><p>给合约添加以下的方法：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mintToken</span>(<span class="params">address target, uint256 mintedAmount</span>) <span class="title">onlyOwner</span> </span>&#123;</span><br><span class="line">        balanceOf[target] += mintedAmount;</span><br><span class="line">        totalSupply += mintedAmount;</span><br><span class="line">        Transfer(<span class="number">0</span>, owner, mintedAmount);</span><br><span class="line">        Transfer(owner, target, mintedAmount);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>注意<strong>onlyOwner</strong>修改器添加在函数末尾，这表示只有<strong>ower</strong>才能调用这用函数。<br>他的功能很简单，就是给指定的账户增加代币，同时增加总供应量。</p><h2 id="资产冻结"><a href="#资产冻结" class="headerlink" title="资产冻结"></a>资产冻结</h2><p>有时为了监管的需要，需要实现冻结某些账户，冻结后，其资产仍在账户，但是不允许交易，之道解除冻结。<br>给合约添加以下的变量和方法（可以添加到合约的任何地方，但是建议把mapping加到和其他mapping一起，event也是如此）：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mapping (<span class="function"><span class="params">address</span> =&gt;</span> bool) public frozenAccount;</span><br><span class="line">event FrozenFunds(address target, bool frozen);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">freezeAccount</span>(<span class="params">address target, bool freeze</span>) <span class="title">onlyOwner</span> </span>&#123;</span><br><span class="line">    frozenAccount[target] = freeze;</span><br><span class="line">    FrozenFunds(target, freeze);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>单单以上的代码还无法冻结，需要把他加入到transfer函数中才能真正生效，因此修改transfer函数<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">transfer</span>(<span class="params">address _to, uint256 _value</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">require</span>(!frozenAccount[msg.sender]);</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这样在转账前，对发起交易的账号做一次检查，只有不是被冻结的账号才能转账。</p><h2 id="代币买卖（兑换）"><a href="#代币买卖（兑换）" class="headerlink" title="代币买卖（兑换）"></a>代币买卖（兑换）</h2><p>可以自己的货币中实现代币与其他数字货币（ether 或其他tokens）的兑换机制。有了这个功能，我们的合约就可以在一买一卖中赚利润了。</p><p>先来设置下买卖价格<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">uint256 public sellPrice;</span><br><span class="line">uint256 public buyPrice;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setPrices</span>(<span class="params">uint256 newSellPrice, uint256 newBuyPrice</span>) <span class="title">onlyOwner</span> </span>&#123;</span><br><span class="line">    sellPrice = newSellPrice;</span><br><span class="line">    buyPrice = newBuyPrice;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>setPrices()添加了<strong>onlyOwner</strong>修改器，注意买卖的价格单位是wei（最小的货币单位： 1 eth = 1000000000000000000 wei)</p><p>添加来添加买卖函数:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">buy</span>(<span class="params"></span>) <span class="title">payable</span> <span class="title">returns</span> (<span class="params">uint amount</span>)</span>&#123;</span><br><span class="line">    amount = msg.value / buyPrice;                    <span class="comment">// calculates the amount</span></span><br><span class="line">    <span class="built_in">require</span>(balanceOf[<span class="keyword">this</span>] &gt;= amount);               <span class="comment">// checks if it has enough to sell</span></span><br><span class="line">    balanceOf[msg.sender] += amount;                  <span class="comment">// adds the amount to buyer's balance</span></span><br><span class="line">    balanceOf[<span class="keyword">this</span>] -= amount;                        <span class="comment">// subtracts amount from seller's balance</span></span><br><span class="line">    Transfer(<span class="keyword">this</span>, msg.sender, amount);               <span class="comment">// execute an event reflecting the change</span></span><br><span class="line">    <span class="keyword">return</span> amount;                                    <span class="comment">// ends function and returns</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sell</span>(<span class="params">uint amount</span>) <span class="title">returns</span> (<span class="params">uint revenue</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">require</span>(balanceOf[msg.sender] &gt;= amount);         <span class="comment">// checks if the sender has enough to sell</span></span><br><span class="line">    balanceOf[<span class="keyword">this</span>] += amount;                        <span class="comment">// adds the amount to owner's balance</span></span><br><span class="line">    balanceOf[msg.sender] -= amount;                  <span class="comment">// subtracts the amount from seller's balance</span></span><br><span class="line">    revenue = amount * sellPrice;</span><br><span class="line">    msg.sender.transfer(revenue);                     <span class="comment">// sends ether to the seller: it's important to do this last to prevent recursion attacks</span></span><br><span class="line">    Transfer(msg.sender, <span class="keyword">this</span>, amount);               <span class="comment">// executes an event reflecting on the change</span></span><br><span class="line">    <span class="keyword">return</span> revenue;                                   <span class="comment">// ends function and returns</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>加入了买卖功能后，要求我们在创建合约时发送足够的以太币，以便合约有能力回购市面上的代币，否则合约将破产，用户没法先合约卖代币。</p><h2 id="实现Gas的自动补充"><a href="#实现Gas的自动补充" class="headerlink" title="实现Gas的自动补充"></a>实现Gas的自动补充</h2><p>以太坊中的交易时需要gas（支付给矿工的费用，费用以ether来支付）。而如果用户没有以太币，只有代币的情况（或者我们想向用户隐藏以太坊的细节），就需要自动补充gas的功能。这个功能将使我们代币更加好用。</p><p>自动补充的逻辑是这样了，在执行交易之前，我们判断用户的余额（用来支付矿工的费用），如果用户的余额非常少（低于某个阈值时）可能影响到交易进行，合约自动售出一部分代币来补充余额，以帮助用户顺利完成交易。</p><p>先来设定余额阈值：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">uint minBalanceForAccounts;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">setMinBalance</span>(<span class="params">uint minimumBalanceInFinney</span>) <span class="title">onlyOwner</span> </span>&#123;</span><br><span class="line">         minBalanceForAccounts = minimumBalanceInFinney * <span class="number">1</span> finney;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>finney 是货币单位 1 finney = 0.001eth<br>然后交易中加入对用户的余额的判断。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">transfer</span>(<span class="params">address _to, uint256 _value</span>) </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span>(msg.sender.balance &lt; minBalanceForAccounts)</span><br><span class="line">        sell((minBalanceForAccounts - msg.sender.balance) / sellPrice);</span><br><span class="line">    <span class="keyword">if</span>(_to.balance&lt;minBalanceForAccounts)   <span class="comment">// 可选，让接受者也补充余额，以便接受者使用代币。</span></span><br><span class="line">        _to.send(sell((minBalanceForAccounts - _to.balance) / sellPrice));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="代码部署"><a href="#代码部署" class="headerlink" title="代码部署"></a>代码部署</h2><p>高级功能完整代码请前往我的<a href="https://xiaozhuanlan.com/blockchaincore" target="_blank" rel="noopener">小专栏</a>， 项目的完整的部署方法参考<a href="https://learnblockchain.cn/2018/01/12/create_token/">上一篇</a>，不同的是创建合约时需要预存余额，如图：</p><p><img src="https://learnblockchain.cn/images/create_adv_token.jpg" alt=""></p><p>专栏已经有多篇文章介绍Remix Solidity IDE的使用，这里就不一一截图演示了，请大家自己测试验证。</p><p>如果你在创建代币的过程中遇到问题，欢迎到我的<strong><a href="https://t.xiaomiquan.com/RfAu7uj" target="_blank" rel="noopener">知识星球</a></strong>提问，作为星球成员福利，成员可加入区块链技术付费交流群。</p><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul><li><a href="https://ethereum.org/token" target="_blank" rel="noopener">Create your own crypto-currency with ethereum</a></li></ul><p><a href="https://learnblockchain.cn/">深入浅出区块链</a> - 系统学习区块链，打造最好的区块链技术博客。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要介绍代币高级功能的实现: 代币管理、代币增发、代币兑换、资产冻结、Gas自动补充。&lt;br&gt;
    
    </summary>
    
      <category term="以太坊" scheme="https://learnblockchain.cn/categories/ethereum/"/>
    
      <category term="智能合约" scheme="https://learnblockchain.cn/categories/ethereum/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/"/>
    
    
      <category term="智能合约" scheme="https://learnblockchain.cn/tags/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/"/>
    
      <category term="Token" scheme="https://learnblockchain.cn/tags/Token/"/>
    
  </entry>
  
  <entry>
    <title>一步步教你创建自己的数字货币（代币）进行ICO</title>
    <link href="https://learnblockchain.cn/2018/01/12/create_token/"/>
    <id>https://learnblockchain.cn/2018/01/12/create_token/</id>
    <published>2018-01-12T14:36:39.000Z</published>
    <updated>2018-02-08T12:34:13.386Z</updated>
    
    <content type="html"><![CDATA[<p>本文从技术角度详细介绍如何基于以太坊ERC20创建代币的流程.</p><a id="more"></a><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>本文所讲的代币是使用以太坊智能合约创建，阅读本文前，你应该对以太坊、智能合约有所了解，如果你还不了解，建议你先看<a href="https://learnblockchain.cn/2017/11/20/whatiseth/">以太坊是什么</a></p><h2 id="代币Token"><a href="#代币Token" class="headerlink" title="代币Token"></a>代币Token</h2><p>如果不那么追求精确的定义，代币就是数字货币，比特币、以太币就是一个代币。<br>利用以太坊的智能合约可以轻松编写出属于自己的代币，代币可以代表任何可以交易的东西，如：积分、财产、证书等等。<br>因此不管是出于商业，还是学习很多人想创建一个自己的代币，先贴一个图看看创建的代币是什么样子。<br><img src="https://learnblockchain.cn/images/token_info.jpeg" alt=""></p><p>今天我们就来详细讲一讲怎样创建一个这样的代币。</p><h3 id="ERC20-Token"><a href="#ERC20-Token" class="headerlink" title="ERC20 Token"></a>ERC20 Token</h3><p>也许你经常看到ERC20和代币一同出现， ERC20是以太坊定义的一个<a href="https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md" target="_blank" rel="noopener">代币标准</a>。<br>要求我们在实现代币的时候必须要遵守的协议，如指定代币名称、总量、实现代币交易函数等，只有支持了协议才能被以太坊钱包支持。<br>其接口如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">contract ERC20Interface &#123;</span><br><span class="line"></span><br><span class="line">    string public constant name = <span class="string">"Token Name"</span>;</span><br><span class="line">    string public constant symbol = <span class="string">"SYM"</span>;</span><br><span class="line">    uint8 public constant decimals = <span class="number">18</span>;  <span class="comment">// 18 is the most common number of decimal places</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">totalSupply</span>(<span class="params"></span>) <span class="title">public</span> <span class="title">constant</span> <span class="title">returns</span> (<span class="params">uint</span>);</span></span><br><span class="line"><span class="function">    <span class="title">function</span> <span class="title">balanceOf</span>(<span class="params">address tokenOwner</span>) <span class="title">public</span> <span class="title">constant</span> <span class="title">returns</span> (<span class="params">uint balance</span>);</span></span><br><span class="line"><span class="function">    <span class="title">function</span> <span class="title">allowance</span>(<span class="params">address tokenOwner, address spender</span>) <span class="title">public</span> <span class="title">constant</span> <span class="title">returns</span> (<span class="params">uint remaining</span>);</span></span><br><span class="line"><span class="function">    <span class="title">function</span> <span class="title">transfer</span>(<span class="params">address to, uint tokens</span>) <span class="title">public</span> <span class="title">returns</span> (<span class="params">bool success</span>);</span></span><br><span class="line"><span class="function">    <span class="title">function</span> <span class="title">approve</span>(<span class="params">address spender, uint tokens</span>) <span class="title">public</span> <span class="title">returns</span> (<span class="params">bool success</span>);</span></span><br><span class="line"><span class="function">    <span class="title">function</span> <span class="title">transferFrom</span>(<span class="params">address from, address to, uint tokens</span>) <span class="title">public</span> <span class="title">returns</span> (<span class="params">bool success</span>);</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="title">event</span> <span class="title">Transfer</span>(<span class="params">address indexed from, address indexed to, uint tokens</span>);</span></span><br><span class="line"><span class="function">    <span class="title">event</span> <span class="title">Approval</span>(<span class="params">address indexed tokenOwner, address indexed spender, uint tokens</span>);</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure><p>简单说明一下：<br>name ：  代币名称<br>symbol： 代币符号<br>decimals： 代币小数点位数，代币的最小单位， 18表示我们可以拥有 .0000000000000000001单位个代币。<br>totalSupply() : 发行代币总量。<br>balanceOf(): 查看对应账号的代币余额。<br>transfer(): 实现代币交易，用于给用户发送代币（从我们的账户里）。<br>transferFrom():  实现代币用户之间的交易。<br>allowance(): 控制代币的交易，如可交易账号及资产。<br>approve():  允许用户可花费的代币数。</p><h2 id="编写代币合约代码"><a href="#编写代币合约代码" class="headerlink" title="编写代币合约代码"></a>编写代币合约代码</h2><p>代币合约代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.16</span>;</span><br><span class="line"></span><br><span class="line">interface tokenRecipient &#123; <span class="function"><span class="keyword">function</span> <span class="title">receiveApproval</span>(<span class="params">address _from, uint256 _value, address _token, bytes _extraData</span>) <span class="title">public</span>; &#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">contract</span> <span class="title">TokenERC20</span> </span>&#123;</span><br><span class="line">    string public name;</span><br><span class="line">    string public symbol;</span><br><span class="line">    uint8 public decimals = <span class="number">18</span>;  <span class="comment">// 18 是建议的默认值</span></span><br><span class="line">    uint256 public totalSupply;</span><br><span class="line"></span><br><span class="line">    mapping (<span class="function"><span class="params">address</span> =&gt;</span> uint256) public balanceOf;  <span class="comment">// </span></span><br><span class="line">    mapping (<span class="function"><span class="params">address</span> =&gt;</span> mapping (<span class="function"><span class="params">address</span> =&gt;</span> uint256)) public allowance;</span><br><span class="line"></span><br><span class="line">    event Transfer(address indexed <span class="keyword">from</span>, address indexed to, uint256 value);</span><br><span class="line"></span><br><span class="line">    event Burn(address indexed <span class="keyword">from</span>, uint256 value);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">TokenERC20</span>(<span class="params">uint256 initialSupply, string tokenName, string tokenSymbol</span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">        totalSupply = initialSupply * <span class="number">10</span> ** uint256(decimals);</span><br><span class="line">        balanceOf[msg.sender] = totalSupply;</span><br><span class="line">        name = tokenName;</span><br><span class="line">        symbol = tokenSymbol;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">_transfer</span>(<span class="params">address _from, address _to, uint _value</span>) <span class="title">internal</span> </span>&#123;</span><br><span class="line">        <span class="built_in">require</span>(_to != <span class="number">0x0</span>);</span><br><span class="line">        <span class="built_in">require</span>(balanceOf[_from] &gt;= _value);</span><br><span class="line">        <span class="built_in">require</span>(balanceOf[_to] + _value &gt; balanceOf[_to]);</span><br><span class="line">        uint previousBalances = balanceOf[_from] + balanceOf[_to];</span><br><span class="line">        balanceOf[_from] -= _value;</span><br><span class="line">        balanceOf[_to] += _value;</span><br><span class="line">        Transfer(_from, _to, _value);</span><br><span class="line">        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">transfer</span>(<span class="params">address _to, uint256 _value</span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">        _transfer(msg.sender, _to, _value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">transferFrom</span>(<span class="params">address _from, address _to, uint256 _value</span>) <span class="title">public</span> <span class="title">returns</span> (<span class="params">bool success</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">require</span>(_value &lt;= allowance[_from][msg.sender]);     <span class="comment">// Check allowance</span></span><br><span class="line">        allowance[_from][msg.sender] -= _value;</span><br><span class="line">        _transfer(_from, _to, _value);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">approve</span>(<span class="params">address _spender, uint256 _value</span>) <span class="title">public</span></span></span><br><span class="line"><span class="function">        <span class="title">returns</span> (<span class="params">bool success</span>) </span>&#123;</span><br><span class="line">        allowance[msg.sender][_spender] = _value;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">approveAndCall</span>(<span class="params">address _spender, uint256 _value, bytes _extraData</span>) <span class="title">public</span> <span class="title">returns</span> (<span class="params">bool success</span>) </span>&#123;</span><br><span class="line">        tokenRecipient spender = tokenRecipient(_spender);</span><br><span class="line">        <span class="keyword">if</span> (approve(_spender, _value)) &#123;</span><br><span class="line">            spender.receiveApproval(msg.sender, _value, <span class="keyword">this</span>, _extraData);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">burn</span>(<span class="params">uint256 _value</span>) <span class="title">public</span> <span class="title">returns</span> (<span class="params">bool success</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">require</span>(balanceOf[msg.sender] &gt;= _value);</span><br><span class="line">        balanceOf[msg.sender] -= _value;</span><br><span class="line">        totalSupply -= _value;</span><br><span class="line">        Burn(msg.sender, _value);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">burnFrom</span>(<span class="params">address _from, uint256 _value</span>) <span class="title">public</span> <span class="title">returns</span> (<span class="params">bool success</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">require</span>(balanceOf[_from] &gt;= _value);</span><br><span class="line">        <span class="built_in">require</span>(_value &lt;= allowance[_from][msg.sender]);</span><br><span class="line">        balanceOf[_from] -= _value;</span><br><span class="line">        allowance[_from][msg.sender] -= _value;</span><br><span class="line">        totalSupply -= _value;</span><br><span class="line">        Burn(_from, _value);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码的详细解读，请订阅我的<a href="https://xiaozhuanlan.com/blockchaincore" target="_blank" rel="noopener">小专栏</a>。</p><h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><p>在开发测试智能合约时，<a href="https://metamask.io/" target="_blank" rel="noopener">MetaMask</a>和<a href="https://remix.ethereum.org" target="_blank" rel="noopener">Remix Solidity IDE</a>是两个非常好用的工具，今天就用他们来完成部署。</p><ol><li><p>安装和配置MetaMask请参考<a href="https://learnblockchain.cn/2018/01/12/first-dapp">开发、部署第一个去中心化应用</a>，不同的上本文选择了以太坊的测试网络Ropsten，如果你没有余额请点击购买buy，进入的网站可以送一些测试以太币给你，配置好之后，界面应该如下：<br><img src="https://learnblockchain.cn/images/metamask_main.png" alt=""></p></li><li><p>浏览器打开Remix Solidity IDE，复制以上源码粘贴上，在右侧选项参考如图的设置：<br><img src="https://learnblockchain.cn/images/token_create_remix.jpeg" alt=""><br>注意Environment和Account和MetaMask保持一致，然后选择合约TokenERC20，填入你想要的发行量，名称及代号，就可以创建合约了。<br>这时MetaMask会弹出一个交易确认框，点SUBMIT。待合约部署交易确认之后，复制合约地址。</p></li><li><p>打开Metamask界面，切换到TOKENS，点添加合约，出现如下对话框：<br><img src="https://learnblockchain.cn/images/metamask_add_token.png" alt=""><br>填入刚刚复制的地址，点ADD，这时你就可以看到你创建的代币了，如图：<br><img src="https://learnblockchain.cn/images/metamask_token_added.png" alt=""></p></li></ol><p>哈哈，你已经完成了代币的创建和部署(正式网络和测试网络部署方法一样)，可以在<a href="https://ropsten.etherscan.io/token/0x1f0c085ad323bb69758111cf9ecdc32a32d9a5bb" target="_blank" rel="noopener">Etherscan</a>查询到我们刚刚部署的代币。可以用它进行ICO了，从此走上人生巅峰（玩笑话，不鼓励大家发行无意义的代币）。</p><h2 id="代币交易"><a href="#代币交易" class="headerlink" title="代币交易"></a>代币交易</h2><p>由于MetaMask插件没有提供代币交易功能，同时考虑到很多人并没有以太坊钱包或是被以太坊钱包网络同步问题折磨，今天我用<a href="https://www.myetherwallet.com" target="_blank" rel="noopener">网页钱包</a>来讲解代币交易。</p><ol><li>进入<a href="https://www.myetherwallet.com/#send-transaction" target="_blank" rel="noopener">网页钱包地址</a>, 第一次进入有一些安全提示需要用户确认。</li><li>进入之后，按照下图进行设置：<br><img src="https://learnblockchain.cn/images/myetherwaller.jpeg" alt=""></li><li>连接上之后，如图<br><img src="https://learnblockchain.cn/images/myetherwaller_connected.jpeg" alt=""><br>需要添加代币，填入代币合约地址。</li><li>进行代币转账交易<br><img src="https://learnblockchain.cn/images/myetherwaller_transfer.jpeg" alt=""><br>在接下来的交易确认也，点击确认即可。</li><li>交易完成后，可以看到MetaMask中代币余额减少了，如图：<br><img src="https://learnblockchain.cn/images/metamask_token_tansfered.png" alt=""></li></ol><p>代币交易是不是很简单，只要明白了交易流程，使用其他的钱包也是一样的道理。</p><p>如果你在创建代币的过程中遇到问题，我的<strong><a href="https://t.xiaomiquan.com/RfAu7uj" target="_blank" rel="noopener">知识星球</a></strong>可为大家解答问题，作为星球成员福利，成员还可加入区块链技术付费交流群。</p><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul><li><a href="https://theethereum.wiki/w/index.php/ERC20_Token_Standard" target="_blank" rel="noopener">代币标准</a></li><li><a href="https://ethereum.org/token" target="_blank" rel="noopener">Create your own crypto-currency with ethereum</a></li></ul><p><a href="https://learnblockchain.cn/">深入浅出区块链</a> - 系统学习区块链，打造最好的区块链技术博客。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文从技术角度详细介绍如何基于以太坊ERC20创建代币的流程.&lt;/p&gt;
    
    </summary>
    
      <category term="以太坊" scheme="https://learnblockchain.cn/categories/ethereum/"/>
    
      <category term="智能合约" scheme="https://learnblockchain.cn/categories/ethereum/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/"/>
    
    
      <category term="智能合约" scheme="https://learnblockchain.cn/tags/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/"/>
    
      <category term="Token" scheme="https://learnblockchain.cn/tags/Token/"/>
    
  </entry>
  
  <entry>
    <title>一步步教你开发、部署第一个去中心化应用(Dapp) - 宠物商店</title>
    <link href="https://learnblockchain.cn/2018/01/12/first-dapp/"/>
    <id>https://learnblockchain.cn/2018/01/12/first-dapp/</id>
    <published>2018-01-12T14:36:39.000Z</published>
    <updated>2018-01-24T12:39:59.701Z</updated>
    
    <content type="html"><![CDATA[<p>今天我们来编写一个完整的去中心化（区块链）应用（Dapps）, 本文可以和<a href="https://learnblockchain.cn/2017/11/24/init-env/">编写智能合约</a>结合起来看。</p><a id="more"></a><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>阅读本文前，你应该对以太坊、智能合约有所了解，如果你还不了解，建议你先看<a href="https://learnblockchain.cn/2017/11/20/whatiseth/">以太坊是什么</a><br>除此之外，你最好还了解一些HTML及JavaScript知识。</p><p>本文通过实例教大家来开发去中心化应用，应用效果如图：<br><img src="https://learnblockchain.cn/images/Petshop.jpg" alt=""></p><p>从本文，你可以学习到：</p><ul><li>搭建智能合约开发环境</li><li>创建Truffle项目</li><li>编写智能合约</li><li>编译和部署智能合约到区块链</li><li>如何通过Web3和智能合约交互</li><li>MetaMask 的使用</li></ul><p><a href="https://xiaozhuanlan.com/blockchaincore" target="_blank" rel="noopener">小专栏</a>用户在教程结尾处可以下载完整的Dapp代码。</p><h2 id="项目背景"><a href="#项目背景" class="headerlink" title="项目背景"></a>项目背景</h2><p>Pete有一个宠物店，有16只宠物，他想开发一个去中心化应用，让大家来领养宠物。<br>在truffle box中，已经提供了pet-shop的网站部分的代码，我们只需要编写合约及交互部分。</p><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><ol><li>安装<a href="https://nodejs.org/en/download/" target="_blank" rel="noopener">Node</a></li><li>安装 Truffle ：<code>npm install -g truffle</code></li><li>安装<a href="http://truffleframework.com/ganache/" target="_blank" rel="noopener">Ganache</a></li></ol><blockquote><p>Ganache（或Ganache CLI）已经取代了 testrpc。</p></blockquote><h2 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h2><ol><li><p>建立项目目录并进入</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> mkdir pet-shop-tutorial</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="built_in">cd</span> pet-shop-tutorial</span></span><br></pre></td></tr></table></figure></li><li><p>使用truffle unbox 创建项目</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"> &gt;</span><span class="bash"> truffle unbox pet-shop</span></span><br><span class="line"> Downloading...</span><br><span class="line"> Unpacking...</span><br><span class="line"> Setting up...</span><br><span class="line"> Unbox successful. Sweet!</span><br><span class="line"></span><br><span class="line">Commands:</span><br><span class="line"></span><br><span class="line">  Compile:        truffle compile</span><br><span class="line">  Migrate:        truffle migrate</span><br><span class="line">  Test contracts: truffle test</span><br><span class="line">  Run dev server: npm run dev</span><br></pre></td></tr></table></figure></li></ol><p>这一步需要等待一会</p><blockquote><p>也可以使用truffle init 来创建一个全新的项目。</p></blockquote><h2 id="项目目录结构"><a href="#项目目录结构" class="headerlink" title="项目目录结构"></a>项目目录结构</h2><p><code>contracts/</code>  智能合约的文件夹，所有的智能合约文件都放置在这里，里面包含一个重要的合约Migrations.sol（稍后再讲）<br><code>migrations/</code> 用来处理部署（迁移）智能合约 ，迁移是一个额外特别的合约用来保存合约的变化。<br><code>test/</code> 智能合约测试用例文件夹<br><code>truffle.js/</code> 配置文件</p><p>其他代码可以暂时不用管</p><h2 id="编写智能合约"><a href="#编写智能合约" class="headerlink" title="编写智能合约"></a>编写智能合约</h2><p>智能合约承担着分布式应用的后台逻辑和存储。智能合约使用solidity编写，可阅读<br><a href="https://learnblockchain.cn/categories/ethereum/Solidity/">solidity系列文章</a></p><p>在contracts目录下，添加合约文件Adoption.sol<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.17</span>;</span><br><span class="line"></span><br><span class="line">contract Adoption &#123;</span><br><span class="line"></span><br><span class="line">  address[<span class="number">16</span>] public adopters;  <span class="comment">// 保存领养者的地址</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 领养宠物</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">adopt</span>(<span class="params">uint petId</span>) <span class="title">public</span> <span class="title">returns</span> (<span class="params">uint</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">require</span>(petId &gt;= <span class="number">0</span> &amp;&amp; petId &lt;= <span class="number">15</span>);  <span class="comment">// 确保id在数组长度内</span></span><br><span class="line"></span><br><span class="line">    adopters[petId] = msg.sender;        <span class="comment">// 保存调用这地址 </span></span><br><span class="line">    <span class="keyword">return</span> petId;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回领养者</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">getAdopters</span>(<span class="params"></span>) <span class="title">public</span> <span class="title">view</span> <span class="title">returns</span> (<span class="params">address[<span class="number">16</span>]</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> adopters;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="编译部署智能合约"><a href="#编译部署智能合约" class="headerlink" title="编译部署智能合约"></a>编译部署智能合约</h2><p>Truffle集成了一个开发者控制台，可用来生成一个开发链用来测试和部署智能合约。</p><h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><p>Solidity是编译型语言，需要把可读的Solidity代码编译为EVM字节码才能运行。<br>dapp的根目录pet-shop-tutorial下，<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> truffle compile</span></span><br></pre></td></tr></table></figure></p><p>输出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Compiling ./contracts/Adoption.sol...</span><br><span class="line">Writing artifacts to ./build/contracts</span><br></pre></td></tr></table></figure></p><h3 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h3><p>编译之后，就可以部署到区块链上。<br>在migrations文件夹下已经有一个1_initial_migration.js部署脚本，用来部署Migrations.sol合约。<br>Migrations.sol 用来确保不会部署相同的合约。</p><p>现在我们来创建一个自己的部署脚本<code>2_deploy_contracts.js</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var Adoption = artifacts.require(&quot;Adoption&quot;);</span><br><span class="line"></span><br><span class="line">module.exports = function(deployer) &#123;</span><br><span class="line">  deployer.deploy(Adoption);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在执行部署之前，需要确保有一个区块链运行, 可以使用<br><a href="http://truffleframework.com/ganache/" target="_blank" rel="noopener">Ganache</a>来开启一个私链来进行开发测试，默认会在7545端口上运行一个开发链。<br>Ganache 启动之后是这样：<br><img src="https://learnblockchain.cn/images/ganache-initial.png" alt=""></p><p>接下来执行部署命令:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; truffle  migrate</span><br></pre></td></tr></table></figure></p><p>执行后，有一下类似的输出，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Using network &apos;develop&apos;.</span><br><span class="line"></span><br><span class="line">Running migration: 1_initial_migration.js</span><br><span class="line">  Deploying Migrations...</span><br><span class="line">  ... 0x3076b7dac65afc44ec51508bf6f2b6894f833f0f9560ecad2d6d41ed98a4679f</span><br><span class="line">  Migrations: 0x8cdaf0cd259887258bc13a92c0a6da92698644c0</span><br><span class="line">Saving successful migration to network...</span><br><span class="line">  ... 0xd7bc86d31bee32fa3988f1c1eabce403a1b5d570340a3a9cdba53a472ee8c956</span><br><span class="line">Saving artifacts...</span><br><span class="line">Running migration: 2_deploy_contracts.js</span><br><span class="line">  Deploying Adoption...</span><br><span class="line">  ... 0x2c6ab4471c225b5473f2079ee42ca1356007e51d5bb57eb80bfeb406acc35cd4</span><br><span class="line">  Adoption: 0x345ca3e014aaf5dca488057592ee47305d9b3e10</span><br><span class="line">Saving successful migration to network...</span><br><span class="line">  ... 0xf36163615f41ef7ed8f4a8f192149a0bf633fe1a2398ce001bf44c43dc7bdda0</span><br><span class="line">Saving artifacts...</span><br></pre></td></tr></table></figure></p><p>在打开的Ganache里可以看到区块链状态的变化，现在产生了4个区块。<br><img src="https://learnblockchain.cn/images/ganache-migrated.png" alt=""><br>这时说明已经智能合约已经部署好了。</p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>现在我们来测试一下智能合约，测试用例可以用 JavaScript or Solidity来编写，这里使用Solidity。</p><p>在<code>test</code>目录下新建一个<code>TestAdoption.sol</code>，编写测试合约<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.17</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"truffle/Assert.sol"</span>;   <span class="comment">// 引入的断言</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">"truffle/DeployedAddresses.sol"</span>;  <span class="comment">// 用来获取被测试合约的地址</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">"../contracts/Adoption.sol"</span>;      <span class="comment">// 被测试合约</span></span><br><span class="line"></span><br><span class="line">contract TestAdoption &#123;</span><br><span class="line">  Adoption adoption = Adoption(DeployedAddresses.Adoption());</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 领养测试用例</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">testUserCanAdoptPet</span>(<span class="params"></span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">    uint returnedId = adoption.adopt(<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    uint expected = <span class="number">8</span>;</span><br><span class="line">    Assert.equal(returnedId, expected, <span class="string">"Adoption of pet ID 8 should be recorded."</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 宠物所有者测试用例</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">testGetAdopterAddressByPetId</span>(<span class="params"></span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 期望领养者的地址就是本合约地址，因为交易是由测试合约发起交易，</span></span><br><span class="line">    address expected = <span class="keyword">this</span>;</span><br><span class="line">    address adopter = adoption.adopters(<span class="number">8</span>);</span><br><span class="line">    Assert.equal(adopter, expected, <span class="string">"Owner of pet ID 8 should be recorded."</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试所有领养者</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">testGetAdopterAddressByPetIdInArray</span>(<span class="params"></span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 领养者的地址就是本合约地址</span></span><br><span class="line">    address expected = <span class="keyword">this</span>;</span><br><span class="line">    address[<span class="number">16</span>] memory adopters = adoption.getAdopters();</span><br><span class="line">    Assert.equal(adopters[<span class="number">8</span>], expected, <span class="string">"Owner of pet ID 8 should be recorded."</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Assert.sol 及 DeployedAddresses.sol是Truffle框架提供，在test目录下并不提供truffle目录。</p><p>TestAdoption合约中添加adopt的测试用例</p><h3 id="运行测试用例"><a href="#运行测试用例" class="headerlink" title="运行测试用例"></a>运行测试用例</h3><p>在终端中，执行<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">truffle <span class="built_in">test</span></span><br></pre></td></tr></table></figure></p><p>如果测试通过，则终端输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Using network &apos;develop&apos;.</span><br><span class="line"></span><br><span class="line">Compiling ./contracts/Adoption.sol...</span><br><span class="line">Compiling ./test/TestAdoption.sol...</span><br><span class="line">Compiling truffle/Assert.sol...</span><br><span class="line">Compiling truffle/DeployedAddresses.sol...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  TestAdoption</span><br><span class="line">    ✓ testUserCanAdoptPet (62ms)</span><br><span class="line">    ✓ testGetAdopterAddressByPetId (53ms)</span><br><span class="line">    ✓ testGetAdopterAddressByPetIdInArray (73ms)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  3 passing (554ms)</span><br></pre></td></tr></table></figure></p><h2 id="创建用户接口和智能合约交互"><a href="#创建用户接口和智能合约交互" class="headerlink" title="创建用户接口和智能合约交互"></a>创建用户接口和智能合约交互</h2><p>我们已经编写和部署及测试好了我们的合约，接下我们为合约编写UI，让合约真正可以用起来。</p><p>在Truffle Box <code>pet-shop</code>里，已经包含了应用的前端代码，代码在<code>src/</code>文件夹下。</p><p>在编辑器中打开<code>src/js/app.js</code><br>可以看到用来管理整个应用的App对象，init函数加载宠物信息，就初始化<a href="https://github.com/ethereum/web3.js/" target="_blank" rel="noopener">web3</a>.<br>web3是一个实现了与以太坊节点通信的库，我们利用web3来和合约进行交互。</p><h3 id="初始化web3"><a href="#初始化web3" class="headerlink" title="初始化web3"></a>初始化web3</h3><p>接下来，我们来编辑app.js修改initWeb3():<br>删除注释，修改为：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">initWeb3: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Is there an injected web3 instance?</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> web3 !== <span class="string">'undefined'</span>) &#123;</span><br><span class="line">    App.web3Provider = web3.currentProvider;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// If no injected web3 instance is detected, fall back to Ganache</span></span><br><span class="line">    App.web3Provider = <span class="keyword">new</span> Web3.providers.HttpProvider(<span class="string">'http://localhost:7545'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  web3 = <span class="keyword">new</span> Web3(App.web3Provider);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> App.initContract();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>代码中优先使用<a href="https://github.com/ethereum/mist" target="_blank" rel="noopener">Mist</a> 或 <a href="https://metamask.io/" target="_blank" rel="noopener">MetaMask</a>提供的web3实例，如果没有则从本地环境创建一个。</p><h3 id="实例化合约"><a href="#实例化合约" class="headerlink" title="实例化合约"></a>实例化合约</h3><p>使用truffle-contract会帮我们保存合约部署的信息，就不需要我们手动修改合约地址，修改initContract()代码如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">initContract: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 加载Adoption.json，保存了Adoption的ABI（接口说明）信息及部署后的网络(地址)信息，它在编译合约的时候生成ABI，在部署的时候追加网络信息</span></span><br><span class="line">  $.getJSON(<span class="string">'Adoption.json'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 用Adoption.json数据创建一个可交互的TruffleContract合约实例。</span></span><br><span class="line">    <span class="keyword">var</span> AdoptionArtifact = data;</span><br><span class="line">    App.contracts.Adoption = TruffleContract(AdoptionArtifact);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set the provider for our contract</span></span><br><span class="line">    App.contracts.Adoption.setProvider(App.web3Provider);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Use our contract to retrieve and mark the adopted pets</span></span><br><span class="line">    <span class="keyword">return</span> App.markAdopted();</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> App.bindEvents();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="处理领养"><a href="#处理领养" class="headerlink" title="处理领养"></a>处理领养</h3><p>修改markAdopted()代码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">markAdopted: <span class="function"><span class="keyword">function</span>(<span class="params">adopters, account</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> adoptionInstance;</span><br><span class="line"></span><br><span class="line">  App.contracts.Adoption.deployed().then(<span class="function"><span class="keyword">function</span>(<span class="params">instance</span>) </span>&#123;</span><br><span class="line">    adoptionInstance = instance;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用合约的getAdopters(), 用call读取信息不用消耗gas</span></span><br><span class="line">    <span class="keyword">return</span> adoptionInstance.getAdopters.call();</span><br><span class="line">  &#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">adopters</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; adopters.length; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (adopters[i] !== <span class="string">'0x0000000000000000000000000000000000000000'</span>) &#123;</span><br><span class="line">        $(<span class="string">'.panel-pet'</span>).eq(i).find(<span class="string">'button'</span>).text(<span class="string">'Success'</span>).attr(<span class="string">'disabled'</span>, <span class="literal">true</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err.message);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>修改handleAdopt()代码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">handleAdopt: <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  event.preventDefault();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> petId = <span class="built_in">parseInt</span>($(event.target).data(<span class="string">'id'</span>));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> adoptionInstance;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取用户账号</span></span><br><span class="line">  web3.eth.getAccounts(<span class="function"><span class="keyword">function</span>(<span class="params">error, accounts</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (error) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(error);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">var</span> account = accounts[<span class="number">0</span>];</span><br><span class="line">  </span><br><span class="line">    App.contracts.Adoption.deployed().then(<span class="function"><span class="keyword">function</span>(<span class="params">instance</span>) </span>&#123;</span><br><span class="line">      adoptionInstance = instance;</span><br><span class="line">  </span><br><span class="line">      <span class="comment">// 发送交易领养宠物</span></span><br><span class="line">      <span class="keyword">return</span> adoptionInstance.adopt(petId, &#123;<span class="attr">from</span>: account&#125;);</span><br><span class="line">    &#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">result</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> App.markAdopted();</span><br><span class="line">    &#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(err.message);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="在浏览器中运行"><a href="#在浏览器中运行" class="headerlink" title="在浏览器中运行"></a>在浏览器中运行</h2><h3 id="安装-MetaMask"><a href="#安装-MetaMask" class="headerlink" title="安装 MetaMask"></a>安装 MetaMask</h3><p>MetaMask 是一款插件形式的以太坊轻客户端，开发过程中使用MetaMask和我们的dapp进行交互是个很好的选择，通过此<a href="https://metamask.io/" target="_blank" rel="noopener">链接</a>安装，安装完成后，浏览器工具条会显示一个小狐狸图标。</p><h3 id="配置钱包"><a href="#配置钱包" class="headerlink" title="配置钱包"></a>配置钱包</h3><p>在接受隐私说明后，会出现页面如下：<br><img src="https://learnblockchain.cn/images/metamask-initial.png" alt=""></p><p>这里我们通过还原一个Ganache为我们创建好的钱包，作为我们的开发测试钱包。点击页面的<strong> Import Existing DEN</strong>，输入Ganache显示的助记词。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">candy maple cake sugar pudding cream honey rich smooth crumble sweet treat</span><br></pre></td></tr></table></figure></p><p>然后自己想要的密码，点击OK。<br>如图：<br><img src="https://learnblockchain.cn/images/metamask-seed.png" alt=""></p><h3 id="连接开发区块链网络"><a href="#连接开发区块链网络" class="headerlink" title="连接开发区块链网络"></a>连接开发区块链网络</h3><p>默认连接的是以太坊主网（左上角显示），选择<strong>Custom RPC</strong>，添加一个网络：<strong><a href="http://127.0.0.1:7545" target="_blank" rel="noopener">http://127.0.0.1:7545</a></strong>，点返回后，显示如下：<br><img src="/images/metamask-account1.png" alt=""><br>这是左上角显示为<strong>Private Network</strong>，账号是Ganache中默认的第一个账号。</p><p>至此MetaMask的安装，配置已经完成。</p><h3 id="安装和配置lite-server"><a href="#安装和配置lite-server" class="headerlink" title="安装和配置lite-server"></a>安装和配置lite-server</h3><p>接下来需要本地的web 服务器提供服务的访问， Truffle Box <strong>pet-shop</strong>里提供了一个<strong>lite-server</strong>可以直接使用，我们看看它是如何工作的。<br><strong>bs-config.json</strong>指示了lite-server的工作目录。<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"server"</span>: &#123;</span><br><span class="line">    <span class="attr">"baseDir"</span>: [<span class="string">"./src"</span>, <span class="string">"./build/contracts"</span>]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>./src 是网站文件目录<br>./build/contracts 是合约输出目录</p><p>以此同时，在package.json文件的scripts中添加了dev命令：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">"scripts": &#123;</span><br><span class="line">  "dev": "lite-server",</span><br><span class="line">  "test": "echo \"Error: no test specified\" &amp;&amp; exit 1"</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></p><p>当运行npm run dev的时候，就会启动lite-server</p><h3 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; npm run dev</span><br></pre></td></tr></table></figure><p>会自动打开浏览器显示我们的dapp，如本文的第一张图。<br>现在领养一直宠物看看，当我们点击<strong>Adopt</strong>时，MetaMask会提示我们交易的确认，如图：</p><p><img src="https://learnblockchain.cn/images/metamask-transactionconfirm.png" alt=""></p><p>点击Submit确认后，就可以看到成功领养了这次宠物。</p><p>在MetaMask中，也可以看到交易的清单：<br><img src="https://learnblockchain.cn/images/metamask-transactionsuccess.png" alt=""></p><p>好了，恭喜你，即将成为一名去中心化式应用开发者的你已经成为迈出了坚实的一步。<br>如果学习中遇到问题，欢迎来我的<strong><a href="https://t.xiaomiquan.com/RfAu7uj" target="_blank" rel="noopener">知识星球</a></strong>交流。</p><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul><li><a href="http://truffleframework.com/tutorials/pet-shop" target="_blank" rel="noopener">Truffle手册</a></li></ul><p><a href="https://learnblockchain.cn/">深入浅出区块链</a> - 系统学习区块链，打造最好的区块链技术博客。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天我们来编写一个完整的去中心化（区块链）应用（Dapps）, 本文可以和&lt;a href=&quot;https://learnblockchain.cn/2017/11/24/init-env/&quot;&gt;编写智能合约&lt;/a&gt;结合起来看。&lt;/p&gt;
    
    </summary>
    
      <category term="以太坊" scheme="https://learnblockchain.cn/categories/ethereum/"/>
    
      <category term="Dapp" scheme="https://learnblockchain.cn/categories/ethereum/Dapp/"/>
    
    
      <category term="Dapp入门" scheme="https://learnblockchain.cn/tags/Dapp%E5%85%A5%E9%97%A8/"/>
    
      <category term="以太坊概念" scheme="https://learnblockchain.cn/tags/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%A6%82%E5%BF%B5/"/>
    
  </entry>
  
  <entry>
    <title>区块链技术学习指引</title>
    <link href="https://learnblockchain.cn/2018/01/11/guide/"/>
    <id>https://learnblockchain.cn/2018/01/11/guide/</id>
    <published>2018-01-11T07:03:36.000Z</published>
    <updated>2018-03-26T01:17:01.036Z</updated>
    
    <content type="html"><![CDATA[<p>本文为博客文章索引，小白必看。有新文章时会更新本文，建议大家加入收藏夹中，如果你觉得本站不错，欢迎你转发给朋友。</p><a id="more"></a><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>给迷失在如何学习区块链技术的同学一个指引，区块链技术是随比特币诞生，因此要搞明白区块链技术，应该先了解下比特币。<br>但区块链技术不单应用于比特币，还有非常多的现实应用场景，想做区块链应用开发，可进一步阅读以太坊系列。</p><h2 id="比特币"><a href="#比特币" class="headerlink" title="比特币"></a>比特币</h2><p>如果你是还不知比特币是什么，那就看看<a href="https://learnblockchain.cn/2017/10/23/whatisbitcoin/">比特币是什么</a></p><h3 id="基础入门"><a href="#基础入门" class="headerlink" title="基础入门"></a>基础入门</h3><p>接下来可以通过下面这几篇文章了解比特币大概的运行原理：</p><ul><li><a href="https://learnblockchain.cn/2017/10/25/whatbc/">区块链记账原理</a><br> 通过这篇可以了解到区块链是一个怎样的结构</li><li><a href="https://learnblockchain.cn/2017/11/02/bitcoin-own/">比特币所有权及隐私问题</a><br> 通过这篇可以了解到地址私钥 非对称加密应用 等概念</li><li><a href="https://learnblockchain.cn/2017/11/04/bitcoin-pow/">比特币如何挖矿</a><br> 通过这篇了解工作量证明</li><li><a href="https://learnblockchain.cn/2017/12/07/bitcoin-sonsensus/">比特币如何达成共识 - 最长链的选择</a><br> 通过这篇可以了解共识机制。<h3 id="补充阅读"><a href="#补充阅读" class="headerlink" title="补充阅读"></a>补充阅读</h3></li><li><a href="https://learnblockchain.cn/2018/02/05/bitcoin-byzantine/">什么是拜占庭将军问题</a></li></ul><h3 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h3><p>在基础入门之后，可以进一步阅读以下几篇，理解分布式网络，交易验证。</p><ul><li><a href="https://learnblockchain.cn/2017/11/07/bitcoin-p2p/">分析比特币网络：一种去中心化、点对点的网络架构</a></li><li><a href="https://learnblockchain.cn/2017/11/10/bitcoin-script/">比特币区块结构 Merkle 树及简单支付验证分析</a></li><li><a href="https://xiaozhuanlan.com/topic/1402935768" target="_blank" rel="noopener">比特币脚本及交易分析 - 智能合约雏形</a></li></ul><p>看完上面这些，区块链应该理解差不多了，就可以尝试实现一个简单的区块链了。参考这篇<a href="https://learnblockchain.cn/2017/10/27/build_blockchain_by_python/">用Python从零开始创建区块链</a>。</p><h2 id="以太坊"><a href="#以太坊" class="headerlink" title="以太坊"></a>以太坊</h2><p>一个技术要落地还得靠应用， 以太坊就这样一个建立在区块链技术之上，去中心化的应用平台。可以阅读几下几篇，这部分以开发为主，需要大家多发时间实践。</p><ul><li><a href="https://learnblockchain.cn/2017/11/20/whatiseth/">以太坊开发入门</a></li><li><a href="https://learnblockchain.cn/2017/11/24/init-env/">智能合约开发环境搭建及Hello World合约</a></li><li><a href="https://learnblockchain.cn/2017/11/29/geth_cmd_options">以太坊客户端Geth命令用法-参数详解</a></li><li><a href="https://learnblockchain.cn/2017/12/01/geth_cmd_short/">Geth控制台使用实战及Web3.js使用</a></li><li><a href="https://learnblockchain.cn/2018/03/18/create_private_blockchain/">如何搭建以太坊私有链</a></li></ul><h3 id="智能合约及应用开发"><a href="#智能合约及应用开发" class="headerlink" title="智能合约及应用开发"></a>智能合约及应用开发</h3><ul><li><a href="https://learnblockchain.cn/2018/01/12/first-dapp/">一步步教你开发、部署第一个Dapp应用</a></li><li><a href="https://learnblockchain.cn/2018/01/12/create_token/">一步步教你创建自己的数字货币（代币）进行ICO</a></li><li><a href="https://learnblockchain.cn/2018/01/27/create_token2/">实现一个可管理、增发、兑换、冻结等高级功能的代币</a></li><li><a href="https://learnblockchain.cn/2018/02/28/ico-crowdsale/">如何通过以太坊智能合约来进行众筹（ICO）</a></li><li><a href="https://learnblockchain.cn/2018/03/23/token-erc721/">剖析非同质化代币ERC721–全面解析ERC721标准</a></li></ul><h3 id="Solidity语言教程"><a href="#Solidity语言教程" class="headerlink" title="Solidity语言教程"></a>Solidity语言教程</h3><p>Solidity语言是开发智能合约最广泛的语言，本专栏应该是国内最深度介绍Solidity的文章了。</p><ul><li><a href="https://learnblockchain.cn/2017/12/05/solidity1/">Solidity 教程系列1 - 类型介绍</a></li><li><a href="https://learnblockchain.cn/2017/12/12/solidity2/">Solidity 教程系列2 - 地址类型介绍</a></li><li><a href="https://learnblockchain.cn/2017/12/12/solidity_func/">Solidity 教程系列3 - 函数类型介绍</a></li><li><a href="https://learnblockchain.cn/2017/12/21/solidity_reftype_datalocation/">Solidity 教程系列4 - 数据存储位置分析</a></li><li><a href="https://learnblockchain.cn/2017/12/21/solidity-arrays/">Solidity 教程系列5 - 数组介绍</a></li><li><a href="https://learnblockchain.cn/2017/12/27/solidity-structs/">Solidity 教程系列6 - 结构体与映射</a></li><li><a href="https://learnblockchain.cn/2018/02/02/solidity-unit/">Solidity 教程系列7 - 以太单位及时间单位</a></li><li><a href="https://learnblockchain.cn/2018/03/14/solidity-api/">Solidity 教程系列8 - Solidity API</a></li></ul><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>知识星球<a href="https://t.xiaomiquan.com/RfAu7uj" target="_blank" rel="noopener">《深入浅出区块链》</a>及微信技术交流群, 主要用来提供一个学习的问答及交流平台，问答交流内容不限于博客文章。<br>目前定价149，有需要加入的同学请加微信：xlbxiong</p><p>温馨提示：微信不提供免费技术解答服务，感谢理解。</p><p><a href="https://learnblockchain.cn/">深入浅出区块链</a> - 系统学习区块链，打造最好的区块链技术博客。</p><h3 id="以下为广告"><a href="#以下为广告" class="headerlink" title="以下为广告"></a>以下为广告</h3><p>我和朋友一起创建了登链科技，是一家从事区块链技术服务与咨询的公司。旨在帮助企业更好的拥抱区块链。<br>我们提供的服务包括（不限于）：</p><ol><li>为游戏公司提供基于区块链的道具、角色等；</li><li>为公司提供基于区块链的股权激励方案；</li><li>为数字产品版权登记、交易平台；</li><li>各种公开透明场景下的服务，如：网络彩票发行、投票、众筹等等；</li><li>区块链技术培训（企业内训）与技术咨询服务。</li></ol><p>所有的服务均可以提供完整的解决方案：如提供面向用户的官方网站、苹果及安卓APP、微信公众号、小程序和企业内部使用的管理后台。<br>业务咨询，请联系：xlb@niuwasoft.com</p><p>另外，我们正在寻找那些热爱技术、愿意迎接挑战的小伙伴（含实习生和正式员工）。<br>我们会提供市场化的薪资待遇和远高于普通公司的成长机会（入职员工由我亲自带领，并且经常有技术培训）。</p><p>如果你对我们感兴趣，欢迎提交简历（千万别忘改贴上你的github地址哦）至xlb@niuwasoft.com。目前所有职位均位于百岛之城珠海。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文为博客文章索引，小白必看。有新文章时会更新本文，建议大家加入收藏夹中，如果你觉得本站不错，欢迎你转发给朋友。&lt;/p&gt;
    
    </summary>
    
      <category term="目录" scheme="https://learnblockchain.cn/categories/%E7%9B%AE%E5%BD%95/"/>
    
    
      <category term="如何学习" scheme="https://learnblockchain.cn/tags/%E5%A6%82%E4%BD%95%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="目录" scheme="https://learnblockchain.cn/tags/%E7%9B%AE%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>智能合约语言 Solidity 教程系列6 - 结构体与映射</title>
    <link href="https://learnblockchain.cn/2017/12/27/solidity-structs/"/>
    <id>https://learnblockchain.cn/2017/12/27/solidity-structs/</id>
    <published>2017-12-27T03:55:26.000Z</published>
    <updated>2018-03-18T13:55:32.194Z</updated>
    
    <content type="html"><![CDATA[<p>Solidity 教程系列第6篇 - Solidity 结构体与映射。<br>Solidity 系列完整的文章列表请查看<a href="https://learnblockchain.cn/categories/ethereum/Solidity/">分类-Solidity</a>。</p><a id="more"></a><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>Solidity 是以太坊智能合约编程语言，阅读本文前，你应该对以太坊、智能合约有所了解，<br>如果你还不了解，建议你先看<a href="https://learnblockchain.cn/2017/11/20/whatiseth/">以太坊是什么</a></p><p>本系列文章一部分是参考Solidity官方文档（当前最新版本：0.4.20）进行翻译，另一部分是Solidity深入分析，这部分请订阅<a href="https://xiaozhuanlan.com/blockchaincore" target="_blank" rel="noopener">区块链技术专栏</a>阅读。</p><h2 id="结构体-Structs"><a href="#结构体-Structs" class="headerlink" title="结构体(Structs)"></a>结构体(Structs)</h2><p>Solidity提供<strong>struct</strong>来定义自定义类型，自定义的类型是引用类型。<br>我们看看下面的例子：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.11</span>;</span><br><span class="line"></span><br><span class="line">contract CrowdFunding &#123;</span><br><span class="line">    <span class="comment">// 定义一个包含两个成员的新类型</span></span><br><span class="line">    struct Funder &#123;</span><br><span class="line">        address addr;</span><br><span class="line">        uint amount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    struct Campaign &#123;</span><br><span class="line">        address beneficiary;</span><br><span class="line">        uint fundingGoal;</span><br><span class="line">        uint numFunders;</span><br><span class="line">        uint amount;</span><br><span class="line">        mapping (<span class="function"><span class="params">uint</span> =&gt;</span> Funder) funders;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    uint numCampaigns;</span><br><span class="line">    mapping (<span class="function"><span class="params">uint</span> =&gt;</span> Campaign) campaigns;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">newCampaign</span>(<span class="params">address beneficiary, uint goal</span>) <span class="title">public</span> <span class="title">returns</span> (<span class="params">uint campaignID</span>) </span>&#123;</span><br><span class="line">        campaignID = numCampaigns++; <span class="comment">// campaignID 作为一个变量返回</span></span><br><span class="line">        <span class="comment">// 创建一个结构体实例，存储在storage ，放入mapping里</span></span><br><span class="line">        campaigns[campaignID] = Campaign(beneficiary, goal, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">contribute</span>(<span class="params">uint campaignID</span>) <span class="title">public</span> <span class="title">payable</span> </span>&#123;</span><br><span class="line">        Campaign storage c = campaigns[campaignID];</span><br><span class="line">        <span class="comment">// 用mapping对应项创建一个结构体引用</span></span><br><span class="line">        <span class="comment">// 也可以用 Funder(msg.sender, msg.value) 来初始化.</span></span><br><span class="line">        c.funders[c.numFunders++] = Funder(&#123;<span class="attr">addr</span>: msg.sender, <span class="attr">amount</span>: msg.value&#125;);</span><br><span class="line">        c.amount += msg.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">checkGoalReached</span>(<span class="params">uint campaignID</span>) <span class="title">public</span> <span class="title">returns</span> (<span class="params">bool reached</span>) </span>&#123;</span><br><span class="line">        Campaign storage c = campaigns[campaignID];</span><br><span class="line">        <span class="keyword">if</span> (c.amount &lt; c.fundingGoal)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        uint amount = c.amount;</span><br><span class="line">        c.amount = <span class="number">0</span>;</span><br><span class="line">        c.beneficiary.transfer(amount);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面是一个简化版的众筹合约，但它可以让我们理解<strong>structs</strong>的基础概念，<strong>struct</strong>可以用于映射和数组中作为元素。其本身也可以包含映射和数组等类型。</p><p>不能声明一个struct同时将自身struct作为成员，这个限制是基于结构体的大小必须是有限的。<br>但<strong>struct</strong>可以作为<strong>mapping</strong>的值类型成员。</p><p>注意在函数中，将一个<strong>struct</strong>赋值给一个局部变量（默认是storage类型），实际是拷贝的引用，所以修改局部变量值的同时，会影响到原变量。</p><p>当然，也可以直接通过访问成员修改值，而不用一定赋值给一个局部变量，如campaigns[campaignID].amount = 0</p><h2 id="映射-Mappings"><a href="#映射-Mappings" class="headerlink" title="映射(Mappings)"></a>映射(Mappings)</h2><p>映射类型，一种键值对的映射关系存储结构。定义方式为mapping(_KeyType =&gt; _KeyValue)。键类型允许除映射、变长数组、合约、枚举、结构体外的几乎所有类型（）。值类型没有任何限制，可以为任何类型包括映射类型。</p><p><strong>映射</strong>可以被视作为一个哈希表，所有可能的键会被虚拟化的创建，映射到一个类型的默认值（二进制的全零表示）。在映射表中，并不存储键的数据，仅仅存储它的keccak256哈希值，这个哈希值在查找值时需要用到。<br>正因为此，<strong>映射</strong>是没有长度的，也没有键集合或值集合的概念。</p><p><strong>映射类型</strong>，仅能用来作为状态变量，或在内部函数中作为<strong>storage</strong>类型的引用。</p><p>可以通过将映射标记为public，来让Solidity创建一个访问器。通过提供一个键值做为参数来访问它，将返回对应的值。<br>映射的值类型也可以是映射，使用访问器访问时，要提供这个映射值所对应的键，不断重复这个过程。<br>来看一个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract MappingExample &#123;</span><br><span class="line">    mapping(<span class="function"><span class="params">address</span> =&gt;</span> uint) public balances;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">update</span>(<span class="params">uint newBalance</span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">        balances[msg.sender] = newBalance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract MappingUser &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) <span class="title">public</span> <span class="title">returns</span> (<span class="params">uint</span>) </span>&#123;</span><br><span class="line">        MappingExample m = <span class="keyword">new</span> MappingExample();</span><br><span class="line">        m.update(<span class="number">100</span>);</span><br><span class="line">        <span class="keyword">return</span> m.balances(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：<br>映射并未提供迭代输出的方法，可以自行实现一个这样的数据结构。参考<a href="https://github.com/ethereum/dapp-bin/blob/master/library/iterable_mapping.sol" target="_blank" rel="noopener">iterable mapping</a></p><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="https://solidity.readthedocs.io/en/develop/types.html#mappings" target="_blank" rel="noopener">Solidity官方文档</a></p><p><a href="https://learnblockchain.cn/">深入浅出区块链</a> - 系统学习区块链，打造最好的区块链技术博客。<br>我的<strong><a href="https://t.xiaomiquan.com/RfAu7uj" target="_blank" rel="noopener">知识星球</a></strong>为各位解答区块链技术问题，欢迎加入讨论。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Solidity 教程系列第6篇 - Solidity 结构体与映射。&lt;br&gt;Solidity 系列完整的文章列表请查看&lt;a href=&quot;https://learnblockchain.cn/categories/ethereum/Solidity/&quot;&gt;分类-Solidity&lt;/a&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="以太坊" scheme="https://learnblockchain.cn/categories/ethereum/"/>
    
      <category term="Solidity" scheme="https://learnblockchain.cn/categories/ethereum/Solidity/"/>
    
    
      <category term="Solidity手册" scheme="https://learnblockchain.cn/tags/Solidity%E6%89%8B%E5%86%8C/"/>
    
  </entry>
  
  <entry>
    <title>智能合约语言 Solidity 教程系列5 - 数组介绍</title>
    <link href="https://learnblockchain.cn/2017/12/21/solidity-arrays/"/>
    <id>https://learnblockchain.cn/2017/12/21/solidity-arrays/</id>
    <published>2017-12-21T03:55:18.000Z</published>
    <updated>2018-03-18T13:55:32.194Z</updated>
    
    <content type="html"><![CDATA[<p>Solidity 教程系列第5篇 - Solidity 数组介绍。<br>Solidity 系列完整的文章列表请查看<a href="https://learnblockchain.cn/categories/ethereum/Solidity/">分类-Solidity</a>。</p><a id="more"></a><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>Solidity 是以太坊智能合约编程语言，阅读本文前，你应该对以太坊、智能合约有所了解，<br>如果你还不了解，建议你先看<a href="https://learnblockchain.cn/2017/11/20/whatiseth/">以太坊是什么</a></p><p>本文前半部分是参考Solidity官方文档（当前最新版本：0.4.20）进行翻译，后半部分对官方文档中没有提供代码的知识点补充代码说明（订阅<a href="https://xiaozhuanlan.com/blockchaincore" target="_blank" rel="noopener">专栏</a>阅读）。</p><h2 id="数组（Arrays）"><a href="#数组（Arrays）" class="headerlink" title="数组（Arrays）"></a>数组（Arrays）</h2><p>数组可以声明时指定长度，也可以是动态变长。对storage存储的数组来说，元素类型可以是任意的，类型可以是数组，映射类型，结构体等。但对于memory的数组来说。如果作为public函数的参数，它不能是映射类型的数组，只能是支持<a href="https://github.com/ethereum/wiki/wiki/Ethereum-Contract-ABI#types" target="_blank" rel="noopener">ABI的类型</a>。</p><p>一个元素类型为T，固定长度为k的数组，可以声明为<strong>T[k]</strong>，而一个动态大小（变长）的数组则声明为<strong>T[]</strong>。<br>还可以声明一个多维数组，如声明一个类型为uint的数组长度为5的变长数组（5个元素都是变长数组），可以声明为uint[][5]。（注意，相比非区块链语言，多维数组的长度声明是反的。）</p><p>要访问第三个动态数组的第二个元素，使用x[2][1]。数组的序号是从0开始的，序号顺序与定义相反。</p><p><strong>bytes</strong>和<strong>string</strong>是一种特殊的数组。<strong>bytes</strong>类似<strong>byte[]</strong>，但在外部函数作为参数调用中，<strong>bytes</strong>会进行压缩打包。<strong>string</strong>类似<strong>bytes</strong>，但不提供长度和按序号的访问方式（目前）。<br>所以应该尽量使用<strong>bytes</strong>而不是<strong>byte[]</strong>。</p><blockquote><p>可以将字符串s通过bytes(s)转为一个bytes，可以通过<strong>bytes(s).length</strong>获取长度，<strong>bytes(s)[n]</strong>获取对应的UTF-8编码。通过下标访问获取到的不是对应字符，而是UTF-8编码，比如中文编码是多字节，变长的，所以下标访问到的只是其中的一个编码。<br>类型为数组的状态变量，可以标记为<strong>public</strong>，从而让Solidity创建一个访问器，如果要访问数组的某个元素，指定数字下标就好了。（稍后代码事例）</p></blockquote><h2 id="创建内存数组"><a href="#创建内存数组" class="headerlink" title="创建内存数组"></a>创建内存数组</h2><p>可使用new关键字创建一个memory的数组。与stroage数组不同的是，你不能通过.length的长度来修改数组大小属性。我们来看看下面的例子：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.16</span>;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">uint len</span>) <span class="title">public</span> <span class="title">pure</span> </span>&#123;</span><br><span class="line">        uint[] memory a = <span class="keyword">new</span> uint[](<span class="number">7</span>);</span><br><span class="line">                </span><br><span class="line">        <span class="comment">//a.length = 100;  // 错误</span></span><br><span class="line">        bytes memory b = <span class="keyword">new</span> bytes(len);</span><br><span class="line">        <span class="comment">// Here we have a.length == 7 and b.length == len</span></span><br><span class="line">        a[<span class="number">6</span>] = <span class="number">8</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="数组常量及内联数组"><a href="#数组常量及内联数组" class="headerlink" title="数组常量及内联数组"></a>数组常量及内联数组</h2><p>数组常量，是一个数组表达式（还没有赋值到变量）。下面是一个简单的例子：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.16</span>;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) <span class="title">public</span> <span class="title">pure</span> </span>&#123;</span><br><span class="line">        g([uint(<span class="number">1</span>), <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">g</span>(<span class="params">uint[<span class="number">3</span>] _data</span>) <span class="title">public</span> <span class="title">pure</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>通过数组常量，创建的数组是memory的，同时还是定长的。元素类型则是使用刚好能存储的元素的能用类型，比如[1, 2, 3]，只需要uint8即可存储，它的类型是<strong>uint8[3] memory</strong>。</p><p>由于g()方法的参数需要的是uint（默认的uint表示的其实是uint256），所以需要对第一个元素进行类型转换，使用uint(1)来进行这个转换。</p><p>还需注意的一点是，定长数组，不能与变长数组相互赋值，我们来看下面的代码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  无法编译</span></span><br><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">        <span class="comment">// The next line creates a type error because uint[3] memory</span></span><br><span class="line">        <span class="comment">// cannot be converted to uint[] memory.</span></span><br><span class="line">        uint[] x = [uint(<span class="number">1</span>), <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>已经计划在未来移除这样的限制。当前因为ABI传递数组还有些问题。</p><h2 id="成员"><a href="#成员" class="headerlink" title="成员"></a>成员</h2><h3 id="length属性"><a href="#length属性" class="headerlink" title="length属性"></a>length属性</h3><p>数组有一个.length属性，表示当前的数组长度。storage的变长数组，可以通过给.length赋值调整数组长度。memory的变长数组不支持。<br>不能通过访问超出当前数组的长度的方式，来自动实现改变数组长度。memory数组虽然可以通过参数，灵活指定大小，但一旦创建，大小不可调整。</p><h3 id="push方法"><a href="#push方法" class="headerlink" title="push方法"></a>push方法</h3><p>storage的变长数组和bytes都有一个<strong>push</strong>方法（string没有），用于附加新元素到数据末端，返回值为新的长度。</p><h2 id="限制情况"><a href="#限制情况" class="headerlink" title="限制情况"></a>限制情况</h2><p>当前在external函数中，不能使用多维数组。</p><p>另外，基于EVM的限制，不能通过外部函数返回动态的内容。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">contract C &#123;</span><br><span class="line">     <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) <span class="title">returns</span> (<span class="params">uint[]</span>) </span>&#123; ... &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure></p><p>在这个的例子中，如果通过web.js调用能返回数据，但从Solidity中调用不能返回数据。一种绕过这个问题的办法是使用一个非常大的静态数组。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.16</span>;</span><br><span class="line"></span><br><span class="line">contract ArrayContract &#123;</span><br><span class="line">    uint[<span class="number">2</span>**<span class="number">20</span>] m_aLotOfIntegers;</span><br><span class="line">    <span class="comment">// 这里不是两个动态数组的数组，而是一个动态数组里，每个元素是长度为二的数组。</span></span><br><span class="line">    bool[<span class="number">2</span>][] m_pairsOfFlags;</span><br><span class="line">    <span class="comment">// newPairs 存在 memory里，因为是函数参数</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">setAllFlagPairs</span>(<span class="params">bool[<span class="number">2</span>][] newPairs</span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">        m_pairsOfFlags = newPairs;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">setFlagPair</span>(<span class="params">uint index, bool flagA, bool flagB</span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 访问不存在的index会抛出异常</span></span><br><span class="line">        m_pairsOfFlags[index][<span class="number">0</span>] = flagA;</span><br><span class="line">        m_pairsOfFlags[index][<span class="number">1</span>] = flagB;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">changeFlagArraySize</span>(<span class="params">uint newSize</span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果新size更小, 移除的元素会被销毁</span></span><br><span class="line">        m_pairsOfFlags.length = newSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">clear</span>(<span class="params"></span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 销毁</span></span><br><span class="line">        <span class="keyword">delete</span> m_pairsOfFlags;</span><br><span class="line">        <span class="keyword">delete</span> m_aLotOfIntegers;</span><br><span class="line">        <span class="comment">// 同销毁一样的效果</span></span><br><span class="line">        m_pairsOfFlags.length = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bytes m_byteData;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">byteArrays</span>(<span class="params">bytes data</span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">        <span class="comment">// byte arrays ("bytes") are different as they are stored without padding,</span></span><br><span class="line">        <span class="comment">// but can be treated identical to "uint8[]"</span></span><br><span class="line">        m_byteData = data;</span><br><span class="line">        m_byteData.length += <span class="number">7</span>;</span><br><span class="line">        m_byteData[<span class="number">3</span>] = byte(<span class="number">8</span>);</span><br><span class="line">        <span class="keyword">delete</span> m_byteData[<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">addFlag</span>(<span class="params">bool[<span class="number">2</span>] flag</span>) <span class="title">public</span> <span class="title">returns</span> (<span class="params">uint</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_pairsOfFlags.push(flag);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">createMemoryArray</span>(<span class="params">uint size</span>) <span class="title">public</span> <span class="title">pure</span> <span class="title">returns</span> (<span class="params">bytes</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// Dynamic memory arrays are created using `new`:</span></span><br><span class="line">        uint[<span class="number">2</span>][] memory arrayOfPairs = <span class="keyword">new</span> uint[<span class="number">2</span>][](size);</span><br><span class="line">        <span class="comment">// Create a dynamic byte array:</span></span><br><span class="line">        bytes memory b = <span class="keyword">new</span> bytes(<span class="number">200</span>);</span><br><span class="line">        <span class="keyword">for</span> (uint i = <span class="number">0</span>; i &lt; b.length; i++)</span><br><span class="line">            b[i] = byte(i);</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="补充事例说明"><a href="#补充事例说明" class="headerlink" title="补充事例说明"></a>补充事例说明</h2><p>事例代码及讲解，请订阅<a href="https://xiaozhuanlan.com/blockchaincore" target="_blank" rel="noopener">区块链技术</a>查看。</p><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="https://solidity.readthedocs.io/en/develop/types.html#arrays" target="_blank" rel="noopener">Solidity官方文档-数组</a></p><p><a href="https://learnblockchain.cn/">深入浅出区块链</a> - 系统学习区块链，打造最好的区块链技术博客。<br>我的<strong><a href="https://t.xiaomiquan.com/RfAu7uj" target="_blank" rel="noopener">知识星球</a></strong>为各位解答区块链技术问题，欢迎加入讨论。</p><!---<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    </span><br><span class="line">    uint [] public u = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];    <span class="comment">// 生成访问器</span></span><br><span class="line">    string  s = <span class="string">"abcdefg"</span>;</span><br><span class="line"></span><br><span class="line">    uint[] c;  <span class="comment">//storage</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">g</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        c = <span class="keyword">new</span> uint[](<span class="number">7</span>);</span><br><span class="line">        c.length = <span class="number">10</span>;   <span class="comment">//可以修改storage的数组</span></span><br><span class="line">        c[<span class="number">9</span>] = <span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">h</span>(<span class="params"></span>) <span class="title">public</span>  <span class="title">returns</span> (<span class="params">uint</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> bytes(s).length;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) <span class="title">public</span>  <span class="title">returns</span> (<span class="params">byte</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> bytes(s)[<span class="number">1</span>];     <span class="comment">// 转为数组访问</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打开<a href="https://ethereum.github.io/browser-solidity">Remix - Solidity IDE</a>,帖入代码，依次创建合约，如图：<br><img src="/images/testarray.jpg" alt=""></p><p>创建合约后，可以看到public的数组u，生成了对应访问器，可直接访问。</p><p>–&gt;</p>-->]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Solidity 教程系列第5篇 - Solidity 数组介绍。&lt;br&gt;Solidity 系列完整的文章列表请查看&lt;a href=&quot;https://learnblockchain.cn/categories/ethereum/Solidity/&quot;&gt;分类-Solidity&lt;/a&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="以太坊" scheme="https://learnblockchain.cn/categories/ethereum/"/>
    
      <category term="Solidity" scheme="https://learnblockchain.cn/categories/ethereum/Solidity/"/>
    
    
      <category term="Solidity手册" scheme="https://learnblockchain.cn/tags/Solidity%E6%89%8B%E5%86%8C/"/>
    
  </entry>
  
  <entry>
    <title>智能合约语言 Solidity 教程系列4 - 数据存储位置分析</title>
    <link href="https://learnblockchain.cn/2017/12/21/solidity_reftype_datalocation/"/>
    <id>https://learnblockchain.cn/2017/12/21/solidity_reftype_datalocation/</id>
    <published>2017-12-21T03:51:02.000Z</published>
    <updated>2018-03-18T13:55:32.198Z</updated>
    
    <content type="html"><![CDATA[<p>Solidity教程系列第4篇 - Solidity数据位置分析。<br>Solidity 系列完整的文章列表请查看<a href="https://learnblockchain.cn/categories/ethereum/Solidity/">分类-Solidity</a>。<br><a id="more"></a></p><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>Solidity 是以太坊智能合约编程语言，阅读本文前，你应该对以太坊、智能合约有所了解，<br>如果你还不了解，建议你先看<a href="https://learnblockchain.cn/2017/11/20/whatiseth/">以太坊是什么</a></p><p>这部分的内容官方英文文档讲的不是很透，因此我在参考Solidity官方文档（当前最新版本：0.4.20）的同时加入了深入分析部分，欢迎订阅<a href="https://xiaozhuanlan.com/blockchaincore" target="_blank" rel="noopener">专栏</a>。</p><h2 id="数据位置-Data-location"><a href="#数据位置-Data-location" class="headerlink" title="数据位置(Data location)"></a>数据位置(Data location)</h2><p>在系列第一篇，我们提到 Solidity 类型分为两类：<br><strong>值类型(Value Type)</strong> 及 <strong>引用类型(Reference Types)</strong>，<br>前面我们已经介绍完了值类型，接下来会介绍引用类型。</p><p>引用类型是一个复杂类型，占用的空间通常超过256位， 拷贝时开销很大，因此我们需要考虑将它们存储在什么位置，是<strong>memory</strong>（内存中，数据不是永久存在）还是<strong>storage</strong>（永久存储在区块链中）<br>所有的复杂类型如数组(arrays)和结构体(struct)有一个额外的属性：<strong>数据的存储位置（data location）</strong>。可为<strong>memory</strong>和<strong>storage</strong>。</p><p>根据上下文的不同，大多数时候数据位置有默认值，也通过指定关键字storage和memory修改它。</p><p>函数参数（包含返回的参数）默认是<strong>memory</strong>。<br>局部复杂类型变量（local variables）和 状态变量（state variables） 默认是<strong>storage</strong>。</p><blockquote><p>局部变量：局部作用域（越过作用域即不可被访问，等待被回收）的变量，如函数内的变量。状态变量：合约内声明的公有变量</p></blockquote><p>还有一个存储位置是：<strong>calldata</strong>，用来存储函数参数，是只读的，不会永久存储的一个数据位置。外部函数的参数（不包括返回参数）被强制指定为calldata。效果与memory差不多。</p><p>数据位置指定非常重要，因为他们影响着赋值行为。<br>在memory和storage之间或与状态变量之间相互赋值，总是会创建一个完全独立的拷贝。<br>而将一个storage的状态变量，赋值给一个storage的局部变量，是通过引用传递。所以对于局部变量的修改，同时修改关联的状态变量。<br>另一方面，将一个memory的引用类型赋值给另一个memory的引用，不会创建拷贝（即：memory之间是引用传递）。</p><blockquote><ol><li>注意：不能将memory赋值给局部变量。</li><li>对于值类型，总是会进行拷贝。</li></ol></blockquote><p>下面看一段代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.0;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    uint[] x; //  x的存储位置是storage</span><br><span class="line"></span><br><span class="line">    // memoryArray的存储位置是 memory</span><br><span class="line">    function f(uint[] memoryArray) public &#123;</span><br><span class="line">        x = memoryArray;    // 从 memory 复制到 storage</span><br><span class="line">        var y = x;          // storage 引用传递局部变量y（y 是一个 storage 引用）</span><br><span class="line">        y[7];               // 返回第8个元素</span><br><span class="line">        y.length = 2;       // x同样会被修改</span><br><span class="line">        delete x;           // y同样会被修改</span><br><span class="line"></span><br><span class="line">        // 错误， 不能将memory赋值给局部变量</span><br><span class="line">        // y = memoryArray;  </span><br><span class="line"></span><br><span class="line">        // 错误，不能通过引用销毁storage</span><br><span class="line">        // delete y;        </span><br><span class="line"></span><br><span class="line">        g(x);               // 引用传递， g可以改变x的内容</span><br><span class="line">        h(x);               // 拷贝到memory， h无法改变x的内容</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function g(uint[] storage storageArray) internal &#123;&#125;</span><br><span class="line">    function h(uint[] memoryArray) public &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><h4 id="强制的数据位置-Forced-data-location"><a href="#强制的数据位置-Forced-data-location" class="headerlink" title="强制的数据位置(Forced data location)"></a>强制的数据位置(Forced data location)</h4><ul><li>外部函数(External function)的参数(不包括返回参数)强制为：calldata</li><li>状态变量(State variables)强制为: storage</li></ul><h4 id="默认数据位置（Default-data-location）"><a href="#默认数据位置（Default-data-location）" class="headerlink" title="默认数据位置（Default data location）"></a>默认数据位置（Default data location）</h4><ul><li>函数参数及返回参数：memory</li><li>复杂类型的局部变量：storage</li></ul><h2 id="深入分析"><a href="#深入分析" class="headerlink" title="深入分析"></a>深入分析</h2><p>storage 存储结构是在合约创建的时候就确定好了的，它取决于合约所声明状态变量。但是内容可以被（交易）调用改变。</p><blockquote><p>Solidity 称这个为状态改变，这也是合约级变量称为<strong>状态变量</strong>的原因。也可以更好的理解为什么状态变量都是storage存储。</p></blockquote><p>memory 只能用于函数内部，memory 声明用来告知EVM在运行时创建一块（固定大小）内存区域给变量使用。</p><blockquote><p>storage 在区块链中是用key/value的形式存储，而memory则表现为字节数组</p></blockquote><h3 id="关于栈（stack）"><a href="#关于栈（stack）" class="headerlink" title="关于栈（stack）"></a>关于栈（stack）</h3><p>EVM是一个基于栈的语言，栈实际是在内存(memory)的一个数据结构，每个栈元素占为256位，栈最大长度为1024。<br>值类型的局部变量是存储在栈上。</p><h3 id="不同存储的消耗（gas消耗）"><a href="#不同存储的消耗（gas消耗）" class="headerlink" title="不同存储的消耗（gas消耗）"></a>不同存储的消耗（gas消耗）</h3><ul><li>storage 会永久保存合约状态变量，开销最大</li><li>memory 仅保存临时变量，函数调用之后释放，开销很小</li><li>stack  保存很小的局部变量，几乎免费使用，但有数量限制。</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://solidity.readthedocs.io/en/develop/types.html#data-location" target="_blank" rel="noopener">Solidity官方文档-类型</a></p><p><a href="https://learnblockchain.cn/">深入浅出区块链</a> - 系统学习区块链，打造最好的区块链技术博客。<br>我的<strong><a href="https://t.xiaomiquan.com/RfAu7uj" target="_blank" rel="noopener">知识星球</a></strong>为各位解答区块链技术问题，欢迎加入讨论。</p><!---[1](https://stackoverflow.com/questions/33839154/in-ethereum-solidity-what-is-the-purpose-of-the-memory-keyword)[2](https://ethereum.stackexchange.com/questions/17964/why-are-local-variables-allocated-to-storage-instead-of-memory) -->]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Solidity教程系列第4篇 - Solidity数据位置分析。&lt;br&gt;Solidity 系列完整的文章列表请查看&lt;a href=&quot;https://learnblockchain.cn/categories/ethereum/Solidity/&quot;&gt;分类-Solidity&lt;/a&gt;。&lt;br&gt;
    
    </summary>
    
      <category term="以太坊" scheme="https://learnblockchain.cn/categories/ethereum/"/>
    
      <category term="Solidity" scheme="https://learnblockchain.cn/categories/ethereum/Solidity/"/>
    
    
      <category term="Solidity手册" scheme="https://learnblockchain.cn/tags/Solidity%E6%89%8B%E5%86%8C/"/>
    
  </entry>
  
  <entry>
    <title>智能合约语言 Solidity 教程系列3 - 函数类型</title>
    <link href="https://learnblockchain.cn/2017/12/12/solidity_func/"/>
    <id>https://learnblockchain.cn/2017/12/12/solidity_func/</id>
    <published>2017-12-12T07:25:59.000Z</published>
    <updated>2018-03-18T13:55:32.197Z</updated>
    
    <content type="html"><![CDATA[<p>Solidity 教程系列第三篇 - Solidity 函数类型介绍。<br>Solidity 系列完整的文章列表请查看<a href="https://learnblockchain.cn/categories/ethereum/Solidity/">分类-Solidity</a>。</p><a id="more"></a><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>Solidity 是以太坊智能合约编程语言，阅读本文前，你应该对以太坊、智能合约有所了解，如果你还不了解，建议你先看<a href="https://learnblockchain.cn/2017/11/20/whatiseth/">以太坊是什么</a></p><p>本文前半部分是参考Solidity 官方文档（当前最新版本：0.4.20）进行翻译，后半部分函数可见性（ public, external, internal, privite ）深度分析（仅针对<a href="https://xiaozhuanlan.com/blockchaincore" target="_blank" rel="noopener">专栏</a>订阅用户）。</p><h2 id="函数类型（Function-Types）"><a href="#函数类型（Function-Types）" class="headerlink" title="函数类型（Function Types）"></a>函数类型（Function Types）</h2><p>函数也是一种类型，且属于值类型。<br>可以将一个函数赋值给一个函数类型的变量。还可以将一个函数作为参数进行传递。也可以在函数调用中返回一个函数。<br>函数类型有两类:内部(internal)和外部(external)函数</p><p><strong>内部(internal)函数</strong>只能在当前合约内被调用（在当前的代码块内，包括内部库函数，和继承的函数中）。<br><strong>外部(external)函数</strong>由地址和函数方法签名两部分组成，可作为外部函数调用的参数，或返回值。</p><p>函数类型定义如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> (<span class="params">&lt;parameter types&gt;</span>) </span>&#123;internal|external&#125; [pure|constant|view|payable] [returns (&lt;return types&gt;)]</span><br></pre></td></tr></table></figure></p><p>如果函数不需要返回，则省去returns (<return types="">)<br>函数类型默认是internal， 因此internal可以省去。但以此相反，合约中函数本身默认是public的， 仅仅是当作类型名使用时默认是internal的。</return></p><p>有两个方式访问函数，一种是直接用函数名<strong>f</strong>, 一种是<strong>this.f</strong>， 前者用于内部函数，后者用于外部函数。</p><p>如果一个函数变量没有初始化，直接调用它将会产生异常。如果delete了一个函数后调用，也会发生同样的异常。</p><p>如果外部函数类型在Solidity的上下文环境以外的地方使用，他们会被视为<strong>function</strong>类型。它会编码为20字节的函数所在地址，和在它之前的4字节的函数方法签名一起作为<strong>bytes24</strong>类型。<br>合约中的public的函数，可以使用internal和external两种方式来调用。<br>internal访问形式为<strong>f</strong>,  external访问形式为<strong>this.f</strong></p><h3 id="成员-属性-selector"><a href="#成员-属性-selector" class="headerlink" title="成员: 属性 selector"></a>成员: 属性 selector</h3><p> public (或 external) 函数有一个特殊的成员selector, 它对应一个ABI 函数选择器。<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.16</span>;</span><br><span class="line"></span><br><span class="line">contract Selector &#123;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) <span class="title">public</span> <span class="title">view</span> <span class="title">returns</span> (<span class="params">bytes4</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.f.selector;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>下面的代码显示内部（internal）函数类型的使用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.16</span>;</span><br><span class="line"></span><br><span class="line">library ArrayUtils &#123;</span><br><span class="line">  <span class="comment">// internal functions can be used in internal library functions because</span></span><br><span class="line">  <span class="comment">// they will be part of the same code context</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">map</span>(<span class="params">uint[] memory self, function (uint</span>) <span class="title">pure</span> <span class="title">returns</span> (<span class="params">uint</span>) <span class="title">f</span>)</span></span><br><span class="line"><span class="function">    <span class="title">internal</span></span></span><br><span class="line"><span class="function">    <span class="title">pure</span></span></span><br><span class="line"><span class="function">    <span class="title">returns</span> (<span class="params">uint[] memory r</span>)</span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    r = <span class="keyword">new</span> uint[](self.length);</span><br><span class="line">    <span class="keyword">for</span> (uint i = <span class="number">0</span>; i &lt; self.length; i++) &#123;</span><br><span class="line">      r[i] = f(self[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">reduce</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    uint[] memory self,</span></span></span><br><span class="line"><span class="function"><span class="params">    function (uint, uint</span>) <span class="title">pure</span> <span class="title">returns</span> (<span class="params">uint</span>) <span class="title">f</span></span></span><br><span class="line"><span class="function">  )</span></span><br><span class="line"><span class="function">    <span class="title">internal</span></span></span><br><span class="line"><span class="function">    <span class="title">pure</span></span></span><br><span class="line"><span class="function">    <span class="title">returns</span> (<span class="params">uint r</span>)</span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    r = self[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (uint i = <span class="number">1</span>; i &lt; self.length; i++) &#123;</span><br><span class="line">      r = f(r, self[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">range</span>(<span class="params">uint length</span>) <span class="title">internal</span> <span class="title">pure</span> <span class="title">returns</span> (<span class="params">uint[] memory r</span>) </span>&#123;</span><br><span class="line">    r = <span class="keyword">new</span> uint[](length);</span><br><span class="line">    <span class="keyword">for</span> (uint i = <span class="number">0</span>; i &lt; r.length; i++) &#123;</span><br><span class="line">      r[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Pyramid &#123;</span><br><span class="line">  using ArrayUtils <span class="keyword">for</span> *;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">pyramid</span>(<span class="params">uint l</span>) <span class="title">public</span> <span class="title">pure</span> <span class="title">returns</span> (<span class="params">uint</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ArrayUtils.range(l).map(square).reduce(sum);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">square</span>(<span class="params">uint x</span>) <span class="title">internal</span> <span class="title">pure</span> <span class="title">returns</span> (<span class="params">uint</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x * x;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">uint x, uint y</span>) <span class="title">internal</span> <span class="title">pure</span> <span class="title">returns</span> (<span class="params">uint</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面的代码显示外部（external）函数类型的使用：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.11</span>;</span><br><span class="line"></span><br><span class="line">contract Oracle &#123;</span><br><span class="line">  struct Request &#123;</span><br><span class="line">    bytes data;</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params">bytes memory</span>) <span class="title">external</span> <span class="title">callback</span>;</span></span><br><span class="line"><span class="function">  &#125;</span></span><br><span class="line">  Request[] requests;</span><br><span class="line">  event NewRequest(uint);</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">query</span>(<span class="params">bytes data, function(bytes memory</span>) <span class="title">external</span> <span class="title">callback</span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">    requests.push(Request(data, callback));</span><br><span class="line">    NewRequest(requests.length - <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">reply</span>(<span class="params">uint requestID, bytes response</span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Here goes the check that the reply comes from a trusted source</span></span><br><span class="line">    requests[requestID].callback(response);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract OracleUser &#123;</span><br><span class="line">  Oracle constant oracle = Oracle(<span class="number">0x1234567</span>); <span class="comment">// known contract</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">buySomething</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    oracle.query(<span class="string">"USD"</span>, <span class="keyword">this</span>.oracleResponse);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">oracleResponse</span>(<span class="params">bytes response</span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">    <span class="built_in">require</span>(msg.sender == address(oracle));</span><br><span class="line">    <span class="comment">// Use the data</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="函数可见性分析"><a href="#函数可见性分析" class="headerlink" title="函数可见性分析"></a>函数可见性分析</h2><ul><li>public - 任意访问</li><li>private - 仅当前合约内</li><li>internal - 仅当前合约及所继承的合约</li><li>external - 仅外部访问（在内部也只能用外部访问方式访问）</li></ul><h3 id="public-还是-external-最佳实践"><a href="#public-还是-external-最佳实践" class="headerlink" title="public 还是 external 最佳实践"></a>public 还是 external 最佳实践</h3><p>请订阅<a href="https://xiaozhuanlan.com/blockchaincore" target="_blank" rel="noopener">区块链技术</a>查看。</p><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="https://solidity.readthedocs.io/en/develop/types.html" target="_blank" rel="noopener">Solidity官方文档-类型</a></p><p><a href="https://learnblockchain.cn/">深入浅出区块链</a> - 系统学习区块链，打造最好的区块链技术博客。<br>我的<strong><a href="https://t.xiaomiquan.com/RfAu7uj" target="_blank" rel="noopener">知识星球</a></strong>为各位解答区块链技术问题，欢迎加入讨论。</p><!---先上一个例子看 public 与 external 不同，代码如下：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity^<span class="number">0.4</span><span class="number">.18</span>;</span><br><span class="line"></span><br><span class="line">contract Test &#123;</span><br><span class="line">    uint[<span class="number">10</span>] x = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">uint[<span class="number">10</span>] a</span>) <span class="title">public</span> <span class="title">returns</span> (<span class="params">uint</span>)</span>&#123;</span><br><span class="line">         <span class="keyword">return</span> a[<span class="number">9</span>]*<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">test2</span>(<span class="params">uint[<span class="number">10</span>] a</span>) <span class="title">external</span> <span class="title">returns</span> (<span class="params">uint</span>)</span>&#123;</span><br><span class="line">         <span class="keyword">return</span> a[<span class="number">9</span>]*<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">calltest</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        test(x);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">calltest2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.test2(x);</span><br><span class="line">        <span class="comment">//test2(x);  //不能在内部调用一个外部函数，会报编译错误。</span></span><br><span class="line">    &#125;  </span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打开<a href="https://ethereum.github.io/browser-solidity">Remix - Solidity IDE</a>,帖入代码，创建合约。<br>然后，我们分别调用 test 及 test2 ，对比执行花费的 gas。<br><img src="/images/test_func.jpg" alt=""><br><img src="/images/test_func2.jpg" alt=""><br>可以看到调用pubic函数花销更大，这是为什么呢？</p><p>当使用public 函数时，Solidity会立即复制数组参数数据到内存， 而external函数则是从calldata读取，而分配内存开销比直接从calldata读取要大的多。<br>那为什么public函数要复制数组参数数据到内存呢？是因为public函数可能会被内部调用，而内部调用数组的参数是当做指向一块内存的指针。<br>对于external函数不允许内部调用，它直接从<strong>calldata</strong>读取数据，省去了复制的过程。</p><p>所以，如果确认一个函数仅仅在外部访问，请用<strong>external</strong>。</p><p>同样，我们接着对比calltest()及calltest2()，这里不截图了，大家自己运行对比一下，可以发现：calltest2的开销比calltest的开销大很多，这是因为通过<strong>this.f()</strong>模式调用，会有一个大开销的<strong>CALL</strong>调用，并且它传参的方式也比内部传递开销更大。</p><p>因此，当需要内部调用的时候，请用<strong>public</strong>。</p><p>–&gt;</p>-->]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Solidity 教程系列第三篇 - Solidity 函数类型介绍。&lt;br&gt;Solidity 系列完整的文章列表请查看&lt;a href=&quot;https://learnblockchain.cn/categories/ethereum/Solidity/&quot;&gt;分类-Solidity&lt;/a&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="以太坊" scheme="https://learnblockchain.cn/categories/ethereum/"/>
    
      <category term="Solidity" scheme="https://learnblockchain.cn/categories/ethereum/Solidity/"/>
    
    
      <category term="Solidity" scheme="https://learnblockchain.cn/tags/Solidity/"/>
    
  </entry>
  
  <entry>
    <title>智能合约语言 Solidity 教程系列2 - 地址类型介绍</title>
    <link href="https://learnblockchain.cn/2017/12/12/solidity2/"/>
    <id>https://learnblockchain.cn/2017/12/12/solidity2/</id>
    <published>2017-12-12T07:25:59.000Z</published>
    <updated>2018-03-18T13:55:32.196Z</updated>
    
    <content type="html"><![CDATA[<p>Solidity教程系列第二篇 - Solidity地址类型介绍.<br>Solidity 系列完整的文章列表请查看<a href="https://learnblockchain.cn/categories/ethereum/Solidity/">分类-Solidity</a>。<br><a id="more"></a></p><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>Solidity是以太坊智能合约编程语言，阅读本文前，你应该对以太坊、智能合约有所了解，如果你还不了解，建议你先看<a href="https://learnblockchain.cn/2017/11/20/whatiseth/">以太坊是什么</a></p><p>本文前半部分是参考Solidity官方文档（当前最新版本：0.4.20）进行翻译，后半部分是结合实际合约代码实例说明类型的使用（仅针对<a href="https://xiaozhuanlan.com/blockchaincore" target="_blank" rel="noopener">专栏</a>订阅用户）。</p><h2 id="地址类型（Address）"><a href="#地址类型（Address）" class="headerlink" title="地址类型（Address）"></a>地址类型（Address）</h2><p>地址类型<strong>address</strong>是一个值类型，</p><p><strong>地址</strong>： 20字节（一个以太坊地址的长度），地址类型也有成员，地址是所有合约的基础<br>支持的运算符：</p><ul><li>&lt;=, &lt;, ==, !=, &gt;= 和 &gt;<blockquote><p>注意：从0.5.0开始，合约不再继承自地址类型，但仍然可以显式转换为地址。</p></blockquote></li></ul><h3 id="地址类型的成员"><a href="#地址类型的成员" class="headerlink" title="地址类型的成员"></a>地址类型的成员</h3><ul><li><p>balance 属性及transfer() 函数<br>这里是地址类型相关成员的<a href="https://solidity.readthedocs.io/en/develop/units-and-global-variables.html#address-related" target="_blank" rel="noopener">快速索引</a><br>  balance用来查询账户余额，transfer()用来发送以太币（以wei为单位）。<br>  如：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">address x = 0x123;</span><br><span class="line">address myAddress = this;</span><br><span class="line">if (x.balance &lt; 10 &amp;&amp; myAddress.balance &gt;= 10) x.transfer(10);</span><br></pre></td></tr></table></figure><p> <strong>注解</strong>：如果x是合约地址，合约的回退函数（fallback 函数）会随<strong>transfer</strong>调用一起执行（这个是EVM特性），如果因gas耗光或其他原因失败，转移交易会还原并且合约会抛异常停止。</p><blockquote><p>关于回退函数（fallback 函数），简单来说它是合约中无函数名函数，下面代码事例中，进进一步讲解回退函数（fallback） 的使用。</p></blockquote></li></ul><ul><li><p>send() 函数<br>  send 与transfer对应，但更底层。如果执行失败，transfer不会因异常停止，而send会返回false。</p><blockquote><p><strong>警告</strong>：send() 执行有一些风险：如果调用栈的深度超过1024或gas耗光，交易都会失败。因此，为了保证安全，必须检查send的返回值，如果交易失败，会回退以太币。如果用transfer会更好。</p></blockquote></li><li><p>call(), callcode() 和 delegatecall() 函数<br>  为了和非ABI协议的合约进行交互，可以使用call() 函数, 它用来向另一个合约发送原始数据，支持任何类型任意数量的参数，每个参数会按规则(ABI协议)打包成32字节并一一拼接到一起。一个例外是：如果第一个参数恰好4个字节，在这种情况下，会被认为根据ABI协议定义的函数器指定的函数签名而直接使用。如果仅想发送消息体，需要避免第一个参数是4个字节。如下面的例子：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">address nameReg = 0x72ba7d8e73fe8eb666ea66babc8116a41bfb10e2;</span><br><span class="line">nameReg.call(&quot;register&quot;, &quot;MyName&quot;);</span><br><span class="line">nameReg.call(bytes4(keccak256(&quot;fun(uint256)&quot;)), a);</span><br></pre></td></tr></table></figure><p>  <strong>call</strong>函数返回一个bool值，以表明执行成功与否。正常结束返回true，异常终止返回false。但无法获取到结果数据，因为需要提前知道返回的数据的编码和数据大小（因不知道对方使用的协议格式，所以也不会知道返回的结果如何解析）。<br>  还可以提供<strong>.gas()</strong>修饰器进行调用：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">namReg.call.gas(1000000)(&quot;register&quot;, &quot;MyName&quot;);</span><br></pre></td></tr></table></figure><p>  类似还可以提供附带以太币：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nameReg.call.value(1 ether)(&quot;register&quot;, &quot;MyName&quot;);</span><br></pre></td></tr></table></figure><p>  修饰器可以混合使用，修饰器调用顺序无所谓。</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nameReg.call.gas(1000000).value(1 ether)(&quot;register&quot;, &quot;MyName&quot;);</span><br></pre></td></tr></table></figure><blockquote><p>注解：目前还不能在重载函数上使用gas或value修饰符，A workaround is to introduce a special case for gas and value and just re-check whether they are present at the point of overload resolution.（这句我怕翻译的不准确，引用原文）</p></blockquote><p>  同样我们也可以使用delegatecall()，它与call方法的区别在于，仅仅是代码会执行，而其它方面，如（存储，余额等）都是用的当前的合约的数据。delegatecall()方法的目的是用来执行另一个合约中的库代码。所以开发者需要保证两个合约中的存储变量能兼容，来保证delegatecall()能顺利执行。在homestead阶段之前，仅有一个受限的callcode()方法可用，但callcode未提供对msg.sender，msg.value的访问权限。</p><p>  上面的这三个方法call()，delegatecall()，callcode()都是底层的消息传递调用，最好仅在万不得已才进行使用，因为他们破坏了Solidity的类型安全。<br>  .gas() 在call(), callcode() 和 delegatecall() 函数下都可以使用， delegatecall()不支持.value()</p><blockquote><p>注解：所有合约都继承了address的成员，因此可以使用this.balance查询余额。<br>callcode不鼓励使用，以后会移除。</p><p>警告：上述的函数都是底层的函数，使用时要异常小心。当调用一个未知的，可能是恶意的合约时，当你把控制权交给它，它可能回调回你的合约，所以要准备好在调用返回时，应对你的状态变量可能被恶意篡改的情况。</p></blockquote></li></ul><h2 id="地址常量（Address-Literals）"><a href="#地址常量（Address-Literals）" class="headerlink" title="地址常量（Address Literals）"></a>地址常量（Address Literals）</h2><p>一个能通过地址合法性检查（address checksum test）十六进制常量就会被认为是地址，如0xdCad3a6d3569DF655070DEd06cb7A1b2Ccd1D3AF。而不能通过地址合法性检查的39到41位长的十六进制常量，会提示一个警告，被视为普通的有理数常量。</p><blockquote><p>地址合法性检查定义在<a href="https://github.com/ethereum/EIPs/blob/master/EIPS/eip-55.md" target="_blank" rel="noopener">EIP-55</a></p></blockquote><h2 id="合约事例讲解"><a href="#合约事例讲解" class="headerlink" title="合约事例讲解"></a>合约事例讲解</h2><h3 id="合约事例代码"><a href="#合约事例代码" class="headerlink" title="合约事例代码"></a>合约事例代码</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract AddrTest&#123;</span><br><span class="line">    event logdata(bytes data);</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params"></span>) <span class="title">payable</span> </span>&#123;</span><br><span class="line">        logdata(msg.data);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">getBalance</span>(<span class="params"></span>) <span class="title">returns</span> (<span class="params">uint</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.balance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    uint score = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">setScore</span>(<span class="params">uint s</span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">        score = s;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">getScore</span>(<span class="params"></span>) <span class="title">returns</span> (<span class="params"> uint</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> score;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract CallTest&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">deposit</span>(<span class="params"></span>) <span class="title">payable</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    event logSendEvent(address to, uint value);</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">transferEther</span>(<span class="params">address towho</span>) <span class="title">payable</span> </span>&#123;</span><br><span class="line">        towho.transfer(<span class="number">10</span>);</span><br><span class="line">        logSendEvent(towho, <span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">callNoFunc</span>(<span class="params">address addr</span>) <span class="title">returns</span> (<span class="params">bool</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> addr.call(<span class="string">"tinyxiong"</span>, <span class="number">1234</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">callfunc</span>(<span class="params">address addr</span>) <span class="title">returns</span> (<span class="params">bool</span>)</span>&#123;</span><br><span class="line">        bytes4 methodId = bytes4(keccak256(<span class="string">"setScore(uint256)"</span>));</span><br><span class="line">        <span class="keyword">return</span> addr.call(methodId, <span class="number">100</span>);</span><br><span class="line">    &#125;  </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">getBalance</span>(<span class="params"></span>) <span class="title">returns</span> (<span class="params">uint</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.balance;</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="代码运行及讲解"><a href="#代码运行及讲解" class="headerlink" title="代码运行及讲解"></a>代码运行及讲解</h3><p>代码运行及讲解，请订阅<a href="https://xiaozhuanlan.com/blockchaincore" target="_blank" rel="noopener">区块链技术</a>查看。</p><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="https://solidity.readthedocs.io/en/develop/types.html" target="_blank" rel="noopener">Solidity官方文档-类型</a></p><p><a href="https://learnblockchain.cn/">深入浅出区块链</a> - 系统学习区块链，打造最好的区块链技术博客。<br>我的<strong><a href="https://t.xiaomiquan.com/RfAu7uj" target="_blank" rel="noopener">知识星球</a></strong>为各位解答区块链技术问题，欢迎加入讨论。</p><!---和[类型介绍](https://xiaozhuanlan.com/topic/7518269403)篇一样，打开[Remix - Solidity IDE](https://ethereum.github.io/browser-solidity),帖入代码，依次创建合约AddrTest及CallTest，如图：![](/images/testaddr.jpg)创建合约后，可以看到，AddrTest合约内没有命令的函数，显示fallback。AddrTest合约主要是用来说明转入以太币及调用函数式回退函数的调用情况，CallTest合约是作为AddrTest合约的调用者。CallTest合约的函数说明：* transferEther(address towho):  用来给指定合约地址转账（如果一个函数需要进行货币操作，必须要带上payable关键字），转账时填入AddrTest的地址（加双引号）作为参数* deposit(): 函数上增加payable标识，可接收ether，并会把ether存在当前合约，（transferEther转账前需要先存款）。* callfunc() : 调用函数，使用指定的是函数签名。* callNoFunc(): 调用不存在的函数，这时被调用的合约的fallback函数会执行。关于fallback函数用法可进一步参考这一篇:[Ethereum-Development-Best-Practices][1]及[问答](https://ethereum.stackexchange.com/questions/7570/whats-a-fallback-function-when-using-address-send)下面截图演示下，存款和转账，其他的调用请读者动手练习。存款操作如图：![](/images/testaddr1.jpg)完成后，可以在左下角区域查看日志Details->value。然后进行转账，如图：![](/images/testaddr2.jpg)完成后，可以在左下角区域查看日志Details->logs数据，可以看到fallback函数被调用。还可以调用AddrTest的getBalance查看余额数据。[1]: https://github.com/ConsenSys/Ethereum-Development-Best-Practices/wiki/Fallback-functions-and-the-fundamental-limitations-of-using-send()-in-Ethereum-&-Solidity-->]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Solidity教程系列第二篇 - Solidity地址类型介绍.&lt;br&gt;Solidity 系列完整的文章列表请查看&lt;a href=&quot;https://learnblockchain.cn/categories/ethereum/Solidity/&quot;&gt;分类-Solidity&lt;/a&gt;。&lt;br&gt;
    
    </summary>
    
      <category term="以太坊" scheme="https://learnblockchain.cn/categories/ethereum/"/>
    
      <category term="Solidity" scheme="https://learnblockchain.cn/categories/ethereum/Solidity/"/>
    
    
      <category term="Solidity" scheme="https://learnblockchain.cn/tags/Solidity/"/>
    
  </entry>
  
  <entry>
    <title>比特币如何达成共识 - 最长链的选择</title>
    <link href="https://learnblockchain.cn/2017/12/07/bitcoin-sonsensus/"/>
    <id>https://learnblockchain.cn/2017/12/07/bitcoin-sonsensus/</id>
    <published>2017-12-07T08:12:29.000Z</published>
    <updated>2018-01-10T08:10:46.598Z</updated>
    
    <content type="html"><![CDATA[<p>比特币没有中心机构，几乎所有的完整节点都有一份公共总帐本，那么大家如何达成共识：确认哪一份才是公认权威的总账本呢？</p><a id="more"></a><h2 id="为什么要遵守协议"><a href="#为什么要遵守协议" class="headerlink" title="为什么要遵守协议"></a>为什么要遵守协议</h2><p>这其实是一个经济问题，在经济活动中的每个人都是自私自利的，追求的是利益的最大化，一个节点工作量只有在其他的节点认同其是有效的（打包的新区块，其他的节点只有验证通过才会加入到区块链中，并在网络上传播），才能够过得收益，<br>而只有遵守规则才会得到其他的节点认同。<br>因此，基于逐利，节点就会自发的遵守协议。共识就是数以万计的独立节点遵守了简单的规则（通过异步交互）自发形成的。</p><blockquote><p>共识：共同遵守的协议规范</p></blockquote><h2 id="去中心化共识"><a href="#去中心化共识" class="headerlink" title="去中心化共识"></a>去中心化共识</h2><p>在<a href="https://learnblockchain.cn/2017/11/04/bitcoin-pow/">工作量证明</a>一篇，我们了解通过工作量证明来竞争记账，权威的总帐本是怎么达到共识的，没有完全说清楚，今天补上，<br>实际上，比特币的共识由所有节点的4个<strong>独立过程</strong>相互作用而产生：</p><ol><li>每个节点（挖矿节点）依据标准对每个交易进行独立验证</li><li>挖矿节点通过完成工作量证明，将交易记录独立打包进新区块</li><li>每个节点独立的对新区块进行校验并组装进区块链</li><li>每个节点对区块链进行独立选择，在工作量证明机制下选择累计工作量最大的区块链</li></ol><p>共识最终目的是保证比特币不停的在工作量最大的区块链上运转，工作量最大的区块链就是权威的公共总帐本。</p><p>第1 2 3步在<a href="https://learnblockchain.cn/2017/11/04/bitcoin-pow/">比特币如何挖矿-工作量证明</a>一篇有提到过，下面着重讲第4步。</p><h2 id="最长链的选择"><a href="#最长链的选择" class="headerlink" title="最长链的选择"></a>最长链的选择</h2><p>先来一个定义，把累计了最多难度的区块链。在一般情况下，也是包含最多区块的那个链称为<strong>主链</strong><br>每一个（挖矿）节点总是选择并尝试延长主链。</p><h3 id="分叉"><a href="#分叉" class="headerlink" title="分叉"></a>分叉</h3><p>当有两名矿工在几乎在相同的时间内，各自都算得了工作量证明解，便立即传播自己的“获胜”区块到网络中，先是传播给邻近的节点而后传播到整个网络。每个收到有效区块的节点都会将其并入并延长区块链。<br>当这个两个区块传播时，一些节点首先收到#3458A, 一些节点首先收到#3458B，这两个候选区块（通常这两个候选区块会包含几乎相同的交易）都是主链的延伸，分叉就会产生，这时分叉出有竞争关系的两条链，如图：<br><img src="/images/block_branch.jpg" alt=""><br>两个块都收到的节点，会把其中有更多工作量的一条会继续作为主链，另一条作为<strong>备用链</strong>保存（保存是因为备用链将来可能会超过主链难度称为新主链）。</p><h3 id="分叉解决"><a href="#分叉解决" class="headerlink" title="分叉解决"></a>分叉解决</h3><p>收到#3458A的（挖矿）节点，会立刻以这个区块为父区块来产生新的候选区块，并尝试寻找这个候选区块的工作量证明解。同样地，接受#3458B区块的节点会以这个区块为链的顶点开始生成新块，延长这个链（下面称为B链）。<br>这时总会有一方抢先发现工作量证明解并将其传播出去，假设以#3458B为父区块的工作量证明首先解出，如图：<br><img src="/images/block_branch2.jpg" alt=""></p><p>当原本以#3458A为父区块求解的节点在收到#3458B, #3459B之后，会立刻将B链作为主链（因为#3458A为顶点的链已经不是最长链了）继续挖矿。</p><blockquote><p>节点也有可能先收到#3459B，再收到#3458B，收到#3459B时，会被认为是“孤块“（因为还找不到#3459B的父块#3458B）保存在孤块池中，一旦收到父块#3458B时，节点就会将孤块从孤块池中取出，并且连接到它的父区块，让它作为区块链的一部分。</p></blockquote><p>比特币将区块间隔设计为10分钟，是在更快速的交易确认和更低的分叉概率间作出的妥协。更短的区块产生间隔会让交易确认更快地完成，也会导致更加频繁地区块链分叉。与之相对地，长的间隔会减少分叉数量，却会导致更长的确认时间。</p><p><a href="https://learnblockchain.cn/">深入浅出区块链</a> - 系统学习区块链，打造最好的区块链技术博客。<br>我的<strong><a href="https://t.xiaomiquan.com/RfAu7uj" target="_blank" rel="noopener">知识星球</a></strong>为各位解答区块链技术问题，欢迎加入讨论。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;比特币没有中心机构，几乎所有的完整节点都有一份公共总帐本，那么大家如何达成共识：确认哪一份才是公认权威的总账本呢？&lt;/p&gt;
    
    </summary>
    
      <category term="比特币" scheme="https://learnblockchain.cn/categories/bitcoin/"/>
    
    
      <category term="比特币" scheme="https://learnblockchain.cn/tags/%E6%AF%94%E7%89%B9%E5%B8%81/"/>
    
      <category term="共识协议" scheme="https://learnblockchain.cn/tags/%E5%85%B1%E8%AF%86%E5%8D%8F%E8%AE%AE/"/>
    
  </entry>
  
  <entry>
    <title>智能合约语言 Solidity 教程系列1 - 类型介绍</title>
    <link href="https://learnblockchain.cn/2017/12/05/solidity1/"/>
    <id>https://learnblockchain.cn/2017/12/05/solidity1/</id>
    <published>2017-12-05T07:25:59.000Z</published>
    <updated>2018-03-18T13:55:32.196Z</updated>
    
    <content type="html"><![CDATA[<p>现在的Solidity中文文档，要么翻译的太烂，要么太旧，决定重新翻译下。<br>尤其点名批评极客学院名为《Solidity官方文档中文版》的翻译，机器翻译的都比它好，大家还是别看了。</p><a id="more"></a><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>Solidity是以太坊智能合约编程语言，阅读本文前，你应该对以太坊、智能合约有所了解，<br>如果你还不了解，建议你先看<a href="https://learnblockchain.cn/2017/11/20/whatiseth/">以太坊是什么</a><br>Solidity教程会是一系列文章，本文是第一篇：介绍Solidity的变量类型。<br>Solidity 系列完整的文章列表请查看<a href="https://learnblockchain.cn/categories/ethereum/Solidity/">分类-Solidity</a>。</p><p>本文前半部分是参考Solidity官方文档（当前最新版本：0.4.20）进行翻译，后半部分是结合实际合约代码实例说明类型的使用（仅针对<a href="https://xiaozhuanlan.com/blockchaincore" target="_blank" rel="noopener">专栏</a>订阅用户）。</p><h2 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h2><p>Solidity是一种静态类型语言，意味着每个变量（本地或状态变量）需要在编译时指定变量的类型（或至少可以推倒出类型）。Solidity提供了一些基本类型可以用来组合成复杂类型。</p><p>Solidity类型分为两类：</p><ul><li>值类型(Value Type) - 变量在赋值或传参时，总是进行值拷贝。</li><li>引用类型(Reference Types)</li></ul><h3 id="值类型-Value-Type"><a href="#值类型-Value-Type" class="headerlink" title="值类型(Value Type)"></a>值类型(Value Type)</h3><p><strong>值类型</strong>包含:</p><ul><li>布尔类型(Booleans)</li><li>整型(Integers)</li><li>定长浮点型(Fixed Point Numbers)</li><li>定长字节数组(Fixed-size byte arrays)</li><li>有理数和整型常量(Rational and Integer Literals)</li><li>字符串常量（String literals）</li><li>十六进制常量（Hexadecimal literals）</li><li>枚举(Enums)</li><li><a href="https://learnblockchain.cn/2017/12/12/solidity_func/">函数类型</a>(Function Types)</li><li><a href="https://learnblockchain.cn/2017/12/12/solidity2/">地址类型</a>(Address)</li><li>地址常量(Address Literals)<blockquote><p><a href="https://learnblockchain.cn/2017/12/12/solidity_func/">函数类型</a>及<a href="https://learnblockchain.cn/2017/12/12/solidity2/">地址类型</a>(Address)有单独的博文，请点击查看。</p></blockquote></li></ul><h2 id="布尔类型-Booleans"><a href="#布尔类型-Booleans" class="headerlink" title="布尔类型(Booleans)"></a>布尔类型(Booleans)</h2><p><strong>布尔(bool)</strong>:可能的取值为常量值<strong>true</strong>和<strong>false</strong>。</p><p>布尔类型支持的运算符有：</p><ul><li>！逻辑非</li><li>&amp;&amp; 逻辑与</li><li>|| 逻辑或</li><li>== 等于</li><li>!= 不等于</li></ul><p>注意：运算符<strong>&amp;&amp;</strong>和<strong>||</strong>是短路运算符，如f(x)||g(y)，当f(x)为真时，则不会继续执行g(y)。</p><h2 id="整型-Integers"><a href="#整型-Integers" class="headerlink" title="整型(Integers)"></a>整型(Integers)</h2><p><strong>int</strong>/<strong>uint</strong>: 表示有符号和无符号不同位数整数。支持关键字<strong>uint8</strong> 到 <strong>uint256</strong> (以8步进)，<br><strong>uint</strong> 和 <strong>int</strong> 默认对应的是 <strong>uint256</strong> 和 <strong>int256</strong>。</p><p>支持的运算符：</p><ul><li>比较运算符： &lt;=, &lt; , ==, !=, &gt;=, &gt; (返回布尔值：true 或 false)</li><li>位操作符： &amp;，|，^(异或)，~（位取反）</li><li>算术操作符：+，-，一元运算-，一元运算+，<em>，/, %(取余数), **</em>（幂）, &lt;&lt; (左移位), &gt;&gt;(右移位)</li></ul><p>说明：</p><ol><li>整数除法总是截断的，但如果运算符是字面量（字面量稍后讲)，则不会截断。</li><li>整数除0会抛异常。</li><li>移位运算的结果的正负取决于操作符左边的数。x &lt;&lt; y 和 x <em> 2**</em>y 是相等， x &gt;&gt; y 和 x / 2**y 是相等的。</li><li>不能进行负移位，即操作符右边的数不可以为负数，否则会抛出运行时异常。</li></ol><p>注意：Solidity中，右移位是和除等价的，因此右移位一个负数，向下取整时会为0，而不像其他语言里为无限负小数。</p><h2 id="定长浮点型（Fixed-Point-Numbers）"><a href="#定长浮点型（Fixed-Point-Numbers）" class="headerlink" title="定长浮点型（Fixed Point Numbers）"></a>定长浮点型（Fixed Point Numbers）</h2><p>注意：定长浮点型 Solidity（发文时）还不完全支持，它可以用来声明变量，但不可以用来赋值。</p><p><strong>fixed</strong>/<strong>ufixed</strong>: 表示有符号和无符号的固定位浮点数。关键字为<strong>ufixedMxN</strong> 和 <strong>ufixedMxN</strong>。<br><strong>M</strong>表示这个类型要占用的位数，以8步进，可为8到256位。<br><strong>N</strong>表示小数点的个数，可为0到80之前</p><p>支持的运算符：</p><ul><li>比较运算符： &lt;=, &lt; , ==, !=, &gt;=, &gt; (返回布尔值：true 或 false)</li><li>算术操作符：+，-，一元运算-，一元运算+，<em>，/, %(取余数)<br>注意：它和大多数语言的float和double不一样，<em>*M</em></em>是表示整个数占用的固定位数，包含整数部分和小数部分。因此用一个小位数（M较小）来表示一个浮点数时，小数部分会几乎占用整个空间。</li></ul><h2 id="定长字节数组-Fixed-size-byte-arrays"><a href="#定长字节数组-Fixed-size-byte-arrays" class="headerlink" title="定长字节数组(Fixed-size byte arrays)"></a>定长字节数组(Fixed-size byte arrays)</h2><p>关键字有：bytes1, bytes2, bytes3, …, bytes32。（以步长1递增）<br>byte代表bytes1。</p><p>支持的运算符：</p><ul><li>比较符: &lt;=, &lt;, ==, !=, &gt;=, &gt; (返回bool）</li><li>位操作符: &amp;, |, ^ (按位异或)，~（按位取反）, &lt;&lt; (左移位), &gt;&gt; (右移位)</li><li>索引（下标）访问: 如果x是bytesI，当0 &lt;= k &lt; I ，则x[k]返回第k个字节（只读）。</li></ul><p>移位运算和整数类似，移位运算的结果的正负取决于操作符左边的数，且不能进行负移位。<br>如可以-5&lt;&lt;1, 不可以5&lt;&lt;-1</p><p>成员变量：<br><strong>.length</strong>：表示这个字节数组的长度（只读）。</p><h2 id="变长（动态分配大小）字节数组（Dynamically-sized-byte-array）"><a href="#变长（动态分配大小）字节数组（Dynamically-sized-byte-array）" class="headerlink" title="变长（动态分配大小）字节数组（Dynamically-sized byte array）"></a>变长（动态分配大小）字节数组（Dynamically-sized byte array）</h2><ul><li>bytes:动态分配大小字节数组, 参见<a href="http://solidity.readthedocs.io/en/latest/types.html#arrays" target="_blank" rel="noopener">Arrays</a>,不是值类型!</li><li>string:动态分配大小UTF8编码的字符类型,参看<a href="http://solidity.readthedocs.io/en/latest/types.html#arrays" target="_blank" rel="noopener">Arrays</a>。不是值类型!</li></ul><p>根据经验：<br>bytes用来存储任意长度的字节数据，string用来存储任意长度的(UTF-8编码)的字符串数据。<br>如果长度可以确定，尽量使用定长的如byte1到byte32中的一个，因为这样更省空间。</p><h2 id="有理数和整型常量-Rational-and-Integer-Literals"><a href="#有理数和整型常量-Rational-and-Integer-Literals" class="headerlink" title="有理数和整型常量(Rational and Integer Literals)"></a>有理数和整型常量(Rational and Integer Literals)</h2><blockquote><p>也有人把Literals翻译为字面量</p></blockquote><p>整型常量是有一系列0-9的数字组成，10进制表示，比如：8进制是不存在的，前置0在Solidity中是无效的。</p><p>10进制小数常量（Decimal fraction literals）带了一个<strong>.</strong>， 在<strong>.</strong>的两边至少有一个数字，有效的表示如:<strong>1.</strong>, <strong>.1</strong> 和 <strong>1.3</strong>.</p><p>科学符号也支持，基数可以是小数，指数必须是整数， 有效的表示如: <strong>2e10</strong>, <strong>-2e10</strong>, <strong>2e-10</strong>, <strong>2.5e1</strong>。</p><p>数字常量表达式本身支持任意精度，也就是可以不会运算溢出，或除法截断。但当它被转换成对应的非常量类型，或者将他们与非常量进行运算，则不能保证精度了。<br>如：(2*<strong>800 + 1) - 2*</strong>800的结果为1（uint8整类) ，尽管中间结果已经超过计算机字长。另外：<strong>.5 * 8</strong>的结果是4，尽管有非整形参与了运算。</p><p>只要操作数是整形，整型支持的运算符都适用于整型常量表达式。<br>如果两个操作数是小数，则不允许进行位运算，指数也不能是小数。</p><p>注意：<br>Solidity对每一个有理数都有一个数值常量类型。整数常量和有理数常量从属于数字常量。所有的数字常表达式的结果都属于数字常量。所以1 + 2和2 + 1都属于同样的有理数的数字常量3</p><p>警告：<br>整数常量除法，在早期的版本中是被截断的，但现在可以被转为有理数了，如5/2的值为 2.5</p><p>注意：<br>数字常量表达式，一旦其中含有常量表达式，它就会被转为一个非常量类型。下面代码中表达式的结果将会被认为是一个有理数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">uint128 a = 1;</span><br><span class="line">uint128 b = 2.5 + a + 0.5;</span><br></pre></td></tr></table></figure></p><p>上述代码编译不能通过，因为b会被编译器认为是小数型。</p><h2 id="字符串常量"><a href="#字符串常量" class="headerlink" title="字符串常量"></a>字符串常量</h2><p>字符串常量是指由单引号，或双引号引起来的字符串 (“foo” or ‘bar’)。字符串并不像C语言，包含结束符，”foo”这个字符串大小仅为三个字节。和整数常量一样，字符串的长度类型可以是变长的。字符串可以隐式的转换为byte1,…byte32 如果适合，也会转为bytes或string。</p><p>字符串常量支持转义字符，比如\n，\xNN，\uNNNN。其中\xNN表示16进制值，最终转换合适的字节。而\uNNNN表示Unicode编码值，最终会转换为UTF8的序列。</p><h2 id="十六进制常量（Hexadecimal-literals）"><a href="#十六进制常量（Hexadecimal-literals）" class="headerlink" title="十六进制常量（Hexadecimal literals）"></a>十六进制常量（Hexadecimal literals）</h2><p>十六进制常量，以关键字hex打头，后面紧跟用单或双引号包裹的字符串，内容是十六进制字符串，如hex”001122ff”。<br>它的值会用二进制来表示。</p><p>十六进制常量和字符串常量类似，也可以转换为字节数组。</p><h2 id="枚举（Enums）"><a href="#枚举（Enums）" class="headerlink" title="枚举（Enums）"></a>枚举（Enums）</h2><p>在Solidity中，枚举可以用来自定义类型。它可以显示的转换与整数进行转换，但不能进行隐式转换。显示的转换会在运行时检查数值范围，如果不匹配，将会引起异常。枚举类型应至少有一名成员。下面是一个枚举的例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.0;</span><br><span class="line"></span><br><span class="line">contract test &#123;</span><br><span class="line">    enum ActionChoices &#123; GoLeft, GoRight, GoStraight, SitStill &#125;</span><br><span class="line">    ActionChoices choice;</span><br><span class="line">    ActionChoices constant defaultChoice = ActionChoices.GoStraight;</span><br><span class="line"></span><br><span class="line">    function setGoStraight() &#123;</span><br><span class="line">        choice = ActionChoices.GoStraight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Since enum types are not part of the ABI, the signature of &quot;getChoice&quot;</span><br><span class="line">    // will automatically be changed to &quot;getChoice() returns (uint8)&quot;</span><br><span class="line">    // for all matters external to Solidity. The integer type used is just</span><br><span class="line">    // large enough to hold all enum values, i.e. if you have more values,</span><br><span class="line">    // `uint16` will be used and so on.</span><br><span class="line">    function getChoice() returns (ActionChoices) &#123;</span><br><span class="line">        return choice;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function getDefaultChoice() returns (uint) &#123;</span><br><span class="line">        return uint(defaultChoice);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="代码实例"><a href="#代码实例" class="headerlink" title="代码实例"></a>代码实例</h2><p>通过合约代码实例说明类型的使用，请订阅<a href="https://xiaozhuanlan.com/blockchaincore" target="_blank" rel="noopener">区块链技术</a>查看。</p><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="https://solidity.readthedocs.io/en/develop/types.html" target="_blank" rel="noopener">Solidity官方文档-类型</a></p><p><a href="https://learnblockchain.cn/">深入浅出区块链</a> - 系统学习区块链，打造最好的区块链技术博客。<br>我的<strong><a href="https://t.xiaomiquan.com/RfAu7uj" target="_blank" rel="noopener">知识星球</a></strong>为各位解答区块链技术问题，欢迎加入讨论。</p><!---下面我们用一个真实的合约代码来理解下各个类型及操作符。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.18</span>;</span><br><span class="line"></span><br><span class="line">contract testType&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">uint x, uint y</span>) <span class="title">public</span> <span class="title">returns</span> (<span class="params">uint z</span>)</span>&#123;</span><br><span class="line">        z = x + y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">divide</span>(<span class="params">uint x, uint y </span>) <span class="title">public</span> <span class="title">returns</span> (<span class="params">uint z</span>) </span>&#123;</span><br><span class="line">        z = x / y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">leftshift</span>(<span class="params">int x, uint y</span>) <span class="title">public</span> <span class="title">returns</span> (<span class="params">int z</span>)</span>&#123;</span><br><span class="line">        z = x &lt;&lt; y;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">rightshift</span>(<span class="params">int x, uint y</span>) <span class="title">public</span> <span class="title">returns</span> (<span class="params">int z</span>)</span>&#123;</span><br><span class="line">        z = x &gt;&gt; y;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">interLiteral</span>(<span class="params"></span>) <span class="title">public</span> <span class="title">returns</span> (<span class="params">uint, uint</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ((<span class="number">2</span>**<span class="number">800</span> + <span class="number">1</span>) - <span class="number">2</span>**<span class="number">800</span>,  <span class="number">0.5</span>*<span class="number">8</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">hexLiteralBytes</span>(<span class="params"></span>) <span class="title">public</span> <span class="title">returns</span> (<span class="params">bytes2, bytes1, bytes1</span>) </span>&#123;</span><br><span class="line">        bytes2 a = hex<span class="string">"aabb"</span>;</span><br><span class="line">        <span class="keyword">return</span> (a, a[<span class="number">0</span>], a[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><ol><li>打开<a href="https://ethereum.github.io/browser-solidity">browser-solidity</a>，把代码拷贝到编辑器。</li><li>选择环境创建合约</li><li>传参数调用</li><li>点Details 查看结果<br>上一张截图大家就明白了。<br><img src="(https://diycode.b0.upaiyun.com/photo/2017/b2b5529012ae930f5ae3e9a700247cbe.jpg" alt=""></li></ol><p>建议根据自己对类型的理解，修改代码，使用不同的参数进行调用以增强对类型的理解。<br>如：运行hexLiteralBytes()查看输出结果，十六进制常量可转化为字节数组。<br><img src="https://diycode.b0.upaiyun.com/photo/2017/e28c82c8442eca12422d32b9d6563dfa.jpg" alt=""></p><p>–&gt;</p>-->]]></content>
    
    <summary type="html">
    
      &lt;p&gt;现在的Solidity中文文档，要么翻译的太烂，要么太旧，决定重新翻译下。&lt;br&gt;尤其点名批评极客学院名为《Solidity官方文档中文版》的翻译，机器翻译的都比它好，大家还是别看了。&lt;/p&gt;
    
    </summary>
    
      <category term="以太坊" scheme="https://learnblockchain.cn/categories/ethereum/"/>
    
      <category term="Solidity" scheme="https://learnblockchain.cn/categories/ethereum/Solidity/"/>
    
    
      <category term="Solidity手册" scheme="https://learnblockchain.cn/tags/Solidity%E6%89%8B%E5%86%8C/"/>
    
  </entry>
  
  <entry>
    <title>Geth 控制台使用及 Web3.js 使用实战</title>
    <link href="https://learnblockchain.cn/2017/12/01/geth_cmd_short/"/>
    <id>https://learnblockchain.cn/2017/12/01/geth_cmd_short/</id>
    <published>2017-12-01T11:41:53.000Z</published>
    <updated>2018-01-10T08:11:01.433Z</updated>
    
    <content type="html"><![CDATA[<p>在开发以太坊去中心化应用，免不了和以太坊进行交互，那就离不开Web3。<br>Geth 控制台（REPL）实现了所有的<a href="http://web3js.readthedocs.io/en/1.0/index.html" target="_blank" rel="noopener">web3 API</a>及<a href="https://github.com/ethereum/go-ethereum/wiki/Management-APIs#admin" target="_blank" rel="noopener">Admin API</a>，<br>使用好 Geth 就是必修课。结合<a href="https://learnblockchain.cn/2017/11/29/geth_cmd_options/">Geth命令用法</a>阅读效果更佳。</p><a id="more"></a><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>阅读本文之前，你需要对以太坊（区块链）有初步的了解，如果你不知道以太坊是什么，请先阅读<a href="https://learnblockchain.cn/2017/11/20/whatiseth/">以太坊是什么</a>。<br>如果你在我的小专栏之外的地方阅读到本文，你可能只能阅读本文的节选，阅读完整全文请订阅小专栏<a href="https://xiaozhuanlan.com/blockchaincore" target="_blank" rel="noopener">区块链技术</a></p><h2 id="geth控制台初探-启动、退出"><a href="#geth控制台初探-启动、退出" class="headerlink" title="geth控制台初探 - 启动、退出"></a>geth控制台初探 - 启动、退出</h2><p>安装参考<a href="https://learnblockchain.cn/2017/11/24/init-env/">智能合约开发环境搭建</a><br>最简单启动方式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ geth console</span><br></pre></td></tr></table></figure></p><p>geth控制台启动成功之后，可以看到<strong>&gt;</strong>提示符。<br>退出输入exit</p><h2 id="geth-日志控制"><a href="#geth-日志控制" class="headerlink" title="geth 日志控制"></a>geth 日志控制</h2><h3 id="重定向日志到文件"><a href="#重定向日志到文件" class="headerlink" title="重定向日志到文件"></a>重定向日志到文件</h3><p>使用<strong>geth console</strong>启动是，会在当前的交互界面下时不时出现日志。<br>可以使用以下方式把日志输出到文件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ geth console 2&gt;&gt;geth.log</span><br></pre></td></tr></table></figure></p><p>可以新开一个命令行终端输入以下命令查看日志：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ tail -f geth.log</span><br></pre></td></tr></table></figure></p><h3 id="重定向另一个终端"><a href="#重定向另一个终端" class="headerlink" title="重定向另一个终端"></a>重定向另一个终端</h3><p>也可以把日志重定向到另一个终端，先在想要看日志的终端输入：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ tty</span><br></pre></td></tr></table></figure></p><p>就可以获取到终端编号，如：/dev/ttys003<br>然后另一个终端使用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ geth console 2&gt;&gt; /dev/ttys003</span><br></pre></td></tr></table></figure></p><p>启动geth, 这是日志就输出到另一个终端。<br>如果不想看到日志还可以重定向到空终端：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ geth console 2&gt;&gt; /dev/null</span><br></pre></td></tr></table></figure></p><h3 id="日志级别控制"><a href="#日志级别控制" class="headerlink" title="日志级别控制"></a>日志级别控制</h3><p>使用<strong>–verbosity</strong>可以控制日志级别，如不想看到日志还可以使用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ geth --verbosity 0 console</span><br></pre></td></tr></table></figure></p><h2 id="启动一个开发模式测试节点"><a href="#启动一个开发模式测试节点" class="headerlink" title="启动一个开发模式测试节点"></a>启动一个开发模式测试节点</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">geth --datadir /home/xxx/testNet --dev console</span><br></pre></td></tr></table></figure><blockquote><p>技巧：如果我们经常使用一个方式来启动，可以把命令存为一个bash脚本。<br>~/bin你可以放一些常用的脚本，并把~/bin加入到环境变量PATH里。</p></blockquote><h2 id="连接geth节点"><a href="#连接geth节点" class="headerlink" title="连接geth节点"></a>连接geth节点</h2><p>另外一个启动geth的方法是连接到一个geth节点：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ geth attach ipc:/some/custom/path</span><br><span class="line">$ geth attach http://191.168.1.1:8545</span><br><span class="line">$ geth attach ws://191.168.1.1:8546</span><br></pre></td></tr></table></figure></p><p>如连接刚刚打开的开发模式节点使用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">geth attach ipc:testNet/geth.ipc</span><br></pre></td></tr></table></figure></p><p>更多内容请前往区块链技术小专栏查看<a href="https://xiaozhuanlan.com/topic/5617843029" target="_blank" rel="noopener">全文链接</a>。<br><a href="https://learnblockchain.cn/">深入浅出区块链</a> - 系统学习区块链，打造最好的区块链技术博客。<br>我的<strong><a href="https://t.xiaomiquan.com/RfAu7uj" target="_blank" rel="noopener">知识星球</a></strong>为各位解答区块链技术问题，欢迎加入讨论。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在开发以太坊去中心化应用，免不了和以太坊进行交互，那就离不开Web3。&lt;br&gt;Geth 控制台（REPL）实现了所有的&lt;a href=&quot;http://web3js.readthedocs.io/en/1.0/index.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;web3 API&lt;/a&gt;及&lt;a href=&quot;https://github.com/ethereum/go-ethereum/wiki/Management-APIs#admin&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Admin API&lt;/a&gt;，&lt;br&gt;使用好 Geth 就是必修课。结合&lt;a href=&quot;https://learnblockchain.cn/2017/11/29/geth_cmd_options/&quot;&gt;Geth命令用法&lt;/a&gt;阅读效果更佳。&lt;/p&gt;
    
    </summary>
    
      <category term="以太坊" scheme="https://learnblockchain.cn/categories/ethereum/"/>
    
      <category term="geth" scheme="https://learnblockchain.cn/categories/ethereum/geth/"/>
    
    
      <category term="Geth使用" scheme="https://learnblockchain.cn/tags/Geth%E4%BD%BF%E7%94%A8/"/>
    
      <category term="Web3.js" scheme="https://learnblockchain.cn/tags/Web3-js/"/>
    
  </entry>
  
  <entry>
    <title>以太坊客户端Geth命令用法-参数详解</title>
    <link href="https://learnblockchain.cn/2017/11/29/geth_cmd_options/"/>
    <id>https://learnblockchain.cn/2017/11/29/geth_cmd_options/</id>
    <published>2017-11-29T03:51:52.000Z</published>
    <updated>2018-01-10T08:10:52.557Z</updated>
    
    <content type="html"><![CDATA[<p>Geth在以太坊智能合约开发中最常用的工具（必备开发工具），一个多用途的命令行工具。<br>熟悉Geth可以让我们有更好的效率，大家可收藏起来作为Geth命令用法手册。 本文主要是对geth help的翻译，基于最新的geth 1.7.3-stable版本。</p><a id="more"></a><p>如果你还不知道geth是什么，请先阅读<a href="https://learnblockchain.cn/2017/11/20/whatiseth/">入门篇：以太坊是什么</a>。<br>更多geth实战使用方法请参考<a href="https://learnblockchain.cn/2017/12/01/geth_cmd_short/">Geth控制台使用实战及Web3.js使用</a><br>以下开始正文。</p><h2 id="命令用法"><a href="#命令用法" class="headerlink" title="命令用法"></a>命令用法</h2><pre><code>geth [选项] 命令 [命令选项] [参数…]</code></pre><h3 id="版本："><a href="#版本：" class="headerlink" title="版本："></a>版本：</h3><pre><code>1.7.3-stable</code></pre><h3 id="命令"><a href="#命令" class="headerlink" title="命令:"></a>命令:</h3><pre><code>account    管理账户attach     启动交互式JavaScript环境（连接到节点）bug        上报bug Issuesconsole    启动交互式JavaScript环境copydb     从文件夹创建本地链dump       Dump（分析）一个特定的块存储dumpconfig 显示配置值export     导出区块链到文件import     导入一个区块链文件init       启动并初始化一个新的创世纪块js         执行指定的JavaScript文件(多个)license    显示许可信息makecache  生成ethash验证缓存(用于测试)makedag    生成ethash 挖矿DAG(用于测试)monitor    监控和可视化节点指标removedb   删除区块链和状态数据库version    打印版本号wallet     管理Ethereum预售钱包help,h     显示一个命令或帮助一个命令列表</code></pre><h3 id="ETHEREUM选项"><a href="#ETHEREUM选项" class="headerlink" title="ETHEREUM选项:"></a>ETHEREUM选项:</h3><pre><code>--config value          TOML 配置文件--datadir “xxx”         数据库和keystore密钥的数据目录--keystore              keystore存放目录(默认在datadir内)--nousb                 禁用监控和管理USB硬件钱包--networkid value       网络标识符(整型, 1=Frontier, 2=Morden (弃用), 3=Ropsten, 4=Rinkeby) (默认: 1)--testnet               Ropsten网络:预先配置的POW(proof-of-work)测试网络--rinkeby               Rinkeby网络: 预先配置的POA(proof-of-authority)测试网络--syncmode &quot;fast&quot;       同步模式 (&quot;fast&quot;, &quot;full&quot;, or &quot;light&quot;)--ethstats value        上报ethstats service  URL (nodename:secret@host:port)--identity value        自定义节点名--lightserv value       允许LES请求时间最大百分比(0 – 90)(默认值:0) --lightpeers value      最大LES client peers数量(默认值:20)--lightkdf              在KDF强度消费时降低key-derivation RAM&amp;CPU使用</code></pre><h3 id="开发者（模式）选项"><a href="#开发者（模式）选项" class="headerlink" title="开发者（模式）选项:"></a>开发者（模式）选项:</h3><pre><code>--dev               使用POA共识网络，默认预分配一个开发者账户并且会自动开启挖矿。--dev.period value  开发者模式下挖矿周期 (0 = 仅在交易时) (默认: 0)</code></pre><h3 id="ETHASH-选项"><a href="#ETHASH-选项" class="headerlink" title="ETHASH 选项:"></a>ETHASH 选项:</h3><pre><code>--ethash.cachedir                        ethash验证缓存目录(默认 = datadir目录内)--ethash.cachesinmem value               在内存保存的最近的ethash缓存个数  (每个缓存16MB ) (默认: 2)--ethash.cachesondisk value              在磁盘保存的最近的ethash缓存个数 (每个缓存16MB) (默认: 3)--ethash.dagdir &quot;&quot;                       存ethash DAGs目录 (默认 = 用户hom目录)--ethash.dagsinmem value                 在内存保存的最近的ethash DAGs 个数 (每个1GB以上) (默认: 1)--ethash.dagsondisk value                在磁盘保存的最近的ethash DAGs 个数 (每个1GB以上) (默认: 2)</code></pre><h3 id="交易池选项"><a href="#交易池选项" class="headerlink" title="交易池选项:"></a>交易池选项:</h3><pre><code>--txpool.nolocals            为本地提交交易禁用价格豁免--txpool.journal value       本地交易的磁盘日志：用于节点重启 (默认: &quot;transactions.rlp&quot;)--txpool.rejournal value     重新生成本地交易日志的时间间隔 (默认: 1小时)--txpool.pricelimit value    加入交易池的最小的gas价格限制(默认: 1)--txpool.pricebump value     价格波动百分比（相对之前已有交易） (默认: 10)--txpool.accountslots value  每个帐户保证可执行的最少交易槽数量  (默认: 16)--txpool.globalslots value   所有帐户可执行的最大交易槽数量 (默认: 4096)--txpool.accountqueue value  每个帐户允许的最多非可执行交易槽数量 (默认: 64)--txpool.globalqueue value   所有帐户非可执行交易最大槽数量  (默认: 1024)--txpool.lifetime value      非可执行交易最大入队时间(默认: 3小时)</code></pre><h3 id="性能调优的选项"><a href="#性能调优的选项" class="headerlink" title="性能调优的选项:"></a>性能调优的选项:</h3><pre><code>--cache value                分配给内部缓存的内存MB数量，缓存值(最低16 mb /数据库强制要求)(默认:128)--trie-cache-gens value      保持在内存中产生的trie node数量(默认:120)</code></pre><h3 id="帐户选项"><a href="#帐户选项" class="headerlink" title="帐户选项:"></a>帐户选项:</h3><pre><code>--unlock value              需解锁账户用逗号分隔--password value            用于非交互式密码输入的密码文件</code></pre><h3 id="API和控制台选项"><a href="#API和控制台选项" class="headerlink" title="API和控制台选项:"></a>API和控制台选项:</h3><pre><code>--rpc                       启用HTTP-RPC服务器--rpcaddr value             HTTP-RPC服务器接口地址(默认值:“localhost”)--rpcport value             HTTP-RPC服务器监听端口(默认值:8545)--rpcapi value              基于HTTP-RPC接口提供的API--ws                        启用WS-RPC服务器--wsaddr value              WS-RPC服务器监听接口地址(默认值:“localhost”)--wsport value              WS-RPC服务器监听端口(默认值:8546)--wsapi  value              基于WS-RPC的接口提供的API--wsorigins value           websockets请求允许的源--ipcdisable                禁用IPC-RPC服务器--ipcpath                   包含在datadir里的IPC socket/pipe文件名(转义过的显式路径)--rpccorsdomain value       允许跨域请求的域名列表(逗号分隔)(浏览器强制)--jspath loadScript         JavaScript加载脚本的根路径(默认值:“.”)--exec value                执行JavaScript语句(只能结合console/attach使用)--preload value             预加载到控制台的JavaScript文件列表(逗号分隔)</code></pre><h3 id="网络选项"><a href="#网络选项" class="headerlink" title="网络选项:"></a>网络选项:</h3><pre><code>--bootnodes value    用于P2P发现引导的enode urls(逗号分隔)(对于light servers用v4+v5代替)--bootnodesv4 value  用于P2P v4发现引导的enode urls(逗号分隔) (light server, 全节点)--bootnodesv5 value  用于P2P v5发现引导的enode urls(逗号分隔) (light server, 轻节点)--port value         网卡监听端口(默认值:30303)--maxpeers value     最大的网络节点数量(如果设置为0，网络将被禁用)(默认值:25)--maxpendpeers value    最大尝试连接的数量(如果设置为0，则将使用默认值)(默认值:0)--nat value             NAT端口映射机制 (any|none|upnp|pmp|extip:&lt;IP&gt;) (默认: “any”)--nodiscover            禁用节点发现机制(手动添加节点)--v5disc                启用实验性的RLPx V5(Topic发现)机制--nodekey value         P2P节点密钥文件--nodekeyhex value      十六进制的P2P节点密钥(用于测试)</code></pre><h3 id="矿工选项"><a href="#矿工选项" class="headerlink" title="矿工选项:"></a>矿工选项:</h3><pre><code>--mine                  打开挖矿--minerthreads value    挖矿使用的CPU线程数量(默认值:8)--etherbase value       挖矿奖励地址(默认=第一个创建的帐户)(默认值:“0”)--targetgaslimit value  目标gas限制：设置最低gas限制（低于这个不会被挖？） (默认值:“4712388”)--gasprice value        挖矿接受交易的最低gas价格--extradata value       矿工设置的额外块数据(默认=client version)</code></pre><h3 id="GAS价格选项"><a href="#GAS价格选项" class="headerlink" title="GAS价格选项:"></a>GAS价格选项:</h3><pre><code>--gpoblocks value      用于检查gas价格的最近块的个数  (默认: 10)--gpopercentile value  建议gas价参考最近交易的gas价的百分位数，(默认: 50)</code></pre><h3 id="虚拟机的选项"><a href="#虚拟机的选项" class="headerlink" title="虚拟机的选项:"></a>虚拟机的选项:</h3><pre><code>--vmdebug        记录VM及合约调试信息</code></pre><h3 id="日志和调试选项"><a href="#日志和调试选项" class="headerlink" title="日志和调试选项:"></a>日志和调试选项:</h3><pre><code>--metrics            启用metrics收集和报告--fakepow            禁用proof-of-work验证--verbosity value    日志详细度:0=silent, 1=error, 2=warn, 3=info, 4=debug, 5=detail (default: 3)--vmodule value      每个模块详细度:以 &lt;pattern&gt;=&lt;level&gt;的逗号分隔列表 (比如 eth/*=6,p2p=5)--backtrace value    请求特定日志记录堆栈跟踪 (比如 “block.go:271”)--debug                     突出显示调用位置日志(文件名及行号)--pprof                     启用pprof HTTP服务器--pprofaddr value           pprof HTTP服务器监听接口(默认值:127.0.0.1)--pprofport value           pprof HTTP服务器监听端口(默认值:6060)--memprofilerate value      按指定频率打开memory profiling    (默认:524288)--blockprofilerate value    按指定频率打开block profiling    (默认值:0)--cpuprofile value          将CPU profile写入指定文件--trace value               将execution trace写入指定文件</code></pre><h3 id="WHISPER实验选项"><a href="#WHISPER实验选项" class="headerlink" title="WHISPER实验选项:"></a>WHISPER实验选项:</h3><pre><code>--shh                        启用Whisper--shh.maxmessagesize value   可接受的最大的消息大小 (默认值: 1048576)--shh.pow value              可接受的最小的POW (默认值: 0.2)</code></pre><h3 id="弃用选项："><a href="#弃用选项：" class="headerlink" title="弃用选项："></a>弃用选项：</h3><pre><code>--fast     开启快速同步--light    启用轻客户端模式</code></pre><h3 id="其他选项"><a href="#其他选项" class="headerlink" title="其他选项:"></a>其他选项:</h3><pre><code>–help, -h    显示帮助</code></pre><h3 id="版权："><a href="#版权：" class="headerlink" title="版权："></a>版权：</h3><pre><code>Copyright 2013-2017 The go-ethereum Authors</code></pre><h2 id="翻译说明"><a href="#翻译说明" class="headerlink" title="翻译说明"></a>翻译说明</h2><p>   有些参数翻译可能有不准确的地方，请大家指正。<br>   原文会尽量随geth升级保持更新，原始链接：<a href="https://learnblockchain.cn/2017/11/29/geth_cmd_options">https://learnblockchain.cn/2017/11/29/geth_cmd_options/</a></p><p><a href="https://learnblockchain.cn/">深入浅出区块链</a> - 系统学习区块链，打造最好的区块链技术博客。<br>我的<strong><a href="https://t.xiaomiquan.com/RfAu7uj" target="_blank" rel="noopener">知识星球</a></strong>为各位解答区块链技术问题，欢迎加入讨论。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Geth在以太坊智能合约开发中最常用的工具（必备开发工具），一个多用途的命令行工具。&lt;br&gt;熟悉Geth可以让我们有更好的效率，大家可收藏起来作为Geth命令用法手册。 本文主要是对geth help的翻译，基于最新的geth 1.7.3-stable版本。&lt;/p&gt;
    
    </summary>
    
      <category term="以太坊" scheme="https://learnblockchain.cn/categories/ethereum/"/>
    
      <category term="geth" scheme="https://learnblockchain.cn/categories/ethereum/geth/"/>
    
    
      <category term="Geth命令用法" scheme="https://learnblockchain.cn/tags/Geth%E5%91%BD%E4%BB%A4%E7%94%A8%E6%B3%95/"/>
    
      <category term="Geth命令参数详解" scheme="https://learnblockchain.cn/tags/Geth%E5%91%BD%E4%BB%A4%E5%8F%82%E6%95%B0%E8%AF%A6%E8%A7%A3/"/>
    
      <category term="Geth手册" scheme="https://learnblockchain.cn/tags/Geth%E6%89%8B%E5%86%8C/"/>
    
  </entry>
  
</feed>
