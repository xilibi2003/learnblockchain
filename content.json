{"meta":{"title":"深入浅出区块链","subtitle":"系统学习区块链技术","description":"打造最好的区块链技术博客","author":"Tiny熊","url":"https://learnblockchain.cn"},"pages":[{"title":"","date":"2017-10-24T10:16:10.000Z","updated":"2018-03-25T13:47:28.702Z","comments":true,"path":"about/index.html","permalink":"https://learnblockchain.cn/about/index.html","excerpt":"","text":"深入浅出区块链深入浅出区块链目标做最好的区块链技术分享博客，希望能为推动国内区块链技术尽绵薄之力。本博客完全开源、开放，鼓励分享，转载请注明出处。 我的小专栏经过慎重考虑，决定推出付费订阅专栏：小专栏地址，当然本博客也会继续提供免费版，进阶（高阶及实战等）内容优先发布（或只发布）在我的专栏。 为什么做这个决定？因为虽然可以依靠兴趣纯免费提供原创技术文章，但这个事情很耗精力，难以坚持稳定输出，所以准备付费方式，让这样可以投入有些许回报，也让自己可以坚持，以帮助更多人掌握区块链开发技术。 随文章的增加会不定期的提高订阅价格，非常建议对区块链技术有兴趣的同学尽早订阅，相比其他付费学习，我的专栏性价比很高。 深入浅出区块链知识星球（小密圈）很多朋友加我微信或在公众号留言，问我区块链技术、学习等问题。很抱歉没办法一一回复大家。 请有问题的同学加入知识星球向我提问，提问不限于区块链技术，任何关于学习，互联网技术，团队管理等问题都可以，不保证能够回答上各位的问题，但会毫无保留的把我的经验告诉大家。 加入知识星球是需要付费的，目前149元/年（通过这个方式可以过滤掉杂音，入群不退费），请大家谨慎加入，希望加入知识星球都是热爱学习，热爱学习技术的同学，一起交流。2018-01-13更新：区块链技术付费交流微信群已建立，有需要加入的同学请加微信：xlbxiong， 微信群与小密圈同价，加入知识星球可自行选择是否加入微信群，不在另收费。 贡献区块链涉及的技术太多，希望有兴趣的朋友能一起来参与进来写博客，把这个站打造成所有区块链开发人员的博客。博客Github地址 参与可以获得什么技术，技术，还是技术如果3年后，我们能成为区块链技术第一博客，那么你就是第一博客的创建者。 关于作者 熊丽兵（网名: Tiny熊）写过代码，带过团队，抱过娃。北航硕士毕业，先后加入创新工场（点心）、猎豹移动、创业。 被打劫的强盗码农一枚，喜欢健身，国漫。目前在一家金融公司工作，个人全面拥抱区块链技术。"},{"title":"深入浅出区块链-文章分类","date":"2017-10-24T13:14:00.000Z","updated":"2017-11-03T05:31:44.000Z","comments":false,"path":"categories/index.html","permalink":"https://learnblockchain.cn/categories/index.html","excerpt":"","text":""},{"title":"视频课程介绍及招募体验师","date":"2018-07-24T07:17:12.000Z","updated":"2018-07-24T15:44:48.828Z","comments":true,"path":"course/index.html","permalink":"https://learnblockchain.cn/course/index.html","excerpt":"","text":"区块链视频课程Tiny熊和朋友们成立了登链学院（公众号同名），为了更好的普及区块链技术，也为了这个事情能持续的做下去，所以我们选择用商业公司来运作，在推广普及区块链技术的同时，也能小有盈利以改善家人的生活。 我们现在推出的视频课程，有： 区块链入门-零基础搞懂区块链这是0基础入门课，还不懂区块链是什么的同学可以从这个课开始学。课程可以在登链学院公众号回复“01”获取，PC可以点击视频链接直接前往学习，也可先看看课程介绍。 深入详解以太坊智能合约语言Solidity正在录制中，这门课将会是市面上最深入的讲解智能合约语言Solidity的视频教程。 通过代币学以太坊智能合约开发这门课程囊括发行代币（token），众筹的所有知识点，同时通过代币的开发，引申出了很多智能合约开发知识点，不管是想要发行代币还是学习智能合约都是不可多得好教程。课程可以在登链学院公众号回复“ECR20”获取，PC可以点击视频链接直接前往学习，也可先看看课程介绍。 更多课程请期待… 招募课程体验师先说一下我们什么招募课程体验师，原因是这样的，在有一些课程中，我自己觉的已经把问题讲的比较清楚，可是还是有学院在微信中问我问题，在经历好几个提问之后，我发现每个人知识结构的不一样，对问题的理解是不一样的，有一些我认为是基本知识点而没有讲解。 经过思考之后，我感觉这类的问题可能有不少，估计有更多的问题因为学员不愿意反馈或者反馈渠道不通畅而发现不了，而这样我们的课程就错过了很多改进的机会。 登链做为一家认认真真做区块链技术培训的学院，我们的使命是让所有程序员都懂区块链，显然上面的问题和我们的使命不符，因此我们需要一些真正愿意学习区块链技术的小伙伴来一起参与帮助我们改进课程， 不管你现在的水平如何，只要愿意学，我们都欢迎你来参与。 参与改进课程内容包括： 常规排错：是否有显示不清（尤其是代码），声音不清。 指出课程中没有听明白的地方 说明你认为需要改进的地方 其他的改进讨论，如定价、课程介绍、海报等 能收获什么 登链学院所有课程免费学习包含未来的课程 和讲师Tiny熊面对面交流 工作机会优先推荐 有贡献的体验师，会在课程及博客的贡献名单列出 对你的要求当然，我们也会对你有一点要求，有两点： 要求所有的课程都必须认真完整的学完 每个课程至少提出一个问题 配合课程助理的一些简单的活动 如何加入有兴趣的参与的同学，可以加课程助理的微信： upchainedu 申请， 暗号是：“课程体验师”，通过之后，课程助理会拉大家进课程体验师群。参与的细则课程助理会发布在群里，不过体验师参与的原则是: 体验师需要先自己购买学习，学完及提问后，课程助理返学费。后面如果我们有贵一点的课，会先给大家发优惠劵购买课程。 最后很期待大家的参与，也感谢要参与的同学，让我们一起做全国做好的区块链技术培训学院，让所有程序员都懂区块链。"},{"title":"深入浅出区快链-文章标签","date":"2017-10-24T13:11:50.000Z","updated":"2017-11-03T05:31:44.000Z","comments":false,"path":"tags/index.html","permalink":"https://learnblockchain.cn/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"什么是EOS（柚子）","slug":"whatiseos","date":"2018-07-17T06:25:44.000Z","updated":"2018-07-18T07:58:41.376Z","comments":true,"path":"2018/07/17/whatiseos/","link":"","permalink":"https://learnblockchain.cn/2018/07/17/whatiseos/","excerpt":"是时候给写写EOS了，现在EOS主网已经上线，尽管我个人不是很喜欢EOS项目（不过也一直在关注EOS），但是不可否认EOS这个争议性很大的项目给区块链世界带来的变化。","text":"是时候给写写EOS了，现在EOS主网已经上线，尽管我个人不是很喜欢EOS项目（不过也一直在关注EOS），但是不可否认EOS这个争议性很大的项目给区块链世界带来的变化。 写在前面阅读本文前，如果了解过比特币及以太坊，可以更好的理解本文。欢迎订阅专栏：区块链技术指引你从头开始学区块链技术。 本文出现EOS是指EOS.io公链项目，不是指以太坊上的EOS Token。 EOS 简介EOS: Enterprise Operation System 中文意思为：商业级区块链操作系统。 尽管以太坊创造性引入智能合约概念，极大的简化了区块链应用的开发，但以太坊平台依然有一个很大的限制，就是交易确认时间及交易吞吐量比较小，从而严重影响了以太坊进行商业应用。 交易吞吐量有一个专门的词：TPS （transaction per second 每秒的交易量） 比特币的TPS 是大概7，并且最少几十分钟交易才能被确认，以太坊的TPS大概是20左右，交易的确认一般需要几分钟的时间。不过比特币以太坊也在不断进化以提高TPS，比如比特币的闪电网络，以太坊的Sharding技术（分片）以及Plasma技术（分层）。 EOS 项目的目标是建立可以承载商业级智能合约与应用的区块链基础设施，成为区块链世界的“底层操作系统”。EOS通过石墨烯技术解决延迟和数据吞吐量问题，TPS可达到数千，交易的确认时间也只有数秒。同时声称未来使用并行链的方式，最高可以达到数百万TPS。 EOS 设计了一套账户权限管理系统，EOS不再使用的地址作为账户，可以直接使用字符作为账户名，并设计了一套的账户权限体系。 此外，在 EOS 上转账交易及运行智能合约不需要消耗 EOS代币。而是EOS 系统当中，抵押代币获取对应的资源，来执行相应交易，在EOS运行程序完全免费的说是不准确的。 值的一提的是EOS项目其ICO也是基于以太坊ERC20 Token进行的，其ICO 时间长达355天，作为一个当时还未上线的项目，融资额达到40亿美元是前所未有。 充满争议的技术天才BMEOS的主要开发者为丹尼尔·拉瑞莫（Daniel Larimer）, 绰号BM(GitHub的昵称：ByteMaster), 它是EOS的项目方，BlockOne公司的CTO。和V神一样，也是一个神奇的人物，网络上两人因理念不合有多次论战。BM有一句牛B 轰轰的话：我终生的使命，是致力于找到一些加密经济的解决方案，给所有人的财产、自由、平等带来保障。 BM成功创立过三个区块链项目：BitShares、Steem 以及EOS，是一个技术天才，也是一个多变的人。2009年的BM也准备的数字货币一展身手，在其研究比特币之后，2010年BM提出了一些比特币的问题，并想要改进，结果比特币的创始人中本聪（Satoshi Nakamoto）怼会了他“If you don’t believe me or don’t get it, I don’t have time to try to convince you, sorry.”（懂不懂随你，我可没时间理你）。于是BM开始着手创建自己的区块链项目，这就是2013年发布的 BitShares 比特股，世界上第一个数字货币去中心化交易所。 BitShares在2014年上线时，是当时的明星项目，也由于bug太多、糟糕的体验以及BM在进行个别版本升级的时候都不提供向下兼容，用户逐渐流失，更要命的是，BM利用自己超过1/3的记账节点，在没有达成社区共识的情况下，强行分叉增发了BitShares发行总量。尽管BM在技术提供了改进，发布了石墨烯工具集，不过最终社区投票决定让BM离开了BitShares。 离开BitShares的BM，于2016年创立了区块链项目Steem，去中心化社交网站Steemit就是基于Steem创建，在Steemit的运营期间，BM和Steemit的CEO Ned有过多次口水战。在2017年，BM离开了自己创建的Steem项目（也许除了BM自己，没有人能知道他离开Steem的真实原因），选择与布鲁默联合创办了BlockOne公司打造EOS项目。 石墨烯（Graphene）与 DPOS和BitShares、Steem 一样，EOS底层使用的也是石墨烯技术，石墨烯是一个开源的区块链底层库，也出自BM之手，它采用的是 DPOS（Delegated Proof-of-Stake 股份授权证明机制 ）的共识机制。在比特币及以太坊网络中，任何人都可以参与记账，而DPOS为了提高出块速度TPS，限制了参与记账了人数，在DPOS中，记账者不在称为矿工，而是改称为见证人 Witness，现在EOS中，又有一个新词：Block Producer，简称BP，大家翻译为超级节点（本文中依旧会使用见证人这个词，超级节点更像是一个市场营销用词）。 在EOS中，见证人的个数是21个，BitShares中是101个，BitShares的出块时间打开是 1.5秒，在EOS中，出块时间提高到了0.5秒。 和Pow及Pos共识机制矿工可以自由选择参与挖矿不同，DPOS下节点需要参与见证人选举，只有赢得选举的节点才能负责出块，在EOS中，赢得选举21个节点见证人轮流出块。另外还有100个备用见证人（候选节点），在21个见证人出现问题后做替补。EOS的发行总量是10亿， 见证人在完成打包交易区块后，可以领取到区块的奖励，区块的奖励来自对发行量的通胀增发，通胀率每年接近5%。 BM特色的去中心化我个人理解的区块链，它最大的革命性就是他的中立性，其运行不应该受到任何人的干扰，在POW共识中，矿工、项目方（开发者）以及交易方他们是相互独立的存在。 在EOS中，BM本人拥有巨量的选票，他可以在一定程度上左右见证人的选举，同时BM还为EOS制定了宪法，要求所有的见证人必须遵照宪法。因此BM某种程度上可以左右EOS系统的运行。 本文是个人对EOS的理解，受我自己视野局限也许理解有偏差，欢迎大家批准指正，我的微信： xlbxiong。 EOS相关资料： EOS开发者资源 官方网站 Github 代码 深入浅出区块链 - 系统学习区块链，打造最好的区块链技术博客。我的知识星球为各位解答区块链技术问题，欢迎加入讨论。","categories":[{"name":"EOS","slug":"EOS","permalink":"https://learnblockchain.cn/categories/EOS/"}],"tags":[{"name":"EOS入门","slug":"EOS入门","permalink":"https://learnblockchain.cn/tags/EOS入门/"},{"name":"柚子","slug":"柚子","permalink":"https://learnblockchain.cn/tags/柚子/"}]},{"title":"搭建智能合约开发环境Remix IDE及使用","slug":"remix-ide","date":"2018-06-07T02:56:04.000Z","updated":"2018-07-23T15:04:58.576Z","comments":true,"path":"2018/06/07/remix-ide/","link":"","permalink":"https://learnblockchain.cn/2018/06/07/remix-ide/","excerpt":"目前开发智能的IDE， 首推还是Remix, 而Remix官网, 总是由于各种各样的（网络）原因无法使用，本文就来介绍一下如何在本地搭建智能合约开发环境remix-ide并介绍Remix的使用。","text":"目前开发智能的IDE， 首推还是Remix, 而Remix官网, 总是由于各种各样的（网络）原因无法使用，本文就来介绍一下如何在本地搭建智能合约开发环境remix-ide并介绍Remix的使用。 写在前面Remix 是以太坊智能合约编程语言Solidity IDE，阅读本文前，你应该对以太坊、智能合约有所了解，如果还不了解，建议先看以太坊是什么。 Remix IDE 介绍Remix IDE 是一款基于浏览器的IDE，跟有些开发聊的时候，发现有一些同学对浏览器的IDE，有一些偏见，其实Atom编辑器就是基于web技术开发的一款编辑器（Atom可以看做一个没有地址栏的浏览器），其实基于浏览器的IDE，有一个很大的好处就是不用安装，打开即用。 Remix IDE的功能全面（传统IDE有的功能这里都有），比如： 代码提示补全，代码高亮 代码警告、错误提示 运行日志输出 代码调试 … Remix IDE 安装 更新： Remix 现在提供了一个APP, 叫Remix APP， 如果是Mac 电脑，可以直接使用其提供的发布包，地址为：https://github.com/horizon-games/remix-app/releases 如果你有很好的网络环境，可以直接访问Remix官网。要不能还是还是像我一样老老实实把Remix IDE安装在本地，我发现要想成功安装选择对应的版本很关键，具体的版本要求如下： 123456$ node --versionv7.10.1$ npm --version4.2.0$ nvm --version0.33.11 nvm 安装nvm 是一个node 版本工具，我们可以使用nvm来安装不同版本的node。nvm 官方安装方法如下： 命令行中输入： 1curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.33.11/install.sh | bash 在当前用户profile文件，如（~/.bash_profile, ~/.zshrc, ~/.profile, or ~/.bashrc）添加加载nvm的脚本： 12export NVM_DIR=\"$HOME/.nvm\"[ -s \"$NVM_DIR/nvm.sh\" ] &amp;&amp; \\. \"$NVM_DIR/nvm.sh\" 重启下命令行，输入nvm 试试，应该可以看到 nvm 命令的帮助 使用nvm 安装node因为Remix IDE 要求使用node 7.10.1, 命令行输入一下命令进行安装： 1nvm install 7 安装完成之后，使用node –version 和 npm –version检查下版本号，是否和刚刚列出版本要求一致，在版本一值的qing 命令行安装Remix ide方法1直接使用npm安装，这也是我安装使用的方法。12npm install remix-ide -gremix-ide 如果出现错误：Error: EACCES: permission denied, access ‘/usr/local/lib/node_modules’可以尝试用以下方法解决：1sudo chown -R $(whoami) $(npm config get prefix)/&#123;lib/node_modules,bin,share&#125; 如果我们使用的是正确的node 和npm 版本的话，应该都可以安装成功，安装成功之后，remix-ide命令用来启动ide. 方法2remix-ide的github 上还提供了另一个方法进行安装，通过clone 代码来安装，方法如下： 12345git clone https://github.com/ethereum/remix-ide.gitcd remix-idenpm installnpm run setupremix # this will clone https://github.com/ethereum/remix for you and link it to remix-idenpm start Remix ide 使用Remix IDE 默认是使用8080端口启动的，启动之后在浏览器打开：http://localhost:8080/, 如图： 和大多数IDE一样，最左边是文件浏览，中间是代码编辑区域，右边是功能区域，下边是日志区域。在右侧的功能区域，常用的是Compile、Run及Debuger几个标签页（Tab）。 在Compile页，会动态的显示当前编辑区域合约的编译信息，如显示错误和警告。编译的直接码信息及ABI接口可以通过点击Details查看到。在这篇文章里 也有截图说明。在Run页，可以部署合约，以及调用合约函数等，使用非常简单，我们前面也有多篇文章讲解。Debuger页在下面调试一节单独讲解。 Remix ide 加载本地磁盘文件这是一个非常用的功能，但发现使用的人非常少，通过加载本地磁盘文件，就可以方便代码管理工具（如 git）管理我们的合约代码。我详细介绍下如何这个功能怎么使用？ 使用在线版本的Remix可以使用这个功能， 不过需要安装一下remixd, 安装使用命令npm install -g remixd。 在需要的本地合约代码的目录下启动remix-ide, Remix IDE 会自动把当前目录做为共享目录。如果是使用在线的Remix，需要使用命令remixd -s shared-folder 来指定共享目录。 加载共享目录，在文件浏览区域上有，有这样一个图标，他用来加载本地共享目录，如图： 调试在合约编写过程中，合约调试是必不可少的一部分，为了模拟调试的过程，我故意在代码中加入一ge错误的逻辑代码如下： 1234567891011121314pragma solidity ^0.4.0;​contract SimpleStorage &#123; uint storedData; function set(uint x) public &#123; storedData += x; // 错误的，多加了一个加号 &#125;​ function get() public constant returns (uint) &#123; return storedData; &#125;&#125; 加入了错误的逻辑之后，我第2次调用set函数，合约状态变量的值，可能会出错（如果第一次不是用参数0去调用的话）。注意如果需要调试合约，在部署合约的环境应该选择：JavaScript VM。 开始调试在我们每次执行一个交易（不管是方式调用还是函数执行）的时候，在日志都会输出一条记录，如图： 点击上图中的“Debug”按钮，在Remix右侧的功能区域会切换到调试面板，如下图：调试过程过程中，有下面几项需要重点关注： Transactions: 可以查看交易及交易的执行过程，并且提供了7个调试的按钮，如下图： 为了方便介绍，我为每个按钮编了号，每个按钮的含义是： 后退一步（不进入函数内部） 后退一步（进入函数内部） 前进一步（进入函数内部） 前进一步（不进入函数内部） 跳到上一个断点 跳出当前调用 跳到下一个断点 Solidity Locals：显示当前上下文的局部变量的值， 如图： Solidity State： 显示当前执行合约的状态变量，如下图: 在本例中，我们跟踪运行步骤的时候，可以看到局部变量的值为2，赋值给状态变量之后，状态变量的值更改为了3，所以可以判断运行当前语句的时候出错了。 Step detail： 显示当前步骤的gas详情等，如下图: 设置断点这部分为小专栏读者准备，欢迎订阅小专栏区块链技术查看。 参考链接 remix-ide github Remix Document 深入浅出区块链 - 系统学习区块链，打造最好的区块链技术博客。如果你学习区块链中遇到问题，欢迎加入知识星球深入浅出区块链问答社区，作为星友福利，星友可加入我创建的区块链技术群，群内已经聚集了300多位区块链技术牛人和爱好者。","categories":[{"name":"以太坊","slug":"ethereum","permalink":"https://learnblockchain.cn/categories/ethereum/"},{"name":"智能合约","slug":"ethereum/智能合约","permalink":"https://learnblockchain.cn/categories/ethereum/智能合约/"}],"tags":[{"name":"IDE","slug":"IDE","permalink":"https://learnblockchain.cn/tags/IDE/"}]},{"title":"Solidity 教程系列11 - 视图函数、虚函数讲解","slug":"solidity-functions","date":"2018-05-17T14:16:29.000Z","updated":"2018-05-17T15:23:43.135Z","comments":true,"path":"2018/05/17/solidity-functions/","link":"","permalink":"https://learnblockchain.cn/2018/05/17/solidity-functions/","excerpt":"Solidity 教程系列第11篇 - Solidity 视图函数、虚函数讲解。Solidity 系列完整的文章列表请查看分类-Solidity。","text":"Solidity 教程系列第11篇 - Solidity 视图函数、虚函数讲解。Solidity 系列完整的文章列表请查看分类-Solidity。 写在前面Solidity 是以太坊智能合约编程语言，阅读本文前，你应该对以太坊、智能合约有所了解，如果你还不了解，建议你先看以太坊是什么 欢迎订阅区块链技术专栏阅读更全面的分析文章。 视图函数（View Functions）一个函数如果它不修改状态变量，应该声明为view函数，不过下面几种情况认为是修改了状态： 写状态变量 触发事件（events） 创建其他的合约 call调用附加了以太币 调用了任何没有view或pure修饰的函数 使用了低级别的调用（low-level calls） 使用了包含特定操作符的内联汇编 看一个例子： 1234567891011121314pragma solidity ^0.4.16;contract C &#123; uint public data = 0; function f(uint a, uint b) public view returns (uint) &#123; return a * (b + 42) + now; &#125; // 错误做法，虽然可以编译通过 function df(uint a) public view &#123; data = a; &#125;&#125; 有几个地方需要注意一下： 声明为view 和声明为constant是等价的，constant是view的别名，constant在计划Solidity 0.5.0版本之后会弃用（constant这个词有歧义，view 也更能表达返回值可视）。 访问函数都被标记为view。 当前编译器并未强制要求声明为view，但建议大家对于不会修改状态的函数的标记为view。 纯函数（Pure Functions）函数可以声明为view，表示它即不读取状态，也不修改状态，除了上一节介绍的几种修改状态的情况，以下几种情况被认为是读取了状态： 读状态变量 访问了 this.balance 或 \\.balance 访问了block, tx, msg 的成员 (msg.sig 和 msg.data除外). 调用了任何没有pure修饰的函数 使用了包含特定操作符的内联汇编 看一个例子： 1234567pragma solidity ^0.4.16;contract C &#123; function f(uint a, uint b) public pure returns (uint) &#123; return a * (b + 42); &#125;&#125; 尽管view 和 pure 修饰符编译器并未强制要求使用，view 和 pure 修饰也不会带来gas 消耗的改变，但是更好的编码习惯让我们跟容易发现智能合约中的错误。 参考文献官方文档-函数 欢迎来知识星球提问，星球内已经聚集了200多位区块链技术爱好者。深入浅出区块链 - 系统学习区块链，打造最好的区块链技术博客。","categories":[{"name":"以太坊","slug":"ethereum","permalink":"https://learnblockchain.cn/categories/ethereum/"},{"name":"智能合约","slug":"ethereum/智能合约","permalink":"https://learnblockchain.cn/categories/ethereum/智能合约/"},{"name":"Solidity","slug":"ethereum/智能合约/Solidity","permalink":"https://learnblockchain.cn/categories/ethereum/智能合约/Solidity/"}],"tags":[{"name":"智能合约","slug":"智能合约","permalink":"https://learnblockchain.cn/tags/智能合约/"},{"name":"Solidity","slug":"Solidity","permalink":"https://learnblockchain.cn/tags/Solidity/"}]},{"title":"详解 Solidity 事件Event - 完全搞懂事件的使用","slug":"solidity-event","date":"2018-05-09T12:37:03.000Z","updated":"2018-05-10T13:49:31.287Z","comments":true,"path":"2018/05/09/solidity-event/","link":"","permalink":"https://learnblockchain.cn/2018/05/09/solidity-event/","excerpt":"很多同学对Solidity 中的Event有疑问，这篇文章就来详细的看看Solidity 中Event到底有什么用？","text":"很多同学对Solidity 中的Event有疑问，这篇文章就来详细的看看Solidity 中Event到底有什么用？ 写在前面Solidity 是以太坊智能合约编程语言，阅读本文前，你应该对以太坊、智能合约有所了解，如果你还不了解，建议你先看以太坊是什么，另外本文在监听合约事件是对上一篇Web3与智能合约交互实战进行补充，如果阅读了上一篇可以更好的理解本文。 什么是事件Evnet事件是以太坊虚拟机(EVM)日志基础设施提供的一个便利接口。当被发送事件（调用）时，会触发参数存储到交易的日志中（一种区块链上的特殊数据结构）。这些日志与合约的地址关联，并记录到区块链中.来捋这个关系：区块链是打包一系列交易的区块组成的链条，每一个交易“收据”会包含0到多个日志记录，日志代表着智能合约所触发的事件。 在DAPP的应用中，如果监听了某事件，当事件发生时，会进行回调。不过要注意：日志和事件在合约内是无法被访问的，即使是创建日志的合约。 在Solidity 代码中，使用event 关键字来定义一个事件，如： 1event EventName(address bidder, uint amount); 这个用法和定义函数式一样的，并且事件在合约中同样可以被继承。触发一个事件使用emit(说明，之前的版本里并不需要使用emit)，如： 1emit EventName(msg.sender, msg.value); 触发事件可以在任何函数中调用，如： 12345function testEvent() public &#123; // 触发一个事件 emit EventName(msg.sender, msg.value); &#125; 监听事件通过上面的介绍，可能大家还是不清楚事件有什么作用，如果你跟过Web3与智能合约交互实战这篇文章，你会发现点击”Updata Info”按钮之后，虽然调用智能合约成功，但是当前的界面并没有得到更新。使用事件监听，就可以很好的解决这个问题，让看看如何实现。 修改合约，定义事件及触发事件先回顾一下合约代码： 12345678910111213141516pragma solidity ^0.4.21;contract InfoContract &#123; string fName; uint age; function setInfo(string _fName, uint _age) public &#123; fName = _fName; age = _age; &#125; function getInfo() public constant returns (string, uint) &#123; return (fName, age); &#125; &#125; 首先，需要定义一个事件： 1234event Instructor( string name, uint age ); 这个事件中，会接受两个参数：name 和 age , 也就是需要跟踪的两个信息。 然后，需要在setInfo函数中，触发Instructor事件，如： 12345function setInfo(string _fName, uint _age) public &#123; fName = _fName; age = _age; emit Instructor(_fName, _age);&#125; 在Web3与智能合约交互实战, 点击”Updata Info”按钮之后，会调用setInfo函数，函数时触发Instructor事件。 使用Web3监听事件，刷新UI现在需要使用Web3监听事件，刷新UI。先回顾下之前的使用Web3和智能合约交互的代码： 1234567891011121314151617181920212223242526272829&lt;script&gt; if (typeof web3 !== 'undefined') &#123; web3 = new Web3(web3.currentProvider); &#125; else &#123; // set the provider you want from Web3.providers web3 = new Web3(new Web3.providers.HttpProvider(\"http://localhost:7545\")); &#125; web3.eth.defaultAccount = web3.eth.accounts[0]; var infoContract = web3.eth.contract(ABI INFO); var info = infoContract.at('CONTRACT ADDRESS'); info.getInfo(function(error, result)&#123; if(!error) &#123; $(\"#info\").html(result[0]+' ('+result[1]+' years old)'); console.log(result); &#125; else console.error(error); &#125;); $(\"#button\").click(function() &#123; info.setInfo($(\"#name\").val(), $(\"#age\").val()); &#125;);&lt;/script&gt; 现在可以不需要 info.getInfo()来获取信息，而改用监听事件获取信息，先定义一个变量引用事件： 1var instructorEvent = info.Instructor(); 然后使用.watch()方法来添加一个回调函数： 12345678instructorEvent.watch(function(error, result) &#123; if (!error) &#123; $(\"#info\").html(result.args.name + ' (' + result.args.age + ' years old)'); &#125; else &#123; console.log(error); &#125; &#125;); 代码更新之后，可以在浏览器查看效果，这是点击”Updata Info”按钮之后，会及时更新界面，如图： 完整的代码请订阅小专栏区块链技术查看。 事件高级用法-过滤器有时我们会有这样的需求：获取当前所有姓名及年龄记录，或者是，要过滤出年龄28岁的记录，应该如何做呢？以及另外一个常见的场景：想要获取到代币合约中所有的转账记录，也同样需要使用事件过滤器功能，这部分内容请大家订阅小专栏区块链技术阅读。 参考文章https://coursetro.com/posts/code/100/Solidity-Events-Tutorial---Using-Web3.js-to-Listen-for-Smart-Contract-Eventshttps://github.com/ethereum/wiki/wiki/JavaScript-API#contract-events 深入浅出区块链 - 系统学习区块链，打造最好的区块链技术博客。如果你想和我有密切的联系，欢迎加入知识星球深入浅出区块链，我会在星球为大家解答技术问题，作为星友福利，星友可加入我创建的区块链技术群，群内已经聚集了200多位区块链技术牛人和爱好者。","categories":[{"name":"以太坊","slug":"ethereum","permalink":"https://learnblockchain.cn/categories/ethereum/"},{"name":"智能合约","slug":"ethereum/智能合约","permalink":"https://learnblockchain.cn/categories/ethereum/智能合约/"}],"tags":[{"name":"智能合约","slug":"智能合约","permalink":"https://learnblockchain.cn/tags/智能合约/"},{"name":"Solidity","slug":"Solidity","permalink":"https://learnblockchain.cn/tags/Solidity/"},{"name":"Event","slug":"Event","permalink":"https://learnblockchain.cn/tags/Event/"},{"name":"web3","slug":"web3","permalink":"https://learnblockchain.cn/tags/web3/"}]},{"title":"智能合约最佳实践 之 Solidity 编码规范","slug":"solidity-style-guide","date":"2018-05-04T02:22:08.000Z","updated":"2018-05-07T06:42:11.127Z","comments":true,"path":"2018/05/04/solidity-style-guide/","link":"","permalink":"https://learnblockchain.cn/2018/05/04/solidity-style-guide/","excerpt":"每一门语言都有其相应的编码规范， Solidity 也一样， 下面官方推荐的规范及我的总结，供大家参考，希望可以帮助大家写出更好规范的智能合约。","text":"每一门语言都有其相应的编码规范， Solidity 也一样， 下面官方推荐的规范及我的总结，供大家参考，希望可以帮助大家写出更好规范的智能合约。 命名规范避免使用小写的l，大写的I，大写的O 应该避免在命名中单独出现，因为很容易产生混淆。 合约、库、事件、枚举及结构体命名 合约、库、事件及结构体命名应该使用单词首字母大写的方式，这个方式也称为：帕斯卡命名法或大驼峰式命名法，比如：SimpleToken， SmartBank， CertificateHashRepository，Player。 函数、参数、变量及修饰器函数、参数、变量及修饰器应该使用首单词小写后面单词大写的方式，这个方式也称为：（小）驼峰式命名法，是一种混合大小写的方式，如： 函数名应该如：getBalance，transfer，verifyOwner，addMember。 参数和变量应该如：initialSupply，senderAddress，account，isPreSale。 修饰器应该如：onlyAfter，onlyOwner。 代码格式相关缩进使用空格（spaces）而不是Tab, 缩进应该是4个空格 空行合约之间应该有空行，例如： 12345678910111213contract A &#123; ...&#125; contract B &#123; ...&#125; contract C &#123; ...&#125; 而不是使用： 12345678910contract A &#123; ...&#125;contract B &#123; ...&#125; contract C &#123; ...&#125; 函数之间应该有空行，例如： 123456789contract A &#123; function spam() public &#123; ... &#125; function ham() public &#123; ... &#125;&#125; 没有实现的话，空行可以省去，如： 1234contract A &#123; function spam() public; function ham() public;&#125; 而不是： 12345678contract A &#123; function spam() public &#123; ... &#125; function ham() public &#123; ... &#125;&#125; 左括号应该跟定义在一行定义包括合约定义、函数定义、库定义、结构体定义等等，例如推荐使用： 123456 contract Coin &#123; struct Bank &#123; address owner; uint balance; &#125;&#125; 而不是： 1234567contract Coin&#123; struct Bank &#123; address owner; uint balance; &#125;&#125; 左括号应该跟条件控制在一行在使用if, else, while, for 时，推荐的写法是： 1234567if (...) &#123; ...&#125;for (...) &#123; ...&#125; 而不是： 12345678910if (...)&#123; ...&#125;while(...)&#123;&#125;for (...) &#123; ...;&#125; 如果控制语句内只有一行，括号可省略，如： 12if (x &lt; 10) x += 1; 但像下面一个语句有多方就不能省略，如： 12345if (x &lt; 10) someArray.push(Coin(&#123; name: 'spam', value: 42 &#125;)); 表达式内的空格 一个单行的表达里，在小括号、中括号、大括号里应该避免不必要的空格，例如推荐使用： 1spam(ham[1], Coin(&#123;name: \"ham\"&#125;)); 而不是： 1spam( ham[ 1 ], Coin( &#123; name: \"ham\" &#125; ) ); 有一种例外是，结尾的括号跟在结束的分号后面， 应该加一个空格，如下面的方式也是推荐的： 1function singleLine() public &#123; spam(); &#125; 分号；前不应该有空格，例如推荐使用： 1function spam(uint i, Coin coin) public; 而不是： 1function spam(uint i , Coin coin) public ; 不要为对齐添加不必要的空格，例如推荐使用： 123x = 1;y = 2;long_variable = 3; 而不是： 123x = 1;y = 2;long_variable = 3; 回退函数不应该有空格，例如推荐使用： 123456789101112function() public &#123; ...&#125;``` 而不是：```jsfunction () public &#123; ...&#125; 控制每一行长度每行不应该太长，最好在79（或99）个字符以内，函数的参数应该是单独的行，且只有一个缩进，例如推荐的方式是： 12345thisFunctionCallIsReallyLong( longArgument1, longArgument2, longArgument3); 而不是： 12345678910111213141516171819202122232425thisFunctionCallIsReallyLong(longArgument1, longArgument2, longArgument3);thisFunctionCallIsReallyLong(longArgument1, longArgument2, longArgument3);thisFunctionCallIsReallyLong( longArgument1, longArgument2, longArgument3);thisFunctionCallIsReallyLong(longArgument1,longArgument2,longArgument3);thisFunctionCallIsReallyLong( longArgument1, longArgument2, longArgument3); 对应的赋值语句应该是这样写： 123456 thisIsALongNestedMapping[being][set][to_some_value] = someFunction( argument1, argument2, argument3, argument4); 而不是： 1234thisIsALongNestedMapping[being][set][to_some_value] = someFunction(argument1, argument2, argument3, argument4); 事件定义也应该遵循同样的原则，例如应该使用： 123456789101112131415event LongAndLotsOfArgs( adress sender, adress recipient, uint256 publicKey, uint256 amount, bytes32[] options);LongAndLotsOfArgs( sender, recipient, publicKey, amount, options); 而不是： 1234567891011event LongAndLotsOfArgs(adress sender, adress recipient, uint256 publicKey, uint256 amount, bytes32[] options);LongAndLotsOfArgs(sender, recipient, publicKey, amount, options); 文件编码格式推荐使用utf-8 及 ASCII 编码 引入文件应该在最上方建议使用： 1234567891011import \"owned\";contract A &#123; ...&#125;contract B is owned &#123; ...&#125; 而不是： 1234567891011contract A &#123; ...&#125;import \"owned\";contract B is owned &#123; ...&#125; 函数编写规范函数的顺序在编写函数的时候，应该让大家容易找到构造函数，回退函数，官方推荐的的函数顺序是： 构造函数 回退函数 (如果有) 外部函数（external） 公有函数(public) 内部函数(internal) 私有函数（private） 同一类函数时，constant函数放在后面， 例如推荐方式为： 1234567891011121314151617181920212223242526 contract A &#123; // 构造函数 function A() public &#123; ... &#125; // 回退函数 function() public &#123; ... &#125; // 外部函数 // ... // 带有constant 外部函数 // ... // 公有函数 // ... // 内部函数 // ... // 私有函数 // ...&#125; 而不是下面的函数顺序： 1234567891011121314151617181920212223 contract A &#123; // 外部函数 // ... // 公有函数 // ... // 内部函数 // ... function A() public &#123; ... &#125; function() public &#123; ... &#125; // 私有函数 // ...&#125; 明确函数的可见性所有的函数（包括构造函数）应该在定义的时候明确函数的可见性，例如应该使用： 123function explicitlyPublic(uint val) public &#123; doSomething();&#125; 而不是 123function implicitlyPublic(uint val) &#123; doSomething();&#125; 可见性应该在修饰符前面函数的可见性应该写在自定义的函数修饰符前面，例如： 123function kill() public onlyowner &#123; selfdestruct(owner);&#125; 而不是 123function kill() onlyowner public &#123; selfdestruct(owner);&#125; 区分函数和事件为了防止函数和事件（Event）产生混淆，声明一个事件使用大写并加入前缀（可使用LOG）。对于函数， 始终以小写字母开头，构造函数除外。 1234567// 不建议event Transfer() &#123;&#125;function transfer() &#123;&#125;// 建议event LogTransfer() &#123;&#125;function transfer() external &#123;&#125; 常量常量应该使用全大写及下划线分割大词的方式，如：MAX_BLOCKS，TOKEN_NAME， CONTRACT_VERSION。 参考文献Solidity style-guide 深入浅出区块链 - 系统学习区块链，打造最好的区块链技术博客。如果你想和我有密切的联系，欢迎加入知识星球深入浅出区块链，我会在星球为大家解答技术问题，作为星友福利，星友可加入我创建的区块链技术群，群内已经聚集了200多位区块链技术牛人和爱好者。","categories":[{"name":"以太坊","slug":"ethereum","permalink":"https://learnblockchain.cn/categories/ethereum/"},{"name":"Solidity","slug":"ethereum/Solidity","permalink":"https://learnblockchain.cn/categories/ethereum/Solidity/"}],"tags":[{"name":"Solidity手册","slug":"Solidity手册","permalink":"https://learnblockchain.cn/tags/Solidity手册/"}]},{"title":"美链BEC合约漏洞技术分析","slug":"bec-overflow","date":"2018-04-25T02:13:07.000Z","updated":"2018-04-26T01:49:16.484Z","comments":true,"path":"2018/04/25/bec-overflow/","link":"","permalink":"https://learnblockchain.cn/2018/04/25/bec-overflow/","excerpt":"这两天币圈链圈被美链BEC智能合约的漏洞导致代币价值几乎归零的事件刷遍朋友圈。这篇文章就来分析下BEC智能合约的漏洞","text":"这两天币圈链圈被美链BEC智能合约的漏洞导致代币价值几乎归零的事件刷遍朋友圈。这篇文章就来分析下BEC智能合约的漏洞 漏洞攻击交易我们先来还原下攻击交易，这个交易可以在这个链接查询到。我截图给大家看一下： 攻击者向两个账号转移57896044618…000.792003956564819968个BEC，相当于BEC凭空进行了一个巨大的增发，几乎导致BEC价格瞬间归零。下面我们来分析下这个攻击过程。 合约漏洞分析我们先来看看BEC智能合约的代码，BEC在合约中加入一个批量转账的函数，它的实现如下： 123456789101112function batchTransfer(address[] _receivers, uint256 _value) public whenNotPaused returns (bool) &#123; uint cnt = _receivers.length; uint256 amount = uint256(cnt) * _value; require(cnt &gt; 0 &amp;&amp; cnt &lt;= 20); require(_value &gt; 0 &amp;&amp; balances[msg.sender] &gt;= amount); balances[msg.sender] = balances[msg.sender].sub(amount); for (uint i = 0; i &lt; cnt; i++) &#123; balances[_receivers[i]] = balances[_receivers[i]].add(_value); Transfer(msg.sender, _receivers[i], _value); &#125; return true; 这个函数的作用是，调用者传入若干个地址和转账金额，在经过一些条件检查之后，对msg.sender的余额进行减操作，对每一个对每一个传入的地址进行加操作，以实现BEC的转移。问题出在 uint256 amount = uint256(cnt) * _value; 这句代码，当传入值_value过大时（接近uint256的取值范围的最大值），uint256 amount = uint256(cnt) * _value计算时会发生溢出，导致amount实际的值是一个非常小的数（此时amount不再是cnt * _value的实际值），amount很小，也使得后面对调用者余额校验可正常通过（即require(_value &gt; 0 &amp;&amp; balances[msg.sender] &gt;= amount)语句通过）。 我们来结合实际攻击交易使用的参数来分析一下： batchTransfer的参数_value值为16进制的800000000000000000000...，参数_receivers数组的大小为2，相乘之后刚好可超过uint256所能表示的整数大小上限，引发溢出问题amount实际的值为0，后面的转账操作实际上msg.sender的余额减0， 而对两个账号进行了加16进制的800000000000000000000...，最终的结果是相当于增发了2 * 16进制的800000000000000000000...。 实际上对于这种整数溢出漏洞，最简单的方法是采用 SafeMath 数学计算库来避免。有趣的是BEC智能合约代码中，其实其他的都使用了SafeMath， 而关键的uint256 amount = uint256(cnt) * _value却没有使用。心痛程序员，也心痛韭菜。这句代码改为uint256 amount = _value.mul(uint256(cnt));就可以防止溢出问题 所以在做加减乘除的时候请记得一定使用：SafeMath，代码在这里 溢出补充说明溢出补充说明为小专栏订阅用户福利，小专栏的文章内介绍了什么时候会发生上溢，什么时候会发生下溢，并且给出了代码事例。大家可请前往我的小专栏阅读。 知识星球深入浅出区块链做好的区块链技术问答社区，欢迎来提问，作为星球成员福利，成员可加入区块链技术付费交流群。深入浅出区块链 - 系统学习区块链，打造最好的区块链技术博客。","categories":[{"name":"以太坊","slug":"ethereum","permalink":"https://learnblockchain.cn/categories/ethereum/"},{"name":"智能合约","slug":"ethereum/智能合约","permalink":"https://learnblockchain.cn/categories/ethereum/智能合约/"}],"tags":[{"name":"智能合约","slug":"智能合约","permalink":"https://learnblockchain.cn/tags/智能合约/"}]},{"title":"Web3与智能合约交互实战","slug":"web3-html","date":"2018-04-15T13:24:16.000Z","updated":"2018-05-10T03:46:26.625Z","comments":true,"path":"2018/04/15/web3-html/","link":"","permalink":"https://learnblockchain.cn/2018/04/15/web3-html/","excerpt":"Web3与智能合约交互实战","text":"Web3与智能合约交互实战 写在前面在最初学习以太坊的时候，很多人都是自己创建以太坊节点后，使用geth与之交互。这种使用命令行交互的方法虽然让很多程序员感到兴奋（黑客帝国的既视感？），但不可能指望普通用户通过命令行使用Dapp。因此，我们需要一种友好的方式（比如一个web页面）来与智能合约交互，于是问题的答案就是web3.js。 Web3.jsWeb3.js是以太坊官方的Javascript API，可以帮助智能合约开发者使用HTTP或者IPC与本地的或者远程的以太坊节点交互。实际上就是一个库的集合，主要包括下面几个库： web3-eth用来与以太坊区块链和智能合约交互 web3-shh用来控制whisper协议与p2p通信以及广播 web3-bzz用来与swarm协议交互 web3-utils包含了一些Dapp开发有用的功能 Web3与geth通信使用的是 JSON-RPC ，这是一种轻量级的RPC（Remote Procedure Call）协议，整个通信的模型可以抽象为下图。 搭建测试链在开发初期，我们并没有必要使用真实的公链，为了开发效率，一般选择在本地搭建测试链。在本文我们选择的Ganache（在此之前使用的是testrpc，Ganache属于它的升级版），一个图形化测试软件（也有命令行版本），可以一键在本地搭建以太坊区块链测试环境，并且将区块链的状态通过图形界面显示出来，Ganache的运行界面如下图所示。 从图中可以看到Ganache会默认创建10个账户，监听地址是http://127.0.0.1:7545，可以实时看到Current Block、Gas Price、Gas Limit等信息。 创建智能合约目前以太坊官方全力支持的智能合约开发环境是Remix IDE，我们在合约编辑页面编写如下代码： 12345678910111213141516pragma solidity ^0.4.21;contract InfoContract &#123; string fName; uint age; function setInfo(string _fName, uint _age) public &#123; fName = _fName; age = _age; &#125; function getInfo() public constant returns (string, uint) &#123; return (fName, age); &#125; &#125; 代码很简单，就是简单的给name和age变量赋值与读取，接下来切换到 run 的 tab 下，将Environment切换成Web3 Provider，并输入我们的测试链的地址http://127.0.0.1:7545，这里对这三个选项做一简单说明： Javascript VM：简单的Javascript虚拟机环境，纯粹练习智能合约编写的时候可以选择 Injected Web3：连接到嵌入到页面的Web3，比如连接到MetaMask Web3 Provider：连接到自定义的节点，如私有的测试网络。 如果连接成功，那么在下面的Account的选项会默认选择 Ganache 创建的第一个账户地址。接下来我们点击Create就会将我们的智能合约部署到我们的测试网中。接下来 Remix 的页面不要关闭，在后面编写前端代码时还要用到合约的地址以及ABI信息。 安装Web3在这之前，先在终端创建我们的项目： 12&gt; mkdir info&gt; cd info 接下来使用 node.js 的包管理工具 npm 初始化项目，创建package.json 文件，其中保存了项目需要的相关依赖环境。 1&gt; npm init 一路按回车直到项目创建完成。最后，运行下面命令安装web.js： 1&gt; npm install web3 注意： 在实际安装过程中我发现web3在安装完成后并没有 /node_modules/web3/dist/we3.min.js 文件，这个问题在 issue#1041中有体现，但官方好像一直没解决。不过可以在这里下载所需的文件，解压后将dist文件夹的内容拷贝到 /node_modules/web3路径下。 创建 UI在项目目录下创建index.html，在这里我们将创建基础的 UI，功能包括name和age的输入框，以及一个按钮，这些将通过 jQuery 实现： 123456789101112131415161718192021222324252627282930313233343536373839&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;link rel=\"stylesheet\" type=\"text/css\" href=\"main.css\"&gt; &lt;script src=\"./node_modules/web3/dist/web3.min.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"container\"&gt; &lt;h1&gt;Info Contract&lt;/h1&gt; &lt;h2 id=\"info\"&gt;&lt;/h2&gt; &lt;label for=\"name\" class=\"col-lg-2 control-label\"&gt;Name&lt;/label&gt; &lt;input id=\"name\" type=\"text\"&gt; &lt;label for=\"name\" class=\"col-lg-2 control-label\"&gt;Age&lt;/label&gt; &lt;input id=\"age\" type=\"text\"&gt; &lt;button id=\"button\"&gt;Update Info&lt;/button&gt; &lt;/div&gt; &lt;script src=\"https://code.jquery.com/jquery-3.2.1.slim.min.js\"&gt;&lt;/script&gt; &lt;script&gt; // Our future code here.. &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 接下来需要编写main.css文件设定基本的样式： 1234567891011121314151617181920212223242526272829body &#123; background-color:#F0F0F0; padding: 2em; font-family: 'Raleway','Source Sans Pro', 'Arial';&#125;.container &#123; width: 50%; margin: 0 auto;&#125;label &#123; display:block; margin-bottom:10px;&#125;input &#123; padding:10px; width: 50%; margin-bottom: 1em;&#125;button &#123; margin: 2em 0; padding: 1em 4em; display:block;&#125;#info &#123; padding:1em; background-color:#fff; margin: 1em 0;&#125; ##使用Web3与智能合约交互UI 创建好之后，在&lt;script&gt;标签中间编写web.js的代码与智能合约交互。首先创建web3实例，并与我们的测试环境连接： 12345678&lt;script&gt; if (typeof web3 !== 'undefined') &#123; web3 = new Web3(web3.currentProvider); &#125; else &#123; // set the provider you want from Web3.providers web3 = new Web3(new Web3.providers.HttpProvider(\"http://localhost:7545\")); &#125;&lt;/script&gt; 这段代码是web3.js Github提供的样例，意思是如果web3已经被定义，那么就可以直接当作我们的 provider 使用。如果没有定义，则我们手动指定 provider。 这里可能会存在疑问：为什么 web3 会被事先定义呢？实际上，如果你使用类似 MetaMask（一个 Chrome 上的插件，迷你型以太坊钱包）这样的软件，provider 就会被自动植入。 在上面代码的基础上，接下来设置默认的以太坊账户： 1web3.eth.defaultAccount = web3.eth.accounts[0]; 在上文中我们使用 Ganache 已经创建了 10 个账户了，这里我们选择第一个账户当作默认账户。 接下来需要让我们的web3知道我们的合约是什么样的，这里需要用到合约的 ABI（Application Binary Interface）。ABI可以使我们调用合约的函数，并且从合约中获取数据。 在上文中我们已经在 Remix 中创建了我们的合约，这时重新回到 Remix，在 Compile 的 tab 下我们点击Details 出现的页面中我们可以拷贝合约的ABI，如下图所示。将其复制到代码中： 1var infoContract = web3.eth.contract(PASTE ABI HERE!); 接下来转到 run 的tab，拷贝合约的地址，将其复制到下面的代码中： 1var info = InfoContract.at('PASTE CONTRACT ADDRESS HERE'); 完成这些我们就可以调用合约中的函数了，下面我们使用 jQuery 与我们的合约进行交互： 12345678910111213info.getInfo(function(error, result)&#123; if(!error) &#123; $(\"#info\").html(result[0]+' ('+result[1]+' years old)'); console.log(result); &#125; else console.error(error);&#125;);$(\"#button\").click(function() &#123; info.setInfo($(\"#name\").val(), $(\"#age\").val());&#125;); 以上的代码就简单地实现了对合约中两个函数的调用，分别读取和显示name和age变量。 到此我们就完成了全部的代码，完整代码可以在 InfoContract 中找到。在浏览器中打开index.html测试效果如下图（输入名字和年龄后刷新）。 本文的作者是盖盖，他的微信公众号: chainlab 参考文献 Interacting with a Smart Contract through Web3.js (Tutorial)) 深入浅出区块链 - 系统学习区块链，打造最好的区块链技术博客。如果你想和我有密切的联系，欢迎加入知识星球深入浅出区块链，我会在星球为大家解答技术问题，作为星友福利，星友可加入我创建的区块链技术群，群内已经聚集了200多位区块链技术牛人和爱好者。","categories":[{"name":"以太坊","slug":"ethereum","permalink":"https://learnblockchain.cn/categories/ethereum/"}],"tags":[{"name":"智能合约","slug":"智能合约","permalink":"https://learnblockchain.cn/tags/智能合约/"},{"name":"以太坊","slug":"以太坊","permalink":"https://learnblockchain.cn/tags/以太坊/"},{"name":"Web3","slug":"Web3","permalink":"https://learnblockchain.cn/tags/Web3/"}]},{"title":"智能合约语言 Solidity 教程系列10 - 完全理解函数修改器","slug":"solidity-modify","date":"2018-04-09T12:35:47.000Z","updated":"2018-05-17T15:10:40.883Z","comments":true,"path":"2018/04/09/solidity-modify/","link":"","permalink":"https://learnblockchain.cn/2018/04/09/solidity-modify/","excerpt":"这是Solidity教程系列文章第10篇，带大家完全理解Solidity的函数修改器。Solidity系列完整的文章列表请查看分类-Solidity。","text":"这是Solidity教程系列文章第10篇，带大家完全理解Solidity的函数修改器。Solidity系列完整的文章列表请查看分类-Solidity。 写在前面Solidity 是以太坊智能合约编程语言，阅读本文前，你应该对以太坊、智能合约有所了解，如果你还不了解，建议你先看以太坊是什么 欢迎订阅区块链技术专栏阅读更全面的分析文章。 函数修改器(Function Modifiers)函数修改器(Modifiers)可以用来改变一个函数的行为。比如用于在函数执行前检查某种前置条件。 如果熟悉Python的同学，会发现函数修改器的作用和Python的装饰器很相似。 修改器是一种可被继承合约属性，同时还可被继承的合约重写(override)。下面我们来看一段示例代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546pragma solidity ^0.4.11;contract owned &#123; function owned() public &#123; owner = msg.sender; &#125; address owner; // 定义了一个函数修改器，可被继承 // 修饰时，函数体被插入到 “_;” 处 // 不符合条件时，将抛出异常 modifier onlyOwner &#123; require(msg.sender == owner); _; &#125;&#125;contract mortal is owned &#123; // 使用继承的`onlyOwner` function close() public onlyOwner &#123; selfdestruct(owner); &#125;&#125;contract priced &#123; // 函数修改器可接收参数 modifier costs(uint price) &#123; if (msg.value &gt;= price) &#123; _; &#125; &#125;&#125;contract Register is priced, owned &#123; mapping (address =&gt; bool) registeredAddresses; uint price; function Register(uint initialPrice) public &#123; price = initialPrice; &#125; // 需要提供payable 以接受以太 function register() public payable costs(price) &#123; registeredAddresses[msg.sender] = true; &#125; function changePrice(uint _price) public onlyOwner &#123; price = _price; &#125;&#125; 上面onlyOwner就是定义的一个函数修改器，当用这个修改器区修饰一个函数时，则函数必须满足onlyOwner的条件才能运行，这里的条件是：必须是合约的创建这才能调用函数，否则抛出异常。我们在实现一个可管理、增发、兑换、冻结等高级功能的代币文章中就使用了这个函数修改器。 多个修改器如果同一个函数有多个修改器，他们之间以空格隔开，修饰器会依次检查执行。 在修改器中或函数内的显式的return语句，仅仅跳出当前的修改器或函数。返回的变量会被赋值，但执行流会在前一个修改器后面定义的”_”后继续执行， 如： 12345678910111213141516contract Mutex &#123; bool locked; modifier noReentrancy() &#123; require(!locked); locked = true; _; locked = false; &#125; // 防止递归调用 // return 7 之后，locked = false 依然会执行 function f() public noReentrancy returns (uint) &#123; require(msg.sender.call()); return 7; &#125;&#125; 修改器的参数可以是任意表达式。在此上下文中，所有的函数中引入的符号，在修改器中均可见。但修改器中引入的符号在函数中不可见，因为它们有可能被重写。 深入理解修改器的执行次序再来看一个复杂一点的例子，来深入理解修改器： 1234567891011121314151617181920212223242526272829303132333435pragma solidity ^0.4.11;contract modifysample &#123; uint a = 10; modifier mf1 (uint b) &#123; uint c = b; _; c = a; a = 11; &#125; modifier mf2 () &#123; uint c = a; _; &#125; modifier mf3() &#123; a = 12; return ; _; a = 13; &#125; function test1() mf1(a) mf2 mf3 public &#123; a = 1; &#125; function test2() public constant returns (uint) &#123; return a; &#125; &#125; 上面的智能合约运行test1()之后，状态变量a的值是多少， 是1， 11， 12，还是13呢？答案是 11, 大家可以运行下test2获取下a值。 我们来分析一下 test1， 它扩展之后是这样的： 12345678uint c = b; uint c = a; a = 12; return ; _; a = 13;c = a;a = 11; 这个时候就一目了然了，最后a 为11， 注意第5及第6行是不是执行的。 参考文献官方文档-Function Modifiers 如果你想和认识我，和我建立联系，欢迎加入知识星球深入浅出区块链，我会在星球为大家解答技术问题，作为星友福利，星友可加入我创建的区块链技术群，群内已经聚集了200多位区块链技术爱好者。 深入浅出区块链 - 系统学习区块链，打造最好的区块链技术博客。","categories":[{"name":"以太坊","slug":"ethereum","permalink":"https://learnblockchain.cn/categories/ethereum/"},{"name":"Solidity","slug":"ethereum/Solidity","permalink":"https://learnblockchain.cn/categories/ethereum/Solidity/"}],"tags":[{"name":"Solidity手册","slug":"Solidity手册","permalink":"https://learnblockchain.cn/tags/Solidity手册/"}]},{"title":"智能合约语言 Solidity 教程系列9 - 错误处理","slug":"solidity-errorhandler","date":"2018-04-07T12:35:47.000Z","updated":"2018-04-07T14:37:06.216Z","comments":true,"path":"2018/04/07/solidity-errorhandler/","link":"","permalink":"https://learnblockchain.cn/2018/04/07/solidity-errorhandler/","excerpt":"这是Solidity教程系列文章第9篇介绍Solidity 错误处理。Solidity系列完整的文章列表请查看分类-Solidity。","text":"这是Solidity教程系列文章第9篇介绍Solidity 错误处理。Solidity系列完整的文章列表请查看分类-Solidity。 写在前面Solidity 是以太坊智能合约编程语言，阅读本文前，你应该对以太坊、智能合约有所了解，如果你还不了解，建议你先看以太坊是什么 欢迎订阅区块链技术专栏阅读更全面的分析文章。 什么是错误处理错误处理是指在程序发生错误时的处理方式，Solidity处理错误和我们常见的语言不一样，Solidity是通过回退状态的方式来处理错误。发生异常时会撤消当前调用（及其所有子调用）所改变的状态，同时给调用者返回一个错误标识。注意捕捉异常是不可能的，因此没有try … catch…。 为什么Solidity处理错误要这样设计呢？我们可以把区块链理解为是全球共享的分布式事务性数据库。全球共享意味着参与这个网络的每一个人都可以读写其中的记录。如果想修改这个数据库中的内容，就必须创建一个事务，事务意味着要做的修改（假如我们想同时修改两个值）只能被完全的应用或者一点都没有进行。学习过数据库的同学，应该理解事务的含义，如果你对事务一词不是很理解，建议你搜索一下“数据库事务“。Solidity错误处理就是要保证每次调用都是事务性的。 如何处理Solidity提供了两个函数assert和require来进行条件检查，如果条件不满足则抛出异常。assert函数通常用来检查（测试）内部错误，而require函数来检查输入变量或合同状态变量是否满足条件以及验证调用外部合约返回值。另外，如果我们正确使用assert，有一个Solidity分析工具就可以帮我们分析出智能合约中的错误，帮助我们发现合约中有逻辑错误的bug。 除了可以两个函数assert和require来进行条件检查，另外还有两种方式来触发异常： revert函数可以用来标记错误并回退当前调用 使用throw关键字抛出异常（从0.4.13版本，throw关键字已被弃用，将来会被淘汰。） 当子调用中发生异常时，异常会自动向上“冒泡”。 不过也有一些例外：send，和底层的函数调用call, delegatecall，callcode，当发生异常时，这些函数返回false。 注意：在一个不存在的地址上调用底层的函数call，delegatecall，callcode 也会返回成功，所以我们在进行调用时，应该总是优先进行函数存在性检查。 在下面通过一个示例来说明如何使用require来检查输入条件，以及assert用于内部错误检查： 1234567891011pragma solidity ^0.4.0;contract Sharer &#123; function sendHalf(address addr) public payable returns (uint balance) &#123; require(msg.value % 2 == 0); // 仅允许偶数 uint balanceBeforeTransfer = this.balance; addr.transfer(msg.value / 2); // 如果失败，会抛出异常，下面的代码就不是执行 assert(this.balance == balanceBeforeTransfer - msg.value / 2); return this.balance; &#125;&#125; 我们实际运行下，看看异常是如何发生的： 首先打开Remix，贴入代码，点击创建合约。如下图： 运行测试1：附加1wei (奇数)去调用sendHalf，这时会发生异常，如下图: 运行测试2：附加2wei 去调用sendHalf，运行正常。 运行测试3：附加2wei以及sendHalf参数为当前合约本身，在转账是发生异常，因为合约无法接收转账，错误提示上图类似。 assert类型异常在下述场景中自动产生assert类型的异常: 如果越界，或负的序号值访问数组，如i &gt;= x.length 或 i &lt; 0时访问x[i] 如果序号越界，或负的序号值时访问一个定长的bytesN。 被除数为0， 如5/0 或 23 % 0。 对一个二进制移动一个负的值。如:5&lt;&lt;i; i为-1时。 整数进行可以显式转换为枚举时，如果将过大值，负值转为枚举类型则抛出异常 如果调用未初始化内部函数类型的变量。 如果调用assert的参数为false require类型异常在下述场景中自动产生require类型的异常: 调用throw 如果调用require的参数为false 如果你通过消息调用一个函数，但在调用的过程中，并没有正确结束(gas不足，没有匹配到对应的函数，或被调用的函数出现异常)。底层操作如call,send,delegatecall或callcode除外，它们不会抛出异常，但它们会通过返回false来表示失败。 如果在使用new创建一个新合约时出现第3条的原因没有正常完成。 如果调用外部函数调用时，被调用的对象不包含代码。 如果合约没有payable修饰符的public的函数在接收以太币时（包括构造函数，和回退函数）。 如果合约通过一个public的getter函数（public getter funciton）接收以太币。 如果.transfer()执行失败 当发生require类型的异常时，Solidity会执行一个回退操作（指令0xfd）。当发生assert类型的异常时，Solidity会执行一个无效操作（指令0xfe）。在上述的两种情况下，EVM都会撤回所有的状态改变。是因为期望的结果没有发生，就没法继续安全执行。必须保证交易的原子性（一致性，要么全部执行，要么一点改变都没有，不能只改变一部分），所以需要撤销所有操作，让整个交易没有任何影响。 注意assert类型的异常会消耗掉所有的gas, 而require从大都会版本（Metropolis， 即目前主网所在的版本）起不会消耗gas。 参考文献 Solidity 错误处理 欢迎来我的知识星球深入浅出区块链讨论区块链技术，同时我也会为大家提供区块链技术解答，作为星友福利，星友可加入区块链技术付费交流群。深入浅出区块链 - 系统学习区块链，打造最好的区块链技术博客。","categories":[{"name":"以太坊","slug":"ethereum","permalink":"https://learnblockchain.cn/categories/ethereum/"},{"name":"Solidity","slug":"ethereum/Solidity","permalink":"https://learnblockchain.cn/categories/ethereum/Solidity/"}],"tags":[{"name":"Solidity手册","slug":"Solidity手册","permalink":"https://learnblockchain.cn/tags/Solidity手册/"}]},{"title":"剖析非同质化代币ERC721-全面解析ERC721标准","slug":"token-erc721","date":"2018-03-23T13:54:50.000Z","updated":"2018-03-26T01:58:47.075Z","comments":true,"path":"2018/03/23/token-erc721/","link":"","permalink":"https://learnblockchain.cn/2018/03/23/token-erc721/","excerpt":"什么是ERC-721？现在我们看到的各种加密猫猫狗狗都是基于ERC-721创造出来的，每只都是一个独一无二的ERC-721代币，不过ERC-721在区块链世界远不止猫猫狗狗，它更大的想象空间在于将物理世界的资产映射到区块链上。本文就来剖析下什么是ERC721.","text":"什么是ERC-721？现在我们看到的各种加密猫猫狗狗都是基于ERC-721创造出来的，每只都是一个独一无二的ERC-721代币，不过ERC-721在区块链世界远不止猫猫狗狗，它更大的想象空间在于将物理世界的资产映射到区块链上。本文就来剖析下什么是ERC721. ERC721是什么在创建代币一篇，我们讲到过ERC20代币，和ERC20一样，ERC721同样是一个代币标准，ERC721官方简要解释是Non-Fungible Tokens，简写为NFTs，多翻译为非同质代币。 ERC721 是由Dieter Shirley 在2017年9月提出。Dieter Shirley 正是谜恋猫CryptoKitties背后的公司Axiom Zen的技术总监。因此谜恋猫也是第一个实现了ERC721 标准的去中心化应用。ERC721号提议已经被以太坊作为标准接受，但该标准仍处于草稿阶段。本文介绍的ERC721标准基于最新(2018/03/23官方提议。 那怎么理解非同质代币呢? 非同质代表独一无二，谜恋猫为例，每只猫都被赋予拥有基因，是独一无二的（一只猫就是一个NFTs），猫之间是不能置换的。这种独特性使得某些稀有猫具有收藏价值，也因此受到追捧。 ERC20代币是可置换的，且可细分为N份（1 = 10 * 0.1）, 而ERC721的Token最小的单位为1，无法再分割。 如果同一个集合的两个物品具有不同的特征，这两个物品是非同质的，而同质是某个部分或数量可以被另一个同等部分或数量所代替。 非同质性其实广泛存在于我们的生活中，如图书馆的每一本，宠物商店的每一只宠物，歌手所演唱的歌曲，花店里不同的花等等，因此ERC721合约必定有广泛的应用场景。通过这样一个标准，也可建立跨功能的NFTs管理和销售平台（就像有支持ERC20的交易所和钱包一样），使生态更加强大。 ERC721标准ERC721最为一个合约标准，提供了在实现ERC721代币时必须要遵守的协议，要求每个ERC721标准合约需要实现ERC721及ERC165接口，接口定义如下： 1234567891011121314151617181920pragma solidity ^0.4.20;interface ERC721 /* is ERC165 */ &#123; event Transfer(address indexed _from, address indexed _to, uint256 _tokenId); event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId); event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved); function balanceOf(address _owner) external view returns (uint256); function ownerOf(uint256 _tokenId) external view returns (address); function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes data) external payable; function safeTransferFrom(address _from, address _to, uint256 _tokenId) external payable; function transferFrom(address _from, address _to, uint256 _tokenId) external payable; function approve(address _approved, uint256 _tokenId) external payable; function setApprovalForAll(address _operator, bool _approved) external; function getApproved(uint256 _tokenId) external view returns (address); function isApprovedForAll(address _owner, address _operator) external view returns (bool);&#125; 接口说明： balanceOf(): 返回由_owner 持有的NFTs的数量。 ownerOf(): 返回tokenId代币持有者的地址。 approve(): 授予地址_to具有_tokenId的控制权，方法成功后需触发Approval 事件。 setApprovalForAll(): 授予地址_operator具有所有NFTs的控制权，成功后需触发ApprovalForAll事件。 getApproved()、isApprovedForAll(): 用来查询授权。 safeTransferFrom(): 转移NFT所有权，一次成功的转移操作必须发起 Transer 事件。函数的实现需要做一下几种检查： 调用者msg.sender应该是当前tokenId的所有者或被授权的地址 _from 必须是 _tokenId的所有者 _tokenId 应该是当前合约正在监测的NFTs 中的任何一个 _to 地址不应该为 0 如果_to 是一个合约应该调用其onERC721Received方法, 并且检查其返回值，如果返回值不为bytes4(keccak256(&quot;onERC721Received(address,uint256,bytes)&quot;))抛出异常。一个可接收NFT的合约必须实现ERC721TokenReceiver接口：1234interface ERC721TokenReceiver &#123; /// @return `bytes4(keccak256(\"onERC721Received(address,uint256,bytes)\"))` function onERC721Received(address _from, uint256 _tokenId, bytes data) external returns(bytes4);&#125; transferFrom(): 用来转移NFTs, 方法成功后需触发Transfer事件。调用者自己确认_to地址能正常接收NFT，否则将丢失此NFT。此函数实现时需要检查上面条件的前4条。 ERC165 标准ERC721标准同时要求必须符合ERC165标准 ，其接口如下：123interface ERC165 &#123; function supportsInterface(bytes4 interfaceID) external view returns (bool);&#125; ERC165同样是一个合约标准，这个标准要求合约提供其实现了哪些接口，这样再与合约进行交互的时候可以先调用此接口进行查询。interfaceID为函数选择器，计算方式有两种，如：bytes4(keccak256(&#39;supportsInterface(bytes4)&#39;));或ERC165.supportsInterface.selector，多个函数的接口ID为函数选择器的异或值。关于ERC165，这里不深入介绍，有兴趣的同学可以阅读官方提案。 可选实现接口：ERC721MetadataERC721Metadata 接口用于提供合约的元数据：name , symbol 及 URI（NFT所对应的资源）。其接口定义如下：12345interface ERC721Metadata /* is ERC721 */ &#123; function name() external pure returns (string _name); function symbol() external pure returns (string _symbol); function tokenURI(uint256 _tokenId) external view returns (string);&#125; 接口说明： name(): 返回合约名字，尽管是可选，但强烈建议实现，即便是返回空字符串。 symbol(): 返回合约代币符号，尽管是可选，但强烈建议实现，即便是返回空字符串。 tokenURI(): 返回_tokenId所对应的外部资源文件的URI（通常是IPFS或HTTP(S)路径）。外部资源文件需要包含名字、描述、图片，其格式的要求如下：123456789101112131415161718&#123; \"title\": \"Asset Metadata\", \"type\": \"object\", \"properties\": &#123; \"name\": &#123; \"type\": \"string\", \"description\": \"Identifies the asset to which this NFT represents\", &#125;, \"description\": &#123; \"type\": \"string\", \"description\": \"Describes the asset to which this NFT represents\", &#125;, \"image\": &#123; \"type\": \"string\", \"description\": \"A URI pointing to a resource with mime type image/* representing the asset to which this NFT represents. Consider making any images at a width between 320 and 1080 pixels and aspect ratio between 1.91:1 and 4:5 inclusive.\", &#125; &#125;&#125; tokenURI通常是被web3调用，以便在应用层做相应的查询和展示。 可选实现接口：ERC721EnumerableERC721Enumerable的主要目的是提高合约中NTF的可访问性，其接口定义如下：12345interface ERC721Enumerable /* is ERC721 */ &#123; function totalSupply() external view returns (uint256); function tokenByIndex(uint256 _index) external view returns (uint256); function tokenOfOwnerByIndex(address _owner, uint256 _index) external view returns (uint256);&#125; 接口说明： totalSupply(): 返回NFT总量 tokenByIndex(): 通过索引返回对应的tokenId。 tokenOfOwnerByIndex(): 所有者可以一次拥有多个的NFT, 此函数返回_owner拥有的NFT列表中对应索引的tokenId。 补充说明NTF IDsNTF ID，即tokenId，在合约中用唯一的uint265进行标识，每个NFT的ID在智能合约的生命周期内不允许改变。推荐的实现方式有： 从0开始，每新加一个NFT，NTF ID加1 使用sha3后uuid 转换为 NTF ID 与ERC-20的兼容性ERC721标准尽可能遵循 ERC-20 的语义，但由于同质代币与非同质代币之间的根本差异，并不能完全兼容ERC-20。 交易、挖矿、销毁在实现transter相关接口时除了满足上面的的条件外，我们可以根据需要添加自己的逻辑，如加入黑名单等。同时挖矿、销毁尽管不是标准的一部分，我们可以根据需要实现。 参考实现参考实现为订阅用户专有福利，请订阅我的小专栏：区块链技术查看。 参考文献 EIPS-165 EIPS-721 欢迎来我的知识星球深入浅出区块链讨论区块链，作为星友福利，星友可加入区块链技术付费交流群。深入浅出区块链 - 系统学习区块链，打造最好的区块链技术博客。","categories":[{"name":"以太坊","slug":"ethereum","permalink":"https://learnblockchain.cn/categories/ethereum/"},{"name":"智能合约","slug":"ethereum/智能合约","permalink":"https://learnblockchain.cn/categories/ethereum/智能合约/"}],"tags":[{"name":"智能合约","slug":"智能合约","permalink":"https://learnblockchain.cn/tags/智能合约/"},{"name":"Token","slug":"Token","permalink":"https://learnblockchain.cn/tags/Token/"},{"name":"ERC721","slug":"ERC721","permalink":"https://learnblockchain.cn/tags/ERC721/"}]},{"title":"如何搭建以太坊私有链","slug":"create_private_blockchain","date":"2018-03-18T12:05:59.000Z","updated":"2018-03-19T02:13:22.400Z","comments":true,"path":"2018/03/18/create_private_blockchain/","link":"","permalink":"https://learnblockchain.cn/2018/03/18/create_private_blockchain/","excerpt":"在开发以太坊时，很多时候需要搭建一条以太坊私有链，通过本文一起看看如何在Mac上进行搭建。","text":"在开发以太坊时，很多时候需要搭建一条以太坊私有链，通过本文一起看看如何在Mac上进行搭建。 写在前面阅读本文前，你应该对以太坊语言有所了解，如果你还不了解，建议你先看以太坊是什么 go-ethereum客户端安装Go-ethereum客户端通常被称为Geth，它是个命令行界面，执行在Go上实现的完整以太坊节点。Geth得益于Go语言的多平台特性，支持在多个平台上使用(比如Windows、Linux、Mac)。Geth是以太坊协议的具体落地实现，通过Geth，你可以实现以太坊的各种功能，如账户的新建编辑删除，开启挖矿，ether币的转移，智能合约的部署和执行等等。所以，我们选择geth工具来进行开发。由于本人是mac，所以优先使用mac进行开发啦。mac中geth安装如下： 12brew tap ethereum/ethereumbrew install ethereum 检查是否安装成功 1geth --help 如果输出一些帮助提示命令，则说明安装成功。其他平台可参考Geth 安装 搭建私有链以太坊支持自定义创世区块，要运行私有链，我们就需要定义自己的创世区块，创世区块信息写在一个json格式的配置文件中。首先将下面的内容保存到一个json文件中，例如genesis.json。json文件内容如下: 1234567891011121314151617&#123; \"config\": &#123; \"chainId\": 10, \"homesteadBlock\": 0, \"eip155Block\": 0, \"eip158Block\": 0 &#125;, \"alloc\" : &#123;&#125;, \"coinbase\" : \"0x0000000000000000000000000000000000000000\", \"difficulty\" : \"0x20000\", \"extraData\" : \"\", \"gasLimit\" : \"0x2fefd8\", \"nonce\" : \"0x0000000000000042\", \"mixhash\" : \"0x0000000000000000000000000000000000000000000000000000000000000000\", \"parentHash\" : \"0x0000000000000000000000000000000000000000000000000000000000000000\", \"timestamp\" : \"0x00\"&#125; 初始化：写入创世区块准备好创世区块json配置文件后，需要初始化区块链，将上面的创世区块信息写入到区块链中。首先要新建一个目录data0用来存放区块链数据(其实，这个目录data0就相当于一个根节点。当我们基于genesis.json生成根节点后，其他人就可以来连接此根节点，从而能进行交易)。data0目录结构如图所示： 接下来进入privatechain目录中，执行初始化命令： 12cd privatechaingeth --datadir data0 init genesis.json 上面的命令的主体是 geth init，表示初始化区块链，命令可以带有选项和参数，其中–datadir选项后面跟一个目录名，这里为 data0，表示指定数据存放目录为 data0， genesis.json是init命令的参数。 运行上面的命令，会读取genesis.json文件，根据其中的内容，将创世区块写入到区块链中。如果看到log信息中含有Successfully wrote genesis state字样，说明初始化成功。 初始化成功后的目录如下：其中geth/chaindata中存放的是区块数据，keystore中存放的是账户数据。 启动私有链节点初始化完成后，就有了一条自己的私有链，之后就可以启动自己的私有链节点并做一些操作，在终端中输入以下命令即可启动节点： 1geth --datadir data0 --networkid 1108 console 上面命令的主体是geth console，表示启动节点并进入交互式控制台，–datadir选项指定使用data0作为数据目录，–networkid选项后面跟一个数字，这里是1108，表示指定这个私有链的网络id为1108。网络id在连接到其他节点的时候会用到，以太坊公网的网络id是1，为了不与公有链网络冲突，运行私有链节点的时候要指定自己的网络id(上面命令可能会运行失败，我直接重启mac，再进入到privateChain目录中，简单粗暴)。 运行上面的命令后，就启动了区块链节点并进入了Javascript Console：这是一个交互式的Javascript执行环境，在这里面可以执行Javascript代码，其中&gt;是命令提示符。在这个环境里也内置了一些用来操作以太坊的Javascript对象，可以直接使用这些对象。这些对象主要包括： eth：包含一些跟操作区块链相关的方法net：包含以下查看p2p网络状态的方法admin：包含一些与管理节点相关的方法miner：包含启动&amp;停止挖矿的一些方法personal：主要包含一些管理账户的方法txpool：包含一些查看交易内存池的方法web3：包含了以上对象，还包含一些单位换算的方法 玩转Javascript Console进入以太坊Javascript Console后，就可以使用里面的内置对象做一些操作，这些内置对象提供的功能很丰富，比如查看区块和交易、创建账户、挖矿、发送交易、部署智能合约等。接下来介绍几个常用功能，下面的操作中，前面带&gt;的表示在Javascript Console中执行的命令。 创建账户前面只是搭建了私有链，并没有自己的账户，可以在js console中输入eth.accounts来验证： 12&gt; eth.accounts[] 此时没有账户，接下来使用personal对象来创建一个账户： 1234&gt; personal.newAccount()&gt; Passphrase:&gt; Repeat passphrase:&quot;0x4a3b0216e1644c1bbabda527a6da7fc5d178b58f&quot; Passphrase其实就是密码的意思，输入两次密码后，就创建了一个账户。再次执行命令: 1234&gt; personal.newAccount()&gt; Passphrase:&gt; Repeat passphrase:&quot;0x46b24d04105551498587e3c6ce2c3341d5988938&quot; 这时候再去看账户，就有两个了。 12&gt; eth.accounts[&quot;0x4a3b0216e1644c1bbabda527a6da7fc5d178b58f&quot;, &quot;0x46b24d04105551498587e3c6ce2c3341d5988938&quot;] 账户默认会保存在数据目录的keystore文件夹中。查看目录结构，发现data0/keystore中多了两个文件，这两个文件就对应刚才创建的两个账户，这是json格式的文本文件，可以打开查看，里面存的是私钥经过密码加密后的信息。 json文件中信息格式如下： 123456789101112131415161718192021&#123; &quot;address&quot;: &quot;4a3b0216e1644c1bbabda527a6da7fc5d178b58f&quot;, &quot;crypto&quot;: &#123; &quot;cipher&quot;: &quot;aes-128-ctr&quot;, &quot;ciphertext&quot;: &quot;238d6d48126b762c8f13e84622b1bbb7713f7244c2f24555c99b76396fae8355&quot;, &quot;cipherparams&quot;: &#123; &quot;iv&quot;: &quot;d0f5a3d3e6c1eeec77bf631bc938725d&quot; &#125;, &quot;kdf&quot;: &quot;scrypt&quot;, &quot;kdfparams&quot;: &#123; &quot;dklen&quot;: 32, &quot;n&quot;: 262144, &quot;p&quot;: 1, &quot;r&quot;: 8, &quot;salt&quot;: &quot;70dc72c4eb63bea50f7637d9ff85bb53f6ca8ace17f4245feae9c0bc9abaad82&quot; &#125;, &quot;mac&quot;: &quot;bd7fc0c937c39f1cbbf1ca654c33b53d7f9c644c6dacfeefe1641d2f3decea04&quot; &#125;, &quot;id&quot;: &quot;57803d82-0cd4-4a78-9c29-9f9252fdcf60&quot;, &quot;version&quot;: 3&#125; 查看账户余额eth对象提供了查看账户余额的方法： 1234&gt; eth.getBalance(eth.accounts[0])0&gt; eth.getBalance(eth.accounts[1])0 目前两个账户的以太币余额都是0，要使账户有余额，可以从其他账户转账过来，或者通过挖矿来获得以太币奖励。 启动&amp;停止挖矿通过miner.start()来启动挖矿： 1&gt; miner.start(10) 其中start的参数表示挖矿使用的线程数。第一次启动挖矿会先生成挖矿所需的DAG文件，这个过程有点慢，等进度达到100%后，就会开始挖矿，此时屏幕会被挖矿信息刷屏。 如果想停止挖矿，并且进度已经达到100%之后，可以在js console中输入 1miner.stop()： 注意：输入的字符会被挖矿刷屏信息冲掉，没有关系，只要输入完整的miner.stop()之后回车，即可停止挖矿。 挖到一个区块会奖励5个以太币，挖矿所得的奖励会进入矿工的账户，这个账户叫做coinbase，默认情况下coinbase是本地账户中的第一个账户： 12&gt; eth.coinbase&quot;0x4a3b0216e1644c1bbabda527a6da7fc5d178b58f&quot; 现在的coinbase是账户0，要想使挖矿奖励进入其他账户，通过miner.setEtherbase()将其他账户设置成coinbase即可： 1234&gt; miner.setEtherbase(eth.accounts[1])true&gt; eth.coinbase&quot;0x46b24d04105551498587e3c6ce2c3341d5988938&quot; 挖到区块以后，账户0里面应该就有余额了： 12&gt; eth.getBalance(eth.accounts[0])2.31e+21 getBalance()返回值的单位是wei，wei是以太币的最小单位，1个以太币=10的18次方个wei。要查看有多少个以太币，可以用web3.fromWei()将返回值换算成以太币： 12&gt; web3.fromWei(eth.getBalance(eth.accounts[0]),&apos;ether&apos;)2310 发送交易截止目前，账户一的余额还是0： 12&gt; eth.getBalance(eth.accounts[1])0 可以通过发送一笔交易，从账户0转移10个以太币到账户1： 12345678&gt; amount = web3.toWei(10,&apos;ether&apos;)&quot;10000000000000000000&quot;&gt; eth.sendTransaction(&#123;from:eth.accounts[0],to:eth.accounts[1],value:amount&#125;)Error: authentication needed: password or unlock at web3.js:3143:20 at web3.js:6347:15 at web3.js:5081:36 at &lt;anonymous&gt;:1:1 这里报错了，原因是账户每隔一段时间就会被锁住，要发送交易，必须先解锁账户，由于我们要从账户0发送交易，所以要解锁账户0： 1234&gt; personal.unlockAccount(eth.accounts[0])Unlock account 0x4a3b0216e1644c1bbabda527a6da7fc5d178b58fPassphrase: true 输入创建账户时设置的密码，就可以成功解锁账户。然后再发送交易： 12345&gt; amount = web3.toWei(10,&apos;ether&apos;)&quot;10000000000000000000&quot;&gt; eth.sendTransaction(&#123;from:eth.accounts[0],to:eth.accounts[1],value:amount&#125;)INFO [03-07|11:13:11] Submitted transaction fullhash=0x1b21bba16dd79b659c83594b0c41de42debb2738b447f6b24e133d51149ae2a6 recipient=0x46B24d04105551498587e3C6CE2c3341d5988938&quot;0x1b21bba16dd79b659c83594b0c41de42debb2738b447f6b24e133d51149ae2a6&quot; 我们去查看账户1中的余额： 12&gt; eth.getBalance(eth.accounts[1])0 发现还没转过去，此时交易已经提交到区块链，但还未被处理，这可以通过查看txpool来验证： 12345&gt; txpool.status&#123; pending: 1, queued: 0&#125; 其中有一条pending的交易，pending表示已提交但还未被处理的交易。 要使交易被处理，必须要挖矿。这里我们启动挖矿，然后等待挖到一个区块之后就停止挖矿： 1&gt; miner.start(1);admin.sleepBlocks(1);miner.stop(); 当miner.stop()返回true后，txpool中pending的交易数量应该为0了，说明交易已经被处理了，而账户1应该收到币了： 12&gt; web3.fromWei(eth.getBalance(eth.accounts[1]),&apos;ether&apos;)10 查看交易和区块eth对象封装了查看交易和区块信息的方法。 查看当前区块总数： 12&gt; eth.blockNumber463 通过区块号查看区块： 1234567891011121314151617181920212223&gt; eth.getBlock(66)&#123; difficulty: 135266, extraData: &quot;0xd783010802846765746886676f312e31308664617277696e&quot;, gasLimit: 3350537, gasUsed: 0, hash: &quot;0x265dfcc0649bf6240812256b2b9b4e3ae48d51fd8e43e25329ac111556eacdc8&quot;, logsBloom: &quot;0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000&quot;, miner: &quot;0x4a3b0216e1644c1bbabda527a6da7fc5d178b58f&quot;, mixHash: &quot;0xaf755722f62cac9b483d3437dbc795f2d3a02e28ec03d39d8ecbb6012906263c&quot;, nonce: &quot;0x3cd80f6ec5c2f3e9&quot;, number: 66, parentHash: &quot;0x099776a52223b892d13266bb3aec3cc04c455dc797185f0b3300d39f9fc0a8ec&quot;, receiptsRoot: &quot;0x56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421&quot;, sha3Uncles: &quot;0x1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347&quot;, size: 535, stateRoot: &quot;0x0c9feec5a201c8c98618331aecbfd2d4d93da1c6064abd0c41ae649fc08d8d06&quot;, timestamp: 1520391527, totalDifficulty: 8919666, transactions: [], transactionsRoot: &quot;0x56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421&quot;, uncles: []&#125; 通过交易hash查看交易： 1234567891011121314151617&gt; eth.getTransaction(&quot;0x1b21bba16dd79b659c83594b0c41de42debb2738b447f6b24e133d51149ae2a6&quot;)&#123; blockHash: &quot;0x1cb368a27cc23c786ff5cdf7cd4351d48f4c8e8aea2e084a5e9d7c480449c79a&quot;, blockNumber: 463, from: &quot;0x4a3b0216e1644c1bbabda527a6da7fc5d178b58f&quot;, gas: 90000, gasPrice: 18000000000, hash: &quot;0x1b21bba16dd79b659c83594b0c41de42debb2738b447f6b24e133d51149ae2a6&quot;, input: &quot;0x&quot;, nonce: 0, r: &quot;0x31d22686e0d408a16497becf6d47fbfdffe6692d91727e5b7ed3d73ede9e66ea&quot;, s: &quot;0x7ff7c14a20991e2dfdb813c2237b08a5611c8c8cb3c2dcb03a55ed282ce4d9c3&quot;, to: &quot;0x46b24d04105551498587e3c6ce2c3341d5988938&quot;, transactionIndex: 0, v: &quot;0x38&quot;, value: 10000000000000000000&#125; 深入浅出区块链 - 系统学习区块链，打造最好的区块链技术博客。","categories":[{"name":"以太坊","slug":"ethereum","permalink":"https://learnblockchain.cn/categories/ethereum/"},{"name":"私有链","slug":"ethereum/私有链","permalink":"https://learnblockchain.cn/categories/ethereum/私有链/"}],"tags":[{"name":"以太坊","slug":"以太坊","permalink":"https://learnblockchain.cn/tags/以太坊/"},{"name":"私有链","slug":"私有链","permalink":"https://learnblockchain.cn/tags/私有链/"}]},{"title":"如何编写一个可升级的智能合约","slug":"contract-upgrade","date":"2018-03-15T08:14:01.000Z","updated":"2018-03-19T02:07:02.498Z","comments":true,"path":"2018/03/15/contract-upgrade/","link":"","permalink":"https://learnblockchain.cn/2018/03/15/contract-upgrade/","excerpt":"区块链信任基础的数据不可修改的特性，让它传统应用程序有一个很大的不同的地方是一经发布于区块链上就无法修改（不能直接在原有的合约上直接修改再重新发布）。","text":"区块链信任基础的数据不可修改的特性，让它传统应用程序有一个很大的不同的地方是一经发布于区块链上就无法修改（不能直接在原有的合约上直接修改再重新发布）。 写在前面阅读本文前，你应该对以太坊、智能合约及Solidity语言有所了解，如果你还不了解，建议你先看以太坊是什么 当智能合约出现bug一方面正式由于智能合约的不可修改的特性，因为只要规则确定之后，没人能够修改它，大家才能够信任它。但另一方面，如果规则的实现有Bug, 可能会造成代币被盗，或是调用消耗大量的gas。这时就需要我们去修复错误。 我们知道一个智能合约包含两部分： 代码逻辑和数据，而代码逻辑又是最容易出问题的部分, 如在实现如下合约时，由于手抖在写addTen()时，10写成了11。 12345678910111213pragma solidity ^0.4.18;contract MyContract &#123; mapping (address =&gt; uint256) public balanceOf; function setBlance(address _address,uint256 v) public &#123; balanceOf[_address] = v; &#125; function addTen(address addr) public returns (uint)&#123; return balanceOf[addr] + 11; &#125;&#125; 假如我们在部署之后发现了这个问题，想要修复这个bug的话，只好重新部署合约，可是这时会有一个尴尬的问题，原来的合约已经有很多人使用，如果部署新的合约，老合约的数据将会丢失。 数据合约及控制合约那么如何解决上面的问题了，一个解决方案是分离合约中的数据，使用一个单独的合约来存储数据（下文称数据合约），使用一个单独的合约写业务逻辑（下文称控制合约）。我们来看看代码如何实现。 12345678910111213141516171819202122pragma solidity ^0.4.18;contract DataContract &#123; mapping (address =&gt; uint256) public balanceOf; function setBlance(address _address,uint256 v) public &#123; balanceOf[_address] = v; &#125;&#125;contract ControlContract &#123; DataContract dataContract; function ControlContract(address _dataContractAddr) public &#123; dataContract = DataContract(_dataContractAddr); &#125; function addTen(address addr) public returns (uint)&#123; return dataContract.balanceOf(addr) + 11; &#125;&#125; 现在我们有两个合约DataContract 专门用来存数据，ControlContract用来处理逻辑，并利用DataContract来读写数据。通过这样的设计，可以在更新控制合约后保持数据合约不变，这样就不会丢失数据，也不用迁移数据。 读写控制通过DataContract我们可以单独更新合约逻辑，不过你也许发现了一个新的问题，DataContract的数据不仅仅可以被ControlContract读写，还可以被其他的合约读写，因此需要对DataContract添加读写控制。我们给DataContract添加一个mapping, 用来控制哪些地址可以访问数据，同时添加了修饰器及设置访问的方法，代码如下： 1234567891011121314151617181920212223242526272829pragma solidity ^0.4.18;contract DataContract &#123; mapping (address =&gt; uint256) public balanceOf; mapping (address =&gt; bool) accessAllowed; function DataContract() public &#123; accessAllowed[msg.sender] = true; &#125; function setBlance(address _address,uint256 v) public &#123; balanceOf[_address] = v; &#125; modifier platform() &#123; require(accessAllowed[msg.sender] == true); _; &#125; function allowAccess(address _addr) platform public &#123; accessAllowed[_addr] = true; &#125; function denyAccess(address _addr) platform public &#123; accessAllowed[_addr] = false; &#125;&#125;... 订阅我的小专栏可参看合约的完整代码。 部署方法如下： 先部署DataContract合约 使用DataContract合约地址作为部署ControlContract合约的参数 用ControlContract合约地址作为参数调用DataContract合约的allowAccess方法。如果需要更新控制合约(如修复了addTen)则重新执行第2-3步，同时对老的控制合约执行denyAccess()。 更多当我们在实现数据合约时，它包含的逻辑应该越少越好，并且应该是严格测试过的，因为一旦数据合约部署之后，就没法更改。大多数情况下，和用户交互的是DApp， 因此当控制合约升级之后，需要升级DApp，使之关联新的控制合约。 尽管合约可以通过本文的方式升级，但我们依然要谨慎升级，因为升级表示你可以重写逻辑，会降低用户对你的信任度。本文介绍升级方法更多的是一种思路，实际项目中可能会对应多个控制合约及数据合约。 欢迎来我的知识星球讨论区块链技术。 深入浅出区块链 - 系统学习区块链，打造最好的区块链技术博客。","categories":[{"name":"以太坊","slug":"ethereum","permalink":"https://learnblockchain.cn/categories/ethereum/"},{"name":"智能合约","slug":"ethereum/智能合约","permalink":"https://learnblockchain.cn/categories/ethereum/智能合约/"}],"tags":[{"name":"智能合约","slug":"智能合约","permalink":"https://learnblockchain.cn/tags/智能合约/"}]},{"title":"智能合约语言 Solidity 教程系列8 - Solidity API","slug":"solidity-api","date":"2018-03-14T15:04:43.000Z","updated":"2018-03-18T13:55:32.192Z","comments":true,"path":"2018/03/14/solidity-api/","link":"","permalink":"https://learnblockchain.cn/2018/03/14/solidity-api/","excerpt":"这是Solidity教程系列文章第8篇介绍Solidity API，它们主要表现为内置的特殊的变量及函数，存在于全局命名空间里。 Solidity 系列完整的文章列表请查看分类-Solidity。","text":"这是Solidity教程系列文章第8篇介绍Solidity API，它们主要表现为内置的特殊的变量及函数，存在于全局命名空间里。 Solidity 系列完整的文章列表请查看分类-Solidity。 写在前面Solidity 是以太坊智能合约编程语言，阅读本文前，你应该对以太坊、智能合约有所了解，如果你还不了解，建议你先看以太坊是什么 欢迎订阅区块链技术专栏阅读更全面的分析文章。 Solidity API 主要表现为Solidity 内置的特殊的变量及函数，他们存在于全局命名空间里，主要分为以下几类： 有关区块和交易的属性 有关错误处理 有关数学及加密功能 地址相关 合约相关 下面详细讲解下 区块和交易的属性（Block And Transaction Properties）用来提供一些区块链当前的信息。 block.blockhash(uint blockNumber) returns (bytes32)：返回给定区块号的哈希值，只支持最近256个区块，且不包含当前区块。 block.coinbase (address): 当前块矿工的地址。 block.difficulty (uint):当前块的难度。 block.gaslimit (uint):当前块的gaslimit。 block.number (uint):当前区块的块号。 block.timestamp (uint): 当前块的Unix时间戳（从1970/1/1 00:00:00 UTC开始所经过的秒数） msg.data (bytes): 完整的调用数据（calldata）。 msg.gas (uint): 当前还剩的gas。 msg.sender (address): 当前调用发起人的地址。 msg.sig (bytes4):调用数据(calldata)的前四个字节（例如为：函数标识符）。 msg.value (uint): 这个消息所附带的以太币，单位为wei。 now (uint): 当前块的时间戳(block.timestamp的别名) tx.gasprice (uint) : 交易的gas价格。 tx.origin (address): 交易的发送者（全调用链） 注意：msg的所有成员值，如msg.sender,msg.value的值可以因为每一次外部函数调用，或库函数调用发生变化（因为msg就是和调用相关的全局变量）。 不应该依据 block.timestamp, now 和 block.blockhash来产生一个随机数（除非你确实需要这样做），这几个值在一定程度上被矿工影响（比如在赌博合约里，不诚实的矿工可能会重试去选择一个对自己有利的hash）。 对于同一个链上连续的区块来说，当前区块的时间戳（timestamp）总是会大于上一个区块的时间戳。 为了可扩展性的原因，你只能查最近256个块，所有其它的将返回0. 错误处理 assert(bool condition)用于判断内部错误，条件不满足时抛出异常 require(bool condition):用于判断输入或外部组件错误，条件不满足时抛出异常 revert():终止执行并还原改变的状态 数学及加密功能 addmod(uint x, uint y, uint k) returns (uint):计算(x + y) % k，加法支持任意的精度且不会在2**256处溢出，从0.5.0版本开始断言k != 0。 mulmod(uint x, uint y, uint k) returns (uint):计算 (x y) % k， 乘法支持任意的精度且不会在2*256处溢出， 从0.5.0版本开始断言k != 0。 keccak256(…) returns (bytes32):使用以太坊的（Keccak-256）计算HASH值。紧密打包参数。 sha256(…) returns (bytes32):使用SHA-256计算hash值，紧密打包参数。 sha3(…) returns (bytes32):keccak256的别名 ripemd160(…) returns (bytes20):使用RIPEMD-160计算HASH值。紧密打包参数。 ecrecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) returns (address):通过椭圆曲线签名来恢复与公钥关联的地址，或者在错误时返回零。可用于签名数据的校验，如果返回结果是签名者的公匙地址，那么说明数据是正确的。 ecrecover函数需要四个参数，需要被签名数据的哈希结果值，r，s，v分别来自签名结果串。r = signature[0:64]s = signature[64:128]v = signature[128:130]其中v取出来的值或者是00或01。要使用时，我们先要将其转为整型，再加上27，所以我们将得到27或28。在调用函数时v将填入27或28。 用javascript表达如下:1234567var msg = '0x8CbaC5e4d803bE2A3A5cd3DbE7174504c6DD0c1C'var hash = web3.sha3(msg)var sig = web3.eth.sign(address, h).slice(2)var r = `0x$&#123;sig.slice(0, 64)&#125;`var s = `0x$&#123;sig.slice(64, 128)&#125;`var v = web3.toDecimal(sig.slice(128, 130)) + 27 订阅区块链技术专栏可以参考到完整的使用例子。 紧密打包参数（tightly packed）意思是说参数不会补位，是直接连接在一起的，下面几个是相等的。 123456keccak256(&quot;ab&quot;, &quot;c&quot;)keccak256(&quot;abc&quot;)keccak256(0x616263) // hexkeccak256(6382179)keccak256(97, 98, 99) //ascii 如果需要填充，可以使用显式类型转换：keccak256(“\\x00\\x12”) 与keccak256(uint16(0x12))相同。 注意，常量将使用存储它们所需的最少字节数来打包，例如keccak256(0) == keccak256(uint8(0))和keccak256(0x12345678) == keccak256(uint32(0x12345678)) 在私链(private blockchain)上运行sha256,ripemd160或ecrecover可能会出现Out-Of-Gas报错。因为私链实现了一种预编译合约，合约要在收到第一个消息后才会真正存在（虽然他们的合约代码是硬编码的）。而向一个不存在的合约发送消息，所以才会导致Out-Of-Gas的问题。一种解决办法（workaround）是每个在你真正使用它们之前先发送1 wei到这些合约上来完成初始化。在官方和测试链上没有这个问题。 地址相关 .balance (uint256):Address的余额，以wei为单位。 .transfer(uint256 amount):发送给定数量的ether到某个地址，以wei为单位。失败时抛出异常。 .send(uint256 amount) returns (bool):发送给定数量的ether到某个地址，以wei为单位, 失败时返回false。 .call(…) returns (bool):发起底层的call调用。失败时返回false。 .callcode(…) returns (bool):发起底层的callcode调用，失败时返回false。不鼓励使用，未来可能会移除。 .delegatecall(…) returns (bool):发起底层的delegatecall调用，失败时返回false 更多信息参考地址篇。 警告：send() 执行有一些风险：如果调用栈的深度超过1024或gas耗光，交易都会失败。因此，为了保证安全，必须检查send的返回值，如果交易失败，会回退以太币。如果用transfer会更好。 合约相关 this（当前合约的类型）:表示当前合约，可以显式的转换为Address selfdestruct(address recipient):销毁当前合约，并把它所有资金发送到给定的地址。 suicide(address recipient):selfdestruct的别名 另外，当前合约里的所有函数均可支持调用，包括当前函数本身。 参考文档 Special Variables and Functions 深入浅出区块链 - 系统学习区块链，打造最好的区块链技术博客。如果想与我有更密切的交流可以选择加入我的知识星球（星球成员可加入微信技术交流群）","categories":[{"name":"以太坊","slug":"ethereum","permalink":"https://learnblockchain.cn/categories/ethereum/"},{"name":"Solidity","slug":"ethereum/Solidity","permalink":"https://learnblockchain.cn/categories/ethereum/Solidity/"}],"tags":[{"name":"Solidity手册","slug":"Solidity手册","permalink":"https://learnblockchain.cn/tags/Solidity手册/"}]},{"title":"如何通过以太坊智能合约来进行众筹（ICO）","slug":"ico-crowdsale","date":"2018-02-28T12:30:42.000Z","updated":"2018-05-03T02:26:43.863Z","comments":true,"path":"2018/02/28/ico-crowdsale/","link":"","permalink":"https://learnblockchain.cn/2018/02/28/ico-crowdsale/","excerpt":"前面我们有两遍文章写了如何发行代币，今天我们讲一下如何使用代币来公开募资，即编写一个募资合约。","text":"前面我们有两遍文章写了如何发行代币，今天我们讲一下如何使用代币来公开募资，即编写一个募资合约。 写在前面本文所讲的代币是使用以太坊智能合约创建，阅读本文前，你应该对以太坊、智能合约有所了解，如果你还不了解，建议你先看以太坊是什么 众筹先简单说下众筹的概念：一般是这样的，我一个非常好的想法，但是我没有钱来做这事，于是我把这个想法发给大家看，说：我做这件事需要5百万，大家有没有兴趣投些钱，如果大家在30天内投够了5百万我就开始做，到时大家都是原始股东，如果募资额不到5百万，大家投的钱就还给大家。 现在ICO众筹已经被各路大佬拿来割韭菜而被玩坏了（不管有无达标，都把钱卷走）。 其实区块链技术本事非常适合解决众筹的信任问题，借助于智能合约，可以实现当募资额完成时，募资款自动打到指定账户，当募资额未完成时，可退款。这个过程不需要看众筹大佬的人品，不用依靠第三方平台信用担保。 代币传统的众筹在参与之后通常不容易交易（参与之后无法转给其他人），而通过用代币来参与众筹，则很容易进行交易，众筹的参与人可随时进行买卖，待众筹项目实施完成的时候，完全根据代币持有量进行回馈。 举个例子说明下，大家会更容易理解，有这一个众筹：A有技术做一个能监测健康的指环，为此向公众募资200百万，募资时100块对应一个代币，约定在指环上市之后，代币的持有人可以用一个代币来兑换一个指环。而指环的研发周期是一年，因此在指环还未上市的一年里，众筹的参与人可以随时交易所持有的代币。 众筹智能合约代码接下来就看看如何实现一个众筹智能合约。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104pragma solidity ^0.4.16;interface token &#123; function transfer(address receiver, uint amount);&#125;contract Crowdsale &#123; address public beneficiary; // 募资成功后的收款方 uint public fundingGoal; // 募资额度 uint public amountRaised; // 参与数量 uint public deadline; // 募资截止期 uint public price; // token 与以太坊的汇率 , token卖多少钱 token public tokenReward; // 要卖的token mapping(address =&gt; uint256) public balanceOf; bool fundingGoalReached = false; // 众筹是否达到目标 bool crowdsaleClosed = false; // 众筹是否结束 /** * 事件可以用来跟踪信息 **/ event GoalReached(address recipient, uint totalAmountRaised); event FundTransfer(address backer, uint amount, bool isContribution); /** * 构造函数, 设置相关属性 */ function Crowdsale( address ifSuccessfulSendTo, uint fundingGoalInEthers, uint durationInMinutes, uint finneyCostOfEachToken, address addressOfTokenUsedAsReward) &#123; beneficiary = ifSuccessfulSendTo; fundingGoal = fundingGoalInEthers * 1 ether; deadline = now + durationInMinutes * 1 minutes; price = finneyCostOfEachToken * 1 finney; tokenReward = token(addressOfTokenUsedAsReward); // 传入已发布的 token 合约的地址来创建实例 &#125; /** * 无函数名的Fallback函数， * 在向合约转账时，这个函数会被调用 */ function () payable &#123; require(!crowdsaleClosed); uint amount = msg.value; balanceOf[msg.sender] += amount; amountRaised += amount; tokenReward.transfer(msg.sender, amount / price); FundTransfer(msg.sender, amount, true); &#125; /** * 定义函数修改器modifier（作用和Python的装饰器很相似） * 用于在函数执行前检查某种前置条件（判断通过之后才会继续执行该方法） * _ 表示继续执行之后的代码 **/ modifier afterDeadline() &#123; if (now &gt;= deadline) _; &#125; /** * 判断众筹是否完成融资目标， 这个方法使用了afterDeadline函数修改器 * */ function checkGoalReached() afterDeadline &#123; if (amountRaised &gt;= fundingGoal) &#123; fundingGoalReached = true; GoalReached(beneficiary, amountRaised); &#125; crowdsaleClosed = true; &#125; /** * 完成融资目标时，融资款发送到收款方 * 未完成融资目标时，执行退款 * */ function safeWithdrawal() afterDeadline &#123; if (!fundingGoalReached) &#123; uint amount = balanceOf[msg.sender]; balanceOf[msg.sender] = 0; if (amount &gt; 0) &#123; if (msg.sender.send(amount)) &#123; FundTransfer(msg.sender, amount, false); &#125; else &#123; balanceOf[msg.sender] = amount; &#125; &#125; &#125; if (fundingGoalReached &amp;&amp; beneficiary == msg.sender) &#123; if (beneficiary.send(amountRaised)) &#123; FundTransfer(beneficiary, amountRaised, false); &#125; else &#123; //If we fail to send the funds to beneficiary, unlock funders balance fundingGoalReached = false; &#125; &#125; &#125;&#125; 部署及说明在部署这个合约之前，我们需要先部署一个代币合约，请参考一步步教你创建自己的数字货币。 创建众筹合约我们需要提供一下几个参数：ifSuccessfulSendTo： 募资成功后的收款方（其实这里可以默认为合约创建者）fundingGoalInEthers： 募资额度， 为了方便我们仅募3个etherdurationInMinutes： 募资时间finneyCostOfEachToken 每个代币的价格, 这里为了方便使用了单位finney及值为：1 （1 ether = 1000 finney）addressOfTokenUsedAsReward： 代币合约地址。如：本文使用的参数为： 1&quot;0xc6f9ea59d424733e8e1902c7837ea75e20abfb49&quot;,3, 100, 1,&quot;0xad8972e2b583f580fc52f737b98327eb65d08f8c&quot; 参与人投资的时候实际购买众筹合约代币，所以需要先向合约预存代币，代币的数量为：募资额度 / 代币的价格 ， 这里为：3 * 1000/1 = 3000 （当能也可以大于3000）。向合约预存代币可以使用myetherwallet钱包，或在remix中重新加载代币合约，执行代币合约tranfer()函数进行代币转账，转账的地址就是我们创建合约的地址。如使用myetherwallet转账如图： 投资人向众筹合约转账（发送以太币）即是参与众筹行为，转账时，会执行Fallback回退函数（即无名函数）向其账户打回相应的代币。 safeWithdrawl() 可以被参与人或收益人调用，如果融资不达标参与人可收回之前投资款，如果融资达标收益人可以拿到所有的融资款。 扩展上面是一个很正规的募资合约。接下来讲两个募资合约的扩展，如何实现无限募资合约及割韭菜合约。这部分内容独家发布在我的小专栏区块链技术 如果你在学习中遇到问题，欢迎到我的知识星球提问，作为星球成员福利，成员可加入区块链技术付费交流群。 参考文档 Create a crowdsale 深入浅出区块链 - 系统学习区块链，打造最好的区块链技术博客。","categories":[{"name":"以太坊","slug":"ethereum","permalink":"https://learnblockchain.cn/categories/ethereum/"},{"name":"智能合约","slug":"ethereum/智能合约","permalink":"https://learnblockchain.cn/categories/ethereum/智能合约/"}],"tags":[{"name":"智能合约","slug":"智能合约","permalink":"https://learnblockchain.cn/tags/智能合约/"},{"name":"Token","slug":"Token","permalink":"https://learnblockchain.cn/tags/Token/"},{"name":"ICO","slug":"ICO","permalink":"https://learnblockchain.cn/tags/ICO/"}]},{"title":"什么是拜占庭将军问题","slug":"bitcoin-byzantine","date":"2018-02-04T16:00:00.000Z","updated":"2018-07-16T04:44:51.302Z","comments":true,"path":"2018/02/05/bitcoin-byzantine/","link":"","permalink":"https://learnblockchain.cn/2018/02/05/bitcoin-byzantine/","excerpt":"接触区块链的同学，多少都听说过拜占庭将军问题，经常看到或听到某某区块链使用某某算法解决了拜占庭将军问题，那么究竟什么是拜占庭将军问题呢?","text":"接触区块链的同学，多少都听说过拜占庭将军问题，经常看到或听到某某区块链使用某某算法解决了拜占庭将军问题，那么究竟什么是拜占庭将军问题呢? 什么是拜占庭将军问题也被称为“拜占庭容错”、“拜占庭将军问题”。拜占庭将军问题是Leslie Lamport（2013年的图灵讲得主）用来为描述分布式系统一致性问题（Distributed Consensus）在论文中抽象出来一个著名的例子。 这个例子大意是这样的： 拜占庭帝国想要进攻一个强大的敌人，为此派出了10支军队去包围这个敌人。这个敌人虽不比拜占庭帝国，但也足以抵御5支常规拜占庭军队的同时袭击。这10支军队在分开的包围状态下同时攻击。他们任一支军队单独进攻都毫无胜算，除非有至少6支军队（一半以上）同时袭击才能攻下敌国。他们分散在敌国的四周，依靠通信兵骑马相互通信来协商进攻意向及进攻时间。困扰这些将军的问题是，他们不确定他们中是否有叛徒，叛徒可能擅自变更进攻意向或者进攻时间。在这种状态下，拜占庭将军们才能保证有多于6支军队在同一时间一起发起进攻，从而赢取战斗？ 拜占庭将军问题中并不去考虑通信兵是否会被截获或无法传达信息等问题，即消息传递的信道绝无问题。Lamport已经证明了在消息可能丢失的不可靠信道上试图通过消息传递的方式达到一致性是不可能的。所以，在研究拜占庭将军问题的时候，已经假定了信道是没有问题的. 问题分析单从上面的说明可能无法理解这个问题的复杂性，我们来简单分析一下： 先看在没有叛徒情况下，假如一个将军A提一个进攻提议（如：明日下午1点进攻，你愿意加入吗？）由通信兵通信分别告诉其他的将军，如果幸运中的幸运，他收到了其他6位将军以上的同意，发起进攻。如果不幸，其他的将军也在此时发出不同的进攻提议（如：明日下午2点、3点进攻，你愿意加入吗？），由于时间上的差异，不同的将军收到（并认可）的进攻提议可能是不一样的，这是可能出现A提议有3个支持者，B提议有4个支持者，C提议有2个支持者等等。 再加一点复杂性，在有叛徒情况下，一个叛徒会向不同的将军发出不同的进攻提议（通知A明日下午1点进攻， 通知B明日下午2点进攻等等），一个叛徒也会可能同意多个进攻提议（即同意下午1点进攻又同意下午2点进攻）。 叛徒发送前后不一致的进攻提议，被称为“拜占庭错误”，而能够处理拜占庭错误的这种容错性称为「Byzantine fault tolerance」，简称为BFT。 相信大家已经可以明白这个问题的复杂性了。 中本聪的解决方案在出现比特币之前，解决分布式系统一致性问题主要是Lamport提出的Paxos算法或其衍生算法。Paxos类算法仅适用于中心化的分布式系统，这样的系统的没有不诚实的节点（不会发送虚假错误消息，但允许出现网络不通或宕机出现的消息延迟）。 中本聪在比特币中创造性的引入了“工作量证明（POW : Proof of Work）”来解决这个问题，有兴趣可进一步阅读工作量证明。通过工作量证明就增加了发送信息的成本，降低节点发送消息速率，这样就以保证在一个时间只有一个节点(或是很少)在进行广播，同时在广播时会附上自己的签名。这个过程就像一位将军A在向其他的将军（B、C、D…）发起一个进攻提议一样，将军B、C、D…看到将军A签过名的进攻提议书，如果是诚实的将军就会立刻同意进攻提议，而不会发起自己新的进攻提议。 以上就是比特币网络中是单个区块（账本）达成共识的方法（取得一致性）。 理解了单个区块取得一致性的方法，那么整个区块链（总账本）如果达成一致也好理解。我们稍微把将军问题改一下：假设攻下一个城堡需要多次的进攻，每次进攻的提议必须基于之前最多次数的胜利进攻下提出的（只有这样敌方已有损失最大，我方进攻胜利的可能性就更大），这样约定之后，将军A在收到进攻提议时，就会检查一下这个提议是不是基于最多的胜利提出的，如果不是（基于最多的胜利）将军A就不会同意这样的提议，如果是的，将军A就会把这次提议记下来。 这就是比特币网络最长链选择。 经济学分析工作量证明其实相当于提高了做叛徒（发布虚假区块）的成本，在工作量证明下，只有第一个完成证明的节点才能广播区块，竞争难度非常大，需要很高的算力，如果不成功其算力就白白的耗费了（算力是需要成本的），如果有这样的算力作为诚实的节点，同样也可以获得很大的收益（这就是矿工所作的工作），这也实际就不会有做叛徒的动机，整个系统也因此而更稳定。 很多人批评工作量证明造成巨大的电力浪费，促使人们去探索新的解决一致性（共识）问题的机制：权益证明机制（POS: Proof of Stake）是一个代表。在拜占庭将军问题的角度来看，它同样提高了做叛徒的成本，因为账户需要首先持有大量余额才能有更多的几率广播区块，POS不是本文重点，以后在讲。 共识算法的核心就是解决拜占庭将军问题（分布式网络一致性问题）。 扩展阅读The Byzantine Generals Problem 深入浅出区块链 - 系统学习区块链，打造最好的区块链技术博客。如果想与我有更密切的交流可以选择加入我的知识星球（星球成员可加入微信技术交流群）","categories":[{"name":"比特币","slug":"bitcoin","permalink":"https://learnblockchain.cn/categories/bitcoin/"}],"tags":[{"name":"比特币","slug":"比特币","permalink":"https://learnblockchain.cn/tags/比特币/"},{"name":"共识协议","slug":"共识协议","permalink":"https://learnblockchain.cn/tags/共识协议/"}]},{"title":"智能合约语言 Solidity 教程系列7 - 以太单位及时间单位","slug":"solidity-unit","date":"2018-02-02T11:51:03.000Z","updated":"2018-03-19T03:26:58.537Z","comments":true,"path":"2018/02/02/solidity-unit/","link":"","permalink":"https://learnblockchain.cn/2018/02/02/solidity-unit/","excerpt":"这是Solidity教程系列文章第7篇介绍以太单位及时间单位，系列带你全面深入理解Solidity语言。Solidity 系列完整的文章列表请查看分类-Solidity。","text":"这是Solidity教程系列文章第7篇介绍以太单位及时间单位，系列带你全面深入理解Solidity语言。Solidity 系列完整的文章列表请查看分类-Solidity。 写在前面Solidity 是以太坊智能合约编程语言，阅读本文前，你应该对以太坊、智能合约有所了解，如果你还不了解，建议你先看以太坊是什么 欢迎订阅区块链技术专栏阅读更全面的分析文章。 货币单位（Ether Units）一个数字常量（字面量）后面跟随一个后缀wei, finney,szabo或ether，这个后缀就是货币单位。不同的单位可以转换。不含任何后缀的默认单位是wei。不同的以太币单位转换关系如下： 1 ether == 10^3 finney == 1000 finney 1 ether == 10^6 szabo 1 ether == 10^18 wei 插曲：以太币单位其实是密码学家的名字，是以太坊创始人为了纪念他们在数字货币的领域的贡献。他们分别是：wei: Wei Dai 戴伟 密码学家 ，发表 B-moneyfinney: Hal Finney 芬尼 密码学家、工作量证明机制（POW）提出szabo: Nick Szabo 尼克萨博 密码学家、智能合约的提出者 我们可以使用一下代码验证一个转换关系：123456789101112131415161718192021222324pragma solidity ^0.4.16;contract testUnit &#123; function tf() public pure returns (bool) &#123; if (1 ether == 1000 finney)&#123; return true; &#125; return false; &#125; function ts() public pure returns (bool) &#123; if (1 ether == 1000000 szabo)&#123; return true; &#125; return false; &#125; function tgw() public pure returns (bool) &#123; if (1 ether == 1000000000000000000 wei)&#123; return true; &#125; return false; &#125;&#125; 时间单位（Time Units）时间单位: seconds, minutes, hours, days, weeks, years均可做为后缀，并进行相互转换，规则如下： 1 == 1 seconds (默认是seconds为单位) 1 minutes == 60 seconds 1 hours == 60 minutes 1 days == 24 hours 1 weeks = 7 days 1 years = 365 days 使用这些单位进行日期计算需要特别小心，因为不是每年都是365天，且并不是每天都有24小时，因为还有闰秒。由于无法预测闰秒，必须由外部的预言（oracle）来更新从而得到一个精确的日历库。 这些后缀不能用于变量。如果想对输入的变量说明其不同的单位，可以使用下面的方式：1234567891011121314pragma solidity ^0.4.16;contract testTUnit &#123; function currTimeInSeconds() public pure returns (uint256)&#123; return now; &#125; function f(uint start, uint daysAfter) public &#123; if (now &gt;= start + daysAfter * 1 days) &#123; // ... &#125; &#125;&#125; 参考文档 units 深入浅出区块链 - 系统学习区块链，打造最好的区块链技术博客。如果想与我有更密切的交流可以选择加入我的知识星球（星球成员可加入微信技术交流群）","categories":[{"name":"以太坊","slug":"ethereum","permalink":"https://learnblockchain.cn/categories/ethereum/"},{"name":"Solidity","slug":"ethereum/Solidity","permalink":"https://learnblockchain.cn/categories/ethereum/Solidity/"}],"tags":[{"name":"Solidity手册","slug":"Solidity手册","permalink":"https://learnblockchain.cn/tags/Solidity手册/"}]},{"title":"实现一个可管理、增发、兑换、冻结等高级功能的代币","slug":"create-token2","date":"2018-01-27T09:04:13.000Z","updated":"2018-04-09T14:52:20.591Z","comments":true,"path":"2018/01/27/create-token2/","link":"","permalink":"https://learnblockchain.cn/2018/01/27/create-token2/","excerpt":"本文主要介绍代币高级功能的实现: 代币管理、代币增发、代币兑换、资产冻结、Gas自动补充。","text":"本文主要介绍代币高级功能的实现: 代币管理、代币增发、代币兑换、资产冻结、Gas自动补充。 写在前面在上一篇：一步步教你创建自己的数字货币（代币）进行ICO中我们实现一个最基本功能的代币，本文将在上一遍文章的基础上，讲解如果添加更多的高级功能。 实现代币的管理者虽然区块链是去中心化的，但是实现对代币（合约）的管理，也在许多应用中有需求，为了对代币进行管理，首先需要给合约添加一个管理者。 我们来看看如果实现，先创建一个owned合约。 1234567891011121314151617contract owned &#123; address public owner; function owned() &#123; owner = msg.sender; &#125; modifier onlyOwner &#123; require(msg.sender == owner); _; &#125; // 实现所有权转移 function transferOwnership(address newOwner) onlyOwner &#123; owner = newOwner; &#125;&#125; 这个合约重要的是加入了一个函数修改器（Function Modifiers）onlyOwner，函数修改器是一个合约属性，可以被继承，还能被重写。它用于在函数执行前检查某种前置条件。关于函数修改器可进一步阅读Solidity 教程系列10 - 完全理解函数修改器 如果熟悉Python的同学，会发现函数修改器的作用和Python的装饰器很相似。 然后让代币合约继承owned以拥有onlyOwner修改器，代码如下：1234567891011contract MyToken is owned &#123; function MyToken( uint256 initialSupply, string tokenName, uint8 decimalUnits, string tokenSymbol, address centralMinter ) &#123; if(centralMinter != 0 ) owner = centralMinter; &#125;&#125; 代币增发实现代币增发，代币增发就如同央行印钞票一样，想必很多人都需要这样的功能。 给合约添加以下的方法：123456function mintToken(address target, uint256 mintedAmount) onlyOwner &#123; balanceOf[target] += mintedAmount; totalSupply += mintedAmount; Transfer(0, owner, mintedAmount); Transfer(owner, target, mintedAmount); &#125; 注意onlyOwner修改器添加在函数末尾，这表示只有ower才能调用这用函数。他的功能很简单，就是给指定的账户增加代币，同时增加总供应量。 资产冻结有时为了监管的需要，需要实现冻结某些账户，冻结后，其资产仍在账户，但是不允许交易，之道解除冻结。给合约添加以下的变量和方法（可以添加到合约的任何地方，但是建议把mapping加到和其他mapping一起，event也是如此）：1234567mapping (address =&gt; bool) public frozenAccount;event FrozenFunds(address target, bool frozen);function freezeAccount(address target, bool freeze) onlyOwner &#123; frozenAccount[target] = freeze; FrozenFunds(target, freeze);&#125; 单单以上的代码还无法冻结，需要把他加入到transfer函数中才能真正生效，因此修改transfer函数1234function transfer(address _to, uint256 _value) &#123; require(!frozenAccount[msg.sender]); ...&#125; 这样在转账前，对发起交易的账号做一次检查，只有不是被冻结的账号才能转账。 代币买卖（兑换）可以自己的货币中实现代币与其他数字货币（ether 或其他tokens）的兑换机制。有了这个功能，我们的合约就可以在一买一卖中赚利润了。 先来设置下买卖价格1234567uint256 public sellPrice;uint256 public buyPrice;function setPrices(uint256 newSellPrice, uint256 newBuyPrice) onlyOwner &#123; sellPrice = newSellPrice; buyPrice = newBuyPrice;&#125; setPrices()添加了onlyOwner修改器，注意买卖的价格单位是wei（最小的货币单位： 1 eth = 1000000000000000000 wei) 添加来添加买卖函数:123456789101112131415161718function buy() payable returns (uint amount)&#123; amount = msg.value / buyPrice; // calculates the amount require(balanceOf[this] &gt;= amount); // checks if it has enough to sell balanceOf[msg.sender] += amount; // adds the amount to buyer's balance balanceOf[this] -= amount; // subtracts amount from seller's balance Transfer(this, msg.sender, amount); // execute an event reflecting the change return amount; // ends function and returns&#125;function sell(uint amount) returns (uint revenue)&#123; require(balanceOf[msg.sender] &gt;= amount); // checks if the sender has enough to sell balanceOf[this] += amount; // adds the amount to owner's balance balanceOf[msg.sender] -= amount; // subtracts the amount from seller's balance revenue = amount * sellPrice; msg.sender.transfer(revenue); // sends ether to the seller: it's important to do this last to prevent recursion attacks Transfer(msg.sender, this, amount); // executes an event reflecting on the change return revenue; // ends function and returns&#125; 加入了买卖功能后，要求我们在创建合约时发送足够的以太币，以便合约有能力回购市面上的代币，否则合约将破产，用户没法先合约卖代币。 实现Gas的自动补充以太坊中的交易时需要gas（支付给矿工的费用，费用以ether来支付）。而如果用户没有以太币，只有代币的情况（或者我们想向用户隐藏以太坊的细节），就需要自动补充gas的功能。这个功能将使我们代币更加好用。 自动补充的逻辑是这样了，在执行交易之前，我们判断用户的余额（用来支付矿工的费用），如果用户的余额非常少（低于某个阈值时）可能影响到交易进行，合约自动售出一部分代币来补充余额，以帮助用户顺利完成交易。 先来设定余额阈值：12345uint minBalanceForAccounts; function setMinBalance(uint minimumBalanceInFinney) onlyOwner &#123; minBalanceForAccounts = minimumBalanceInFinney * 1 finney; &#125; finney 是货币单位 1 finney = 0.001eth然后交易中加入对用户的余额的判断。1234567function transfer(address _to, uint256 _value) &#123; ... if(msg.sender.balance &lt; minBalanceForAccounts) sell((minBalanceForAccounts - msg.sender.balance) / sellPrice); if(_to.balance&lt;minBalanceForAccounts) // 可选，让接受者也补充余额，以便接受者使用代币。 _to.send(sell((minBalanceForAccounts - _to.balance) / sellPrice));&#125; 代码部署高级功能完整代码请前往我的小专栏， 项目的完整的部署方法参考上一篇，不同的是创建合约时需要预存余额，如图： 专栏已经有多篇文章介绍Remix Solidity IDE的使用，这里就不一一截图演示了，请大家自己测试验证。 如果你在创建代币的过程中遇到问题，欢迎到我的知识星球提问，作为星球成员福利，成员可加入区块链技术付费交流群。 参考文档 Create your own crypto-currency with ethereum 深入浅出区块链 - 系统学习区块链，打造最好的区块链技术博客。","categories":[{"name":"以太坊","slug":"ethereum","permalink":"https://learnblockchain.cn/categories/ethereum/"},{"name":"智能合约","slug":"ethereum/智能合约","permalink":"https://learnblockchain.cn/categories/ethereum/智能合约/"}],"tags":[{"name":"智能合约","slug":"智能合约","permalink":"https://learnblockchain.cn/tags/智能合约/"},{"name":"Token","slug":"Token","permalink":"https://learnblockchain.cn/tags/Token/"}]},{"title":"一步步教你创建自己的数字货币（代币）进行ICO","slug":"create_token","date":"2018-01-12T14:36:39.000Z","updated":"2018-02-08T12:34:13.385Z","comments":true,"path":"2018/01/12/create_token/","link":"","permalink":"https://learnblockchain.cn/2018/01/12/create_token/","excerpt":"本文从技术角度详细介绍如何基于以太坊ERC20创建代币的流程.","text":"本文从技术角度详细介绍如何基于以太坊ERC20创建代币的流程. 写在前面本文所讲的代币是使用以太坊智能合约创建，阅读本文前，你应该对以太坊、智能合约有所了解，如果你还不了解，建议你先看以太坊是什么 代币Token如果不那么追求精确的定义，代币就是数字货币，比特币、以太币就是一个代币。利用以太坊的智能合约可以轻松编写出属于自己的代币，代币可以代表任何可以交易的东西，如：积分、财产、证书等等。因此不管是出于商业，还是学习很多人想创建一个自己的代币，先贴一个图看看创建的代币是什么样子。 今天我们就来详细讲一讲怎样创建一个这样的代币。 ERC20 Token也许你经常看到ERC20和代币一同出现， ERC20是以太坊定义的一个代币标准。要求我们在实现代币的时候必须要遵守的协议，如指定代币名称、总量、实现代币交易函数等，只有支持了协议才能被以太坊钱包支持。其接口如下： 12345678910111213141516contract ERC20Interface &#123; string public constant name = \"Token Name\"; string public constant symbol = \"SYM\"; uint8 public constant decimals = 18; // 18 is the most common number of decimal places function totalSupply() public constant returns (uint); function balanceOf(address tokenOwner) public constant returns (uint balance); function allowance(address tokenOwner, address spender) public constant returns (uint remaining); function transfer(address to, uint tokens) public returns (bool success); function approve(address spender, uint tokens) public returns (bool success); function transferFrom(address from, address to, uint tokens) public returns (bool success); event Transfer(address indexed from, address indexed to, uint tokens); event Approval(address indexed tokenOwner, address indexed spender, uint tokens);&#125; 简单说明一下：name ： 代币名称symbol： 代币符号decimals： 代币小数点位数，代币的最小单位， 18表示我们可以拥有 .0000000000000000001单位个代币。totalSupply() : 发行代币总量。balanceOf(): 查看对应账号的代币余额。transfer(): 实现代币交易，用于给用户发送代币（从我们的账户里）。transferFrom(): 实现代币用户之间的交易。allowance(): 控制代币的交易，如可交易账号及资产。approve(): 允许用户可花费的代币数。 编写代币合约代码代币合约代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980pragma solidity ^0.4.16;interface tokenRecipient &#123; function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) public; &#125;contract TokenERC20 &#123; string public name; string public symbol; uint8 public decimals = 18; // 18 是建议的默认值 uint256 public totalSupply; mapping (address =&gt; uint256) public balanceOf; // mapping (address =&gt; mapping (address =&gt; uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20(uint256 initialSupply, string tokenName, string tokenSymbol) public &#123; totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; &#125; function _transfer(address _from, address _to, uint _value) internal &#123; require(_to != 0x0); require(balanceOf[_from] &gt;= _value); require(balanceOf[_to] + _value &gt; balanceOf[_to]); uint previousBalances = balanceOf[_from] + balanceOf[_to]; balanceOf[_from] -= _value; balanceOf[_to] += _value; Transfer(_from, _to, _value); assert(balanceOf[_from] + balanceOf[_to] == previousBalances); &#125; function transfer(address _to, uint256 _value) public &#123; _transfer(msg.sender, _to, _value); &#125; function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) &#123; require(_value &lt;= allowance[_from][msg.sender]); // Check allowance allowance[_from][msg.sender] -= _value; _transfer(_from, _to, _value); return true; &#125; function approve(address _spender, uint256 _value) public returns (bool success) &#123; allowance[msg.sender][_spender] = _value; return true; &#125; function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) &#123; tokenRecipient spender = tokenRecipient(_spender); if (approve(_spender, _value)) &#123; spender.receiveApproval(msg.sender, _value, this, _extraData); return true; &#125; &#125; function burn(uint256 _value) public returns (bool success) &#123; require(balanceOf[msg.sender] &gt;= _value); balanceOf[msg.sender] -= _value; totalSupply -= _value; Burn(msg.sender, _value); return true; &#125; function burnFrom(address _from, uint256 _value) public returns (bool success) &#123; require(balanceOf[_from] &gt;= _value); require(_value &lt;= allowance[_from][msg.sender]); balanceOf[_from] -= _value; allowance[_from][msg.sender] -= _value; totalSupply -= _value; Burn(_from, _value); return true; &#125;&#125; 代码的详细解读，请订阅我的小专栏。 部署在开发测试智能合约时，MetaMask和Remix Solidity IDE是两个非常好用的工具，今天就用他们来完成部署。 安装和配置MetaMask请参考开发、部署第一个去中心化应用，不同的上本文选择了以太坊的测试网络Ropsten，如果你没有余额请点击购买buy，进入的网站可以送一些测试以太币给你，配置好之后，界面应该如下： 浏览器打开Remix Solidity IDE，\b复制以上源码粘贴上，在右侧选项参考如图的设置：注意Environment和Account和MetaMask保持一致，然后选择合约TokenERC20，填入你想要的发行量，名称及代号，就可以创建合约了。这时MetaMask会弹出一个交易确认框，点SUBMIT。待合约部署交易确认之后，复制合约地址。 打开Metamask界面，切换到TOKENS，点添加合约，出现如下对话框：填入刚刚复制的地址，点ADD，这时你就可以看到你创建的代币了，如图： 哈哈，你已经完成了代币的创建和部署(正式网络和测试网络部署方法一样)，可以在Etherscan查询到我们刚刚部署的代币。可以用它进行ICO了，从此走上人生巅峰（玩笑话，不鼓励大家发行无意义的代币）。 代币交易由于MetaMask插件没有提供代币交易功能，同时考虑到很多人并没有以太坊钱包或是被以太坊钱包网络同步问题折磨，今天我用网页钱包来讲解代币交易。 进入网页钱包地址, 第一次进入有一些安全提示需要用户确认。 进入之后，按照下图进行设置： 连接上之后，如图需要添加代币，填入代币合约地址。 进行代币转账交易在接下来的交易确认也，点击确认即可。 交易完成后，可以看到MetaMask中代币余额减少了，如图： 代币交易是不是很简单，只要明白了交易流程，使用其他的钱包也是一样的道理。 如果你在创建代币的过程中遇到问题，我的知识星球可为大家解答问题，作为星球成员福利，成员还可加入区块链技术付费交流群。 参考文档 代币标准 Create your own crypto-currency with ethereum 深入浅出区块链 - 系统学习区块链，打造最好的区块链技术博客。","categories":[{"name":"以太坊","slug":"ethereum","permalink":"https://learnblockchain.cn/categories/ethereum/"},{"name":"智能合约","slug":"ethereum/智能合约","permalink":"https://learnblockchain.cn/categories/ethereum/智能合约/"}],"tags":[{"name":"智能合约","slug":"智能合约","permalink":"https://learnblockchain.cn/tags/智能合约/"},{"name":"Token","slug":"Token","permalink":"https://learnblockchain.cn/tags/Token/"}]},{"title":"一步步教你开发、部署第一个去中心化应用(Dapp) - 宠物商店","slug":"first-dapp","date":"2018-01-12T14:36:39.000Z","updated":"2018-01-24T12:39:59.700Z","comments":true,"path":"2018/01/12/first-dapp/","link":"","permalink":"https://learnblockchain.cn/2018/01/12/first-dapp/","excerpt":"今天我们来编写一个完整的去中心化（区块链）应用（Dapps）, 本文可以和编写智能合约结合起来看。","text":"今天我们来编写一个完整的去中心化（区块链）应用（Dapps）, 本文可以和编写智能合约结合起来看。 写在前面阅读本文前，你应该对以太坊、智能合约有所了解，如果你还不了解，建议你先看以太坊是什么除此之外，你最好还了解一些HTML及JavaScript知识。 本文通过实例教大家来开发去中心化应用，应用效果如图： 从本文，你可以学习到： 搭建智能合约开发环境 创建Truffle项目 编写智能合约 编译和部署智能合约到区块链 如何通过Web3和智能合约交互 MetaMask 的使用 小专栏用户在教程结尾处可以下载完整的Dapp代码。 项目背景Pete有一个宠物店，有16只宠物，他想开发一个去中心化应用，让大家来领养宠物。在truffle box中，已经提供了pet-shop的网站部分的代码，我们只需要编写合约及交互部分。 环境搭建 安装Node 安装 Truffle ：npm install -g truffle 安装Ganache Ganache（或Ganache CLI）已经取代了 testrpc。 创建项目 建立项目目录并进入 12&gt; mkdir pet-shop-tutorial&gt; cd pet-shop-tutorial 使用truffle unbox 创建项目 123456789101112 &gt; truffle unbox pet-shop Downloading... Unpacking... Setting up... Unbox successful. Sweet!Commands: Compile: truffle compile Migrate: truffle migrate Test contracts: truffle test Run dev server: npm run dev 这一步需要等待一会 也可以使用truffle init 来创建一个全新的项目。 项目目录结构contracts/ 智能合约的文件夹，所有的智能合约文件都放置在这里，里面包含一个重要的合约Migrations.sol（稍后再讲）migrations/ 用来处理部署（迁移）智能合约 ，迁移是一个额外特别的合约用来保存合约的变化。test/ 智能合约测试用例文件夹truffle.js/ 配置文件 其他代码可以暂时不用管 编写智能合约智能合约承担着分布式应用的后台逻辑和存储。智能合约使用solidity编写，可阅读solidity系列文章 在contracts目录下，添加合约文件Adoption.sol1234567891011121314151617181920pragma solidity ^0.4.17;contract Adoption &#123; address[16] public adopters; // 保存领养者的地址 // 领养宠物 function adopt(uint petId) public returns (uint) &#123; require(petId &gt;= 0 &amp;&amp; petId &lt;= 15); // 确保id在数组长度内 adopters[petId] = msg.sender; // 保存调用这地址 return petId; &#125; // 返回领养者 function getAdopters() public view returns (address[16]) &#123; return adopters; &#125;&#125; 编译部署智能合约Truffle集成了一个开发者控制台，可用来生成一个开发链用来测试和部署智能合约。 编译Solidity是编译型语言，需要把可读的Solidity代码编译为EVM字节码才能运行。dapp的根目录pet-shop-tutorial下，1&gt; truffle compile 输出12Compiling ./contracts/Adoption.sol...Writing artifacts to ./build/contracts 部署编译之后，就可以部署到区块链上。在migrations文件夹下已经有一个1_initial_migration.js部署脚本，用来部署Migrations.sol合约。Migrations.sol 用来确保不会部署相同的合约。 现在我们来创建一个自己的部署脚本2_deploy_contracts.js 12345var Adoption = artifacts.require(&quot;Adoption&quot;);module.exports = function(deployer) &#123; deployer.deploy(Adoption);&#125;; 在执行部署之前，需要确保有一个区块链运行, 可以使用Ganache来开启一个私链来进行开发测试，默认会在7545端口上运行一个开发链。Ganache 启动之后是这样： 接下来执行部署命令:1&gt; truffle migrate 执行后，有一下类似的输出，12345678910111213141516Using network &apos;develop&apos;.Running migration: 1_initial_migration.js Deploying Migrations... ... 0x3076b7dac65afc44ec51508bf6f2b6894f833f0f9560ecad2d6d41ed98a4679f Migrations: 0x8cdaf0cd259887258bc13a92c0a6da92698644c0Saving successful migration to network... ... 0xd7bc86d31bee32fa3988f1c1eabce403a1b5d570340a3a9cdba53a472ee8c956Saving artifacts...Running migration: 2_deploy_contracts.js Deploying Adoption... ... 0x2c6ab4471c225b5473f2079ee42ca1356007e51d5bb57eb80bfeb406acc35cd4 Adoption: 0x345ca3e014aaf5dca488057592ee47305d9b3e10Saving successful migration to network... ... 0xf36163615f41ef7ed8f4a8f192149a0bf633fe1a2398ce001bf44c43dc7bdda0Saving artifacts... 在打开的Ganache里可以看到区块链状态的变化，现在产生了4个区块。这时说明已经智能合约已经部署好了。 测试现在我们来测试一下智能合约，测试用例可以用 JavaScript or Solidity来编写，这里使用Solidity。 在test目录下新建一个TestAdoption.sol，编写测试合约12345678910111213141516171819202122232425262728293031323334pragma solidity ^0.4.17;import \"truffle/Assert.sol\"; // 引入的断言import \"truffle/DeployedAddresses.sol\"; // 用来获取被测试合约的地址import \"../contracts/Adoption.sol\"; // 被测试合约contract TestAdoption &#123; Adoption adoption = Adoption(DeployedAddresses.Adoption()); // 领养测试用例 function testUserCanAdoptPet() public &#123; uint returnedId = adoption.adopt(8); uint expected = 8; Assert.equal(returnedId, expected, \"Adoption of pet ID 8 should be recorded.\"); &#125; // 宠物所有者测试用例 function testGetAdopterAddressByPetId() public &#123; // 期望领养者的地址就是本合约地址，因为交易是由测试合约发起交易， address expected = this; address adopter = adoption.adopters(8); Assert.equal(adopter, expected, \"Owner of pet ID 8 should be recorded.\"); &#125; // 测试所有领养者 function testGetAdopterAddressByPetIdInArray() public &#123; // 领养者的地址就是本合约地址 address expected = this; address[16] memory adopters = adoption.getAdopters(); Assert.equal(adopters[8], expected, \"Owner of pet ID 8 should be recorded.\"); &#125;&#125; Assert.sol 及 DeployedAddresses.sol是Truffle框架提供，在test目录下并不提供truffle目录。 TestAdoption合约中添加adopt的测试用例 运行测试用例在终端中，执行1truffle test 如果测试通过，则终端输出：123456789101112131415Using network &apos;develop&apos;.Compiling ./contracts/Adoption.sol...Compiling ./test/TestAdoption.sol...Compiling truffle/Assert.sol...Compiling truffle/DeployedAddresses.sol... TestAdoption ✓ testUserCanAdoptPet (62ms) ✓ testGetAdopterAddressByPetId (53ms) ✓ testGetAdopterAddressByPetIdInArray (73ms) 3 passing (554ms) 创建用户接口和智能合约交互我们已经编写和部署及测试好了我们的合约，接下我们为合约编写UI，让合约真正可以用起来。 在Truffle Box pet-shop里，已经包含了应用的前端代码，代码在src/文件夹下。 在编辑器中打开src/js/app.js可以看到用来管理整个应用的App对象，init函数加载宠物信息，就初始化web3.web3是一个实现了与以太坊节点通信的库，我们利用web3来和合约进行交互。 初始化web3接下来，我们来编辑app.js修改initWeb3():删除注释，修改为：123456789101112initWeb3: function() &#123; // Is there an injected web3 instance? if (typeof web3 !== 'undefined') &#123; App.web3Provider = web3.currentProvider; &#125; else &#123; // If no injected web3 instance is detected, fall back to Ganache App.web3Provider = new Web3.providers.HttpProvider('http://localhost:7545'); &#125; web3 = new Web3(App.web3Provider); return App.initContract();&#125; 代码中优先使用Mist 或 MetaMask提供的web3实例，如果没有则从本地环境创建一个。 实例化合约使用truffle-contract会帮我们保存合约部署的信息，就不需要我们手动修改合约地址，修改initContract()代码如下：123456789101112131415initContract: function() &#123; // 加载Adoption.json，保存了Adoption的ABI（接口说明）信息及部署后的网络(地址)信息，它在编译合约的时候生成ABI，在部署的时候追加网络信息 $.getJSON('Adoption.json', function(data) &#123; // 用Adoption.json数据创建一个可交互的TruffleContract合约实例。 var AdoptionArtifact = data; App.contracts.Adoption = TruffleContract(AdoptionArtifact); // Set the provider for our contract App.contracts.Adoption.setProvider(App.web3Provider); // Use our contract to retrieve and mark the adopted pets return App.markAdopted(); &#125;); return App.bindEvents();&#125; 处理领养修改markAdopted()代码：123456789101112131415161718markAdopted: function(adopters, account) &#123; var adoptionInstance; App.contracts.Adoption.deployed().then(function(instance) &#123; adoptionInstance = instance; // 调用合约的getAdopters(), 用call读取信息不用消耗gas return adoptionInstance.getAdopters.call(); &#125;).then(function(adopters) &#123; for (i = 0; i &lt; adopters.length; i++) &#123; if (adopters[i] !== '0x0000000000000000000000000000000000000000') &#123; $('.panel-pet').eq(i).find('button').text('Success').attr('disabled', true); &#125; &#125; &#125;).catch(function(err) &#123; console.log(err.message); &#125;);&#125; 修改handleAdopt()代码：123456789101112131415161718192021222324252627handleAdopt: function(event) &#123; event.preventDefault(); var petId = parseInt($(event.target).data('id')); var adoptionInstance; // 获取用户账号 web3.eth.getAccounts(function(error, accounts) &#123; if (error) &#123; console.log(error); &#125; var account = accounts[0]; App.contracts.Adoption.deployed().then(function(instance) &#123; adoptionInstance = instance; // 发送交易领养宠物 return adoptionInstance.adopt(petId, &#123;from: account&#125;); &#125;).then(function(result) &#123; return App.markAdopted(); &#125;).catch(function(err) &#123; console.log(err.message); &#125;); &#125;);&#125; 在浏览器中运行安装 MetaMaskMetaMask 是一款插件形式的以太坊轻客户端，开发过程中使用MetaMask和我们的dapp进行交互是个很好的选择，通过此链接安装，安装完成后，浏览器工具条会显示一个小狐狸图标。 配置钱包在接受隐私说明后，会出现页面如下： 这里我们通过还原一个Ganache为我们创建好的钱包，作为我们的开发测试钱包。点击页面的 Import Existing DEN，输入Ganache显示的助记词。1candy maple cake sugar pudding cream honey rich smooth crumble sweet treat 然后自己想要的密码，点击OK。如图： 连接开发区块链网络默认连接的是以太坊主网（左上角显示），选择Custom RPC，添加一个网络：http://127.0.0.1:7545，点返回后，显示如下：这是左上角显示为Private Network，账号是Ganache中默认的第一个账号。 至此MetaMask的安装，配置已经完成。 安装和配置lite-server接下来需要本地的web 服务器提供服务的访问， Truffle Box pet-shop里提供了一个lite-server可以直接使用，我们看看它是如何工作的。bs-config.json指示了lite-server的工作目录。12345&#123; \"server\": &#123; \"baseDir\": [\"./src\", \"./build/contracts\"] &#125;&#125; ./src 是网站文件目录./build/contracts 是合约输出目录 以此同时，在package.json文件的scripts中添加了dev命令：1234\"scripts\": &#123; \"dev\": \"lite-server\", \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\"&#125;, 当运行npm run dev的时候，就会启动lite-server 启动服务1&gt; npm run dev 会自动打开浏览器显示我们的dapp，如本文的第一张图。现在领养一直宠物看看，当我们点击Adopt时，MetaMask会提示我们交易的确认，如图： 点击Submit确认后，就可以看到成功领养了这次宠物。 在MetaMask中，也可以看到交易的清单： 好了，恭喜你，即将成为一名去中心化式应用开发者的你已经成为迈出了坚实的一步。如果学习中遇到问题，欢迎来我的知识星球交流。 参考文档 Truffle手册 深入浅出区块链 - 系统学习区块链，打造最好的区块链技术博客。","categories":[{"name":"以太坊","slug":"ethereum","permalink":"https://learnblockchain.cn/categories/ethereum/"},{"name":"Dapp","slug":"ethereum/Dapp","permalink":"https://learnblockchain.cn/categories/ethereum/Dapp/"}],"tags":[{"name":"Dapp入门","slug":"Dapp入门","permalink":"https://learnblockchain.cn/tags/Dapp入门/"},{"name":"以太坊概念","slug":"以太坊概念","permalink":"https://learnblockchain.cn/tags/以太坊概念/"}]},{"title":"区块链技术学习指引","slug":"guide","date":"2018-01-11T07:03:36.000Z","updated":"2018-07-19T09:59:54.657Z","comments":true,"path":"2018/01/11/guide/","link":"","permalink":"https://learnblockchain.cn/2018/01/11/guide/","excerpt":"本文为博客文章索引，小白必看。有新文章时会更新本文，建议大家加入收藏夹中，如果你觉得本站不错，欢迎你转发给朋友。","text":"本文为博客文章索引，小白必看。有新文章时会更新本文，建议大家加入收藏夹中，如果你觉得本站不错，欢迎你转发给朋友。 引言给迷失在如何学习区块链技术的同学一个指引，区块链技术是随比特币诞生，因此要搞明白区块链技术，应该先了解下比特币。但区块链技术不单应用于比特币，还有非常多的现实应用场景，想做区块链应用开发，可进一步阅读以太坊系列。 比特币如果你是还不知比特币是什么，那就看看比特币是什么 基础入门接下来可以通过下面这几篇文章了解比特币大概的运行原理： 区块链记账原理 通过这篇可以了解到区块链是一个怎样的结构 比特币所有权及隐私问题 通过这篇可以了解到地址私钥 非对称加密应用 等概念 比特币如何挖矿 通过这篇了解工作量证明 比特币如何达成共识 - 最长链的选择 通过这篇可以了解共识机制。补充阅读 什么是拜占庭将军问题 进阶在基础入门之后，可以进一步阅读以下几篇，理解分布式网络，交易验证。 分析比特币网络：一种去中心化、点对点的网络架构 比特币区块结构 Merkle 树及简单支付验证分析 比特币脚本及交易分析 - 智能合约雏形 看完上面这些，区块链应该理解差不多了，就可以尝试实现一个简单的区块链了。参考这篇用Python从零开始创建区块链。 以太坊一个技术要落地还得靠应用， 以太坊就这样一个建立在区块链技术之上，去中心化的应用平台。可以阅读几下几篇，这部分以开发为主，需要大家多发时间实践。 以太坊开发入门 智能合约开发环境搭建及Hello World合约 搭建智能合约开发环境Remix IDE及使用 以太坊客户端Geth命令用法-参数详解 Geth控制台使用实战及Web3.js使用 如何搭建以太坊私有链 智能合约及应用开发 一步步教你开发、部署第一个Dapp应用 一步步教你创建自己的数字货币（代币）进行ICO 实现一个可管理、增发、兑换、冻结等高级功能的代币 如何通过以太坊智能合约来进行众筹（ICO） 剖析非同质化代币ERC721–全面解析ERC721标准 Web3与智能合约交互实战 如何编写一个可升级的智能合约 美链BEC合约漏洞技术分析 Solidity语言教程Solidity语言是开发智能合约最广泛的语言，本专栏应该是国内最深度介绍Solidity的文章了。 Solidity 教程系列1 - 类型介绍 Solidity 教程系列2 - 地址类型介绍 Solidity 教程系列3 - 函数类型介绍 Solidity 教程系列4 - 数据存储位置分析 Solidity 教程系列5 - 数组介绍 Solidity 教程系列6 - 结构体与映射 Solidity 教程系列7 - 以太单位及时间单位 Solidity 教程系列8 - Solidity API Solidity 教程系列9 - 错误处理 Solidity 教程系列10 - 完全理解函数修改器 智能合约最佳实践 之 Solidity 编码规范 柚子EOS 什么是EOS 说明知识星球《深入浅出区块链》及微信技术交流群, 主要用来提供一个学习的问答及交流平台，问答交流内容不限于博客文章。目前微信群已经聚集了300多位区块链技术牛人和爱好者，形成为非常好的积极氛围。目前定价149，有需要加入的同学请加微信：xlbxiong 温馨提示：微信不提供免费技术解答服务，感谢理解。 深入浅出区块链 - 系统学习区块链，打造最好的区块链技术博客。 以下为广告我和朋友一起创建了登链科技，是一家从事区块链技术服务与咨询的公司。旨在帮助企业更好的拥抱区块链。我们提供的服务包括（不限于）： 代币（Token）开发等完整的数字货币解决方案； 为游戏公司提供基于区块链的道具、角色等； 为公司提供基于区块链的股权激励方案； 为数字产品版权登记、交易平台； 各种公开透明场景下的服务，如：网络彩票发行、投票、众筹等等； 区块链技术培训（企业内训）与技术咨询服务。 所有的服务均可以提供完整的解决方案：如提供面向用户的官方网站、苹果及安卓APP、微信公众号、小程序和企业内部使用的管理后台。业务咨询，请联系：xlb@upchain.pro 另外，我们正在寻找那些热爱技术、愿意迎接挑战的小伙伴（含实习生和正式员工）。我们会提供市场化的薪资待遇和远高于普通公司的成长机会（入职员工由我亲自带领，并且经常有技术培训）。 如果你对我们感兴趣，欢迎提交简历（千万别忘改贴上你的github地址\b哦）至xlb@upchain.pro。目前所有职位均位于百岛之城珠海。","categories":[{"name":"目录","slug":"目录","permalink":"https://learnblockchain.cn/categories/目录/"}],"tags":[{"name":"如何学习","slug":"如何学习","permalink":"https://learnblockchain.cn/tags/如何学习/"},{"name":"目录","slug":"目录","permalink":"https://learnblockchain.cn/tags/目录/"}]},{"title":"智能合约语言 Solidity 教程系列6 - 结构体与映射","slug":"solidity-structs","date":"2017-12-27T03:55:26.000Z","updated":"2018-03-18T13:55:32.194Z","comments":true,"path":"2017/12/27/solidity-structs/","link":"","permalink":"https://learnblockchain.cn/2017/12/27/solidity-structs/","excerpt":"Solidity 教程系列第6篇 - Solidity 结构体与映射。Solidity 系列完整的文章列表请查看分类-Solidity。","text":"Solidity 教程系列第6篇 - Solidity 结构体与映射。Solidity 系列完整的文章列表请查看分类-Solidity。 写在前面Solidity 是以太坊智能合约编程语言，阅读本文前，你应该对以太坊、智能合约有所了解，如果你还不了解，建议你先看以太坊是什么 本系列文章一部分是参考Solidity官方文档（当前最新版本：0.4.20）进行翻译，另一部分是Solidity深入分析，这部分请订阅区块链技术专栏阅读。 结构体(Structs)Solidity提供struct来定义自定义类型，自定义的类型是引用类型。我们看看下面的例子：1234567891011121314151617181920212223242526272829303132333435363738394041424344pragma solidity ^0.4.11;contract CrowdFunding &#123; // 定义一个包含两个成员的新类型 struct Funder &#123; address addr; uint amount; &#125; struct Campaign &#123; address beneficiary; uint fundingGoal; uint numFunders; uint amount; mapping (uint =&gt; Funder) funders; &#125; uint numCampaigns; mapping (uint =&gt; Campaign) campaigns; function newCampaign(address beneficiary, uint goal) public returns (uint campaignID) &#123; campaignID = numCampaigns++; // campaignID 作为一个变量返回 // 创建一个结构体实例，存储在storage ，放入mapping里 campaigns[campaignID] = Campaign(beneficiary, goal, 0, 0); &#125; function contribute(uint campaignID) public payable &#123; Campaign storage c = campaigns[campaignID]; // 用mapping对应项创建一个结构体引用 // 也可以用 Funder(msg.sender, msg.value) 来初始化. c.funders[c.numFunders++] = Funder(&#123;addr: msg.sender, amount: msg.value&#125;); c.amount += msg.value; &#125; function checkGoalReached(uint campaignID) public returns (bool reached) &#123; Campaign storage c = campaigns[campaignID]; if (c.amount &lt; c.fundingGoal) return false; uint amount = c.amount; c.amount = 0; c.beneficiary.transfer(amount); return true; &#125;&#125; 上面是一个简化版的众筹合约，但它可以让我们理解structs的基础概念，struct可以用于映射和数组中作为元素。其本身也可以包含映射和数组等类型。 不能声明一个struct同时将自身struct作为成员，这个限制是基于结构体的大小必须是有限的。但struct可以作为mapping的值类型成员。 注意在函数中，将一个struct赋值给一个局部变量（默认是storage类型），实际是拷贝的引用，所以修改局部变量值的同时，会影响到原变量。 当然，也可以直接通过访问成员修改值，而不用一定赋值给一个局部变量，如campaigns[campaignID].amount = 0 映射(Mappings)映射类型，一种键值对的映射关系存储结构。定义方式为mapping(_KeyType =&gt; _KeyValue)。键类型允许除映射、变长数组、合约、枚举、结构体外的几乎所有类型（）。值类型没有任何限制，可以为任何类型包括映射类型。 映射可以被视作为一个哈希表，所有可能的键会被虚拟化的创建，映射到一个类型的默认值（二进制的全零表示）。在映射表中，并不存储键的数据，仅仅存储它的keccak256哈希值，这个哈希值在查找值时需要用到。正因为此，映射是没有长度的，也没有键集合或值集合的概念。 映射类型，仅能用来作为状态变量，或在内部函数中作为storage类型的引用。 可以通过将映射标记为public，来让Solidity创建一个访问器。通过提供一个键值做为参数来访问它，将返回对应的值。映射的值类型也可以是映射，使用访问器访问时，要提供这个映射值所对应的键，不断重复这个过程。来看一个例子： 1234567891011121314151617pragma solidity ^0.4.0;contract MappingExample &#123; mapping(address =&gt; uint) public balances; function update(uint newBalance) public &#123; balances[msg.sender] = newBalance; &#125;&#125;contract MappingUser &#123; function f() public returns (uint) &#123; MappingExample m = new MappingExample(); m.update(100); return m.balances(this); &#125;&#125; 注意：映射并未提供迭代输出的方法，可以自行实现一个这样的数据结构。参考iterable mapping 参考文档Solidity官方文档 深入浅出区块链 - 系统学习区块链，打造最好的区块链技术博客。我的知识星球为各位解答区块链技术问题，欢迎加入讨论。","categories":[{"name":"以太坊","slug":"ethereum","permalink":"https://learnblockchain.cn/categories/ethereum/"},{"name":"Solidity","slug":"ethereum/Solidity","permalink":"https://learnblockchain.cn/categories/ethereum/Solidity/"}],"tags":[{"name":"Solidity手册","slug":"Solidity手册","permalink":"https://learnblockchain.cn/tags/Solidity手册/"}]},{"title":"智能合约语言 Solidity 教程系列5 - 数组介绍","slug":"solidity-arrays","date":"2017-12-21T03:55:18.000Z","updated":"2018-03-18T13:55:32.193Z","comments":true,"path":"2017/12/21/solidity-arrays/","link":"","permalink":"https://learnblockchain.cn/2017/12/21/solidity-arrays/","excerpt":"Solidity 教程系列第5篇 - Solidity 数组介绍。Solidity 系列完整的文章列表请查看分类-Solidity。","text":"Solidity 教程系列第5篇 - Solidity 数组介绍。Solidity 系列完整的文章列表请查看分类-Solidity。 写在前面Solidity 是以太坊智能合约编程语言，阅读本文前，你应该对以太坊、智能合约有所了解，如果你还不了解，建议你先看以太坊是什么 本文前半部分是参考Solidity官方文档（当前最新版本：0.4.20）进行翻译，后半部分对官方文档中没有提供代码的知识点补充代码说明（订阅专栏阅读）。 数组（Arrays）数组可以声明时指定长度，也可以是动态变长。对storage存储的数组来说，元素类型可以是任意的，类型可以是数组，映射类型，结构体等。但对于memory的数组来说。如果作为public函数的参数，它不能是映射类型的数组，只能是支持ABI的类型。 一个元素类型为T，固定长度为k的数组，可以声明为T[k]，而一个动态大小（变长）的数组则声明为T[]。还可以声明一个多维数组，如声明一个类型为uint的数组长度为5的变长数组（5个元素都是变长数组），可以声明为uint[][5]。（注意，相比非区块链语言，多维数组的长度声明是反的。） 要访问第三个动态数组的第二个元素，使用x[2][1]。数组的序号是从0开始的，序号顺序与定义相反。 bytes和string是一种特殊的数组。bytes类似byte[]，但在外部函数作为参数调用中，bytes会进行压缩打包。string类似bytes，但不提供长度和按序号的访问方式（目前）。所以应该尽量使用bytes而不是byte[]。 可以将字符串s通过bytes(s)转为一个bytes，可以通过bytes(s).length获取长度，bytes(s)[n]获取对应的UTF-8编码。通过下标访问获取到的不是对应字符，而是UTF-8编码，比如中文编码是多字节，变长的，所以下标访问到的只是其中的一个编码。类型为数组的状态变量，可以标记为public，从而让Solidity创建一个访问器，如果要访问数组的某个元素，指定数字下标就好了。（稍后代码事例） 创建内存数组可使用new关键字创建一个memory的数组。与stroage数组不同的是，你不能通过.length的长度来修改数组大小属性。我们来看看下面的例子：123456789101112pragma solidity ^0.4.16;contract C &#123; function f(uint len) public pure &#123; uint[] memory a = new uint[](7); //a.length = 100; // 错误 bytes memory b = new bytes(len); // Here we have a.length == 7 and b.length == len a[6] = 8; &#125;&#125; 数组常量及内联数组数组常量，是一个数组表达式（还没有赋值到变量）。下面是一个简单的例子：12345678910pragma solidity ^0.4.16;contract C &#123; function f() public pure &#123; g([uint(1), 2, 3]); &#125; function g(uint[3] _data) public pure &#123; // ... &#125;&#125; 通过数组常量，创建的数组是memory的，同时还是定长的。元素类型则是使用刚好能存储的元素的能用类型，比如[1, 2, 3]，只需要uint8即可存储，它的类型是uint8[3] memory。 由于g()方法的参数需要的是uint（默认的uint表示的其实是uint256），所以需要对第一个元素进行类型转换，使用uint(1)来进行这个转换。 还需注意的一点是，定长数组，不能与变长数组相互赋值，我们来看下面的代码：12345678910// 无法编译pragma solidity ^0.4.0;contract C &#123; function f() public &#123; // The next line creates a type error because uint[3] memory // cannot be converted to uint[] memory. uint[] x = [uint(1), 3, 4]; &#125;&#125; 已经计划在未来移除这样的限制。当前因为ABI传递数组还有些问题。 成员length属性数组有一个.length属性，表示当前的数组长度。storage的变长数组，可以通过给.length赋值调整数组长度。memory的变长数组不支持。不能通过访问超出当前数组的长度的方式，来自动实现改变数组长度。memory数组虽然可以通过参数，灵活指定大小，但一旦创建，大小不可调整。 push方法storage的变长数组和bytes都有一个push方法（string没有），用于附加新元素到数据末端，返回值为新的长度。 限制情况当前在external函数中，不能使用多维数组。 另外，基于EVM的限制，不能通过外部函数返回动态的内容。123contract C &#123; function f() returns (uint[]) &#123; ... &#125; &#125; 在这个的例子中，如果通过web.js调用能返回数据，但从Solidity中调用不能返回数据。一种绕过这个问题的办法是使用一个非常大的静态数组。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556pragma solidity ^0.4.16;contract ArrayContract &#123; uint[2**20] m_aLotOfIntegers; // 这里不是两个动态数组的数组，而是一个动态数组里，每个元素是长度为二的数组。 bool[2][] m_pairsOfFlags; // newPairs 存在 memory里，因为是函数参数 function setAllFlagPairs(bool[2][] newPairs) public &#123; m_pairsOfFlags = newPairs; &#125; function setFlagPair(uint index, bool flagA, bool flagB) public &#123; // 访问不存在的index会抛出异常 m_pairsOfFlags[index][0] = flagA; m_pairsOfFlags[index][1] = flagB; &#125; function changeFlagArraySize(uint newSize) public &#123; // 如果新size更小, 移除的元素会被销毁 m_pairsOfFlags.length = newSize; &#125; function clear() public &#123; // 销毁 delete m_pairsOfFlags; delete m_aLotOfIntegers; // 同销毁一样的效果 m_pairsOfFlags.length = 0; &#125; bytes m_byteData; function byteArrays(bytes data) public &#123; // byte arrays (\"bytes\") are different as they are stored without padding, // but can be treated identical to \"uint8[]\" m_byteData = data; m_byteData.length += 7; m_byteData[3] = byte(8); delete m_byteData[2]; &#125; function addFlag(bool[2] flag) public returns (uint) &#123; return m_pairsOfFlags.push(flag); &#125; function createMemoryArray(uint size) public pure returns (bytes) &#123; // Dynamic memory arrays are created using `new`: uint[2][] memory arrayOfPairs = new uint[2][](size); // Create a dynamic byte array: bytes memory b = new bytes(200); for (uint i = 0; i &lt; b.length; i++) b[i] = byte(i); return b; &#125;&#125; 补充事例说明事例代码及讲解，请订阅区块链技术查看。 参考文档Solidity官方文档-数组 深入浅出区块链 - 系统学习区块链，打造最好的区块链技术博客。我的知识星球为各位解答区块链技术问题，欢迎加入讨论。","categories":[{"name":"以太坊","slug":"ethereum","permalink":"https://learnblockchain.cn/categories/ethereum/"},{"name":"Solidity","slug":"ethereum/Solidity","permalink":"https://learnblockchain.cn/categories/ethereum/Solidity/"}],"tags":[{"name":"Solidity手册","slug":"Solidity手册","permalink":"https://learnblockchain.cn/tags/Solidity手册/"}]},{"title":"智能合约语言 Solidity 教程系列4 - 数据存储位置分析","slug":"solidity_reftype_datalocation","date":"2017-12-21T03:51:02.000Z","updated":"2018-03-18T13:55:32.197Z","comments":true,"path":"2017/12/21/solidity_reftype_datalocation/","link":"","permalink":"https://learnblockchain.cn/2017/12/21/solidity_reftype_datalocation/","excerpt":"Solidity教程系列第4篇 - Solidity数据位置分析。Solidity 系列完整的文章列表请查看分类-Solidity。","text":"Solidity教程系列第4篇 - Solidity数据位置分析。Solidity 系列完整的文章列表请查看分类-Solidity。 写在前面Solidity 是以太坊智能合约编程语言，阅读本文前，你应该对以太坊、智能合约有所了解，如果你还不了解，建议你先看以太坊是什么 这部分的内容官方英文文档讲的不是很透，因此我在参考Solidity官方文档（当前最新版本：0.4.20）的同时加入了深入分析部分，欢迎订阅专栏。 数据位置(Data location)在系列第一篇，我们提到 Solidity 类型分为两类：值类型(Value Type) 及 引用类型(Reference Types)，前面我们已经介绍完了值类型，接下来会介绍引用类型。 引用类型是一个复杂类型，占用的空间通常超过256位， 拷贝时开销很大，因此我们需要考虑将它们存储在什么位置，是memory（内存中，数据不是永久存在）还是storage（永久存储在区块链中）所有的复杂类型如数组(arrays)和结构体(struct)有一个额外的属性：数据的存储位置（data location）。可为memory和storage。 根据上下文的不同，大多数时候数据位置有默认值，也通过指定关键字storage和memory修改它。 函数参数（包含返回的参数）默认是memory。局部复杂类型变量（local variables）和 状态变量（state variables） 默认是storage。 局部变量：局部作用域（越过作用域即不可被访问，等待被回收）的变量，如函数内的变量。状态变量：合约内声明的公有变量 还有一个存储位置是：calldata，用来存储函数参数，是只读的，不会永久存储的一个数据位置。外部函数的参数（不包括返回参数）被强制指定为calldata。效果与memory差不多。 数据位置指定非常重要，因为他们影响着赋值行为。在memory和storage之间或与状态变量之间相互赋值，总是会创建一个完全独立的拷贝。而将一个storage的状态变量，赋值给一个storage的局部变量，是通过引用传递。所以对于局部变量的修改，同时修改关联的状态变量。另一方面，将一个memory的引用类型赋值给另一个memory的引用，不会创建拷贝（即：memory之间是引用传递）。 注意：不能将memory赋值给局部变量。 对于值类型，总是会进行拷贝。 下面看一段代码：1234567891011121314151617181920212223242526pragma solidity ^0.4.0;contract C &#123; uint[] x; // x的存储位置是storage // memoryArray的存储位置是 memory function f(uint[] memoryArray) public &#123; x = memoryArray; // 从 memory 复制到 storage var y = x; // storage 引用传递局部变量y（y 是一个 storage 引用） y[7]; // 返回第8个元素 y.length = 2; // x同样会被修改 delete x; // y同样会被修改 // 错误， 不能将memory赋值给局部变量 // y = memoryArray; // 错误，不能通过引用销毁storage // delete y; g(x); // 引用传递， g可以改变x的内容 h(x); // 拷贝到memory， h无法改变x的内容 &#125; function g(uint[] storage storageArray) internal &#123;&#125; function h(uint[] memoryArray) public &#123;&#125;&#125; 总结强制的数据位置(Forced data location) 外部函数(External function)的参数(不包括返回参数)强制为：calldata 状态变量(State variables)强制为: storage 默认数据位置（Default data location） 函数参数及返回参数：memory 复杂类型的局部变量：storage 深入分析storage 存储结构是在合约创建的时候就确定好了的，它取决于合约所声明状态变量。但是内容可以被（交易）调用改变。 Solidity 称这个为状态改变，这也是合约级变量称为状态变量的原因。也可以更好的理解为什么状态变量都是storage存储。 memory 只能用于函数内部，memory 声明用来告知EVM在运行时创建一块（固定大小）内存区域给变量使用。 storage 在区块链中是用key/value的形式存储，而memory则表现为字节数组 关于栈（stack）EVM是一个基于栈的语言，栈实际是在内存(memory)的一个数据结构，每个栈元素占为256位，栈最大长度为1024。值类型的局部变量是存储在栈上。 不同存储的消耗（gas消耗） storage 会永久保存合约状态变量，开销最大 memory 仅保存临时变量，函数调用之后释放，开销很小 stack 保存很小的局部变量，几乎免费使用，但有数量限制。 参考资料Solidity官方文档-类型 深入浅出区块链 - 系统学习区块链，打造最好的区块链技术博客。我的知识星球为各位解答区块链技术问题，欢迎加入讨论。","categories":[{"name":"以太坊","slug":"ethereum","permalink":"https://learnblockchain.cn/categories/ethereum/"},{"name":"Solidity","slug":"ethereum/Solidity","permalink":"https://learnblockchain.cn/categories/ethereum/Solidity/"}],"tags":[{"name":"Solidity手册","slug":"Solidity手册","permalink":"https://learnblockchain.cn/tags/Solidity手册/"}]},{"title":"智能合约语言 Solidity 教程系列2 - 地址类型介绍","slug":"solidity2","date":"2017-12-12T07:25:59.000Z","updated":"2018-03-18T13:55:32.196Z","comments":true,"path":"2017/12/12/solidity2/","link":"","permalink":"https://learnblockchain.cn/2017/12/12/solidity2/","excerpt":"Solidity教程系列第二篇 - Solidity地址类型介绍.Solidity 系列完整的文章列表请查看分类-Solidity。","text":"Solidity教程系列第二篇 - Solidity地址类型介绍.Solidity 系列完整的文章列表请查看分类-Solidity。 写在前面Solidity是以太坊智能合约编程语言，阅读本文前，你应该对以太坊、智能合约有所了解，如果你还不了解，建议你先看以太坊是什么 本文前半部分是参考Solidity官方文档（当前最新版本：0.4.20）进行翻译，后半部分是结合实际合约代码实例说明类型的使用（仅针对专栏订阅用户）。 地址类型（Address）地址类型address是一个值类型， 地址： 20字节（一个以太坊地址的长度），地址类型也有成员，地址是所有合约的基础支持的运算符： &lt;=, &lt;, ==, !=, &gt;= 和 &gt; 注意：从0.5.0开始，合约不再继承自地址类型，但仍然可以显式转换为地址。 地址类型的成员 balance 属性及transfer() 函数这里是地址类型相关成员的快速索引 balance用来查询账户余额，transfer()用来发送以太币（以wei为单位）。 如： 123address x = 0x123;address myAddress = this;if (x.balance &lt; 10 &amp;&amp; myAddress.balance &gt;= 10) x.transfer(10); 注解：如果x是合约地址，合约的回退函数（fallback 函数）会随transfer调用一起执行（这个是EVM特性），如果因gas耗光或其他原因失败，转移交易会还原并且合约会抛异常停止。 关于回退函数（fallback 函数），简单来说它是合约中无函数名函数，下面代码事例中，进进一步讲解回退函数（fallback） 的使用。 send() 函数 send 与transfer对应，但更底层。如果执行失败，transfer不会因异常停止，而send会返回false。 警告：send() 执行有一些风险：如果调用栈的深度超过1024或gas耗光，交易都会失败。因此，为了保证安全，必须检查send的返回值，如果交易失败，会回退以太币。如果用transfer会更好。 call(), callcode() 和 delegatecall() 函数 为了和非ABI协议的合约进行交互，可以使用call() 函数, 它用来向另一个合约发送原始数据，支持任何类型任意数量的参数，每个参数会按规则(ABI协议)打包成32字节并一一拼接到一起。一个例外是：如果第一个参数恰好4个字节，在这种情况下，会被认为根据ABI协议定义的函数器指定的函数签名而直接使用。如果仅想发送消息体，需要避免第一个参数是4个字节。如下面的例子： 123address nameReg = 0x72ba7d8e73fe8eb666ea66babc8116a41bfb10e2;nameReg.call(&quot;register&quot;, &quot;MyName&quot;);nameReg.call(bytes4(keccak256(&quot;fun(uint256)&quot;)), a); call函数返回一个bool值，以表明执行成功与否。正常结束返回true，异常终止返回false。但无法获取到结果数据，因为需要提前知道返回的数据的编码和数据大小（因不知道对方使用的协议格式，所以也不会知道返回的结果如何解析）。 还可以提供.gas()修饰器进行调用： 1namReg.call.gas(1000000)(&quot;register&quot;, &quot;MyName&quot;); 类似还可以提供附带以太币： 1nameReg.call.value(1 ether)(&quot;register&quot;, &quot;MyName&quot;); 修饰器可以混合使用，修饰器调用顺序无所谓。 1nameReg.call.gas(1000000).value(1 ether)(&quot;register&quot;, &quot;MyName&quot;); 注解：目前还不能在重载函数上使用gas或value修饰符，A workaround is to introduce a special case for gas and value and just re-check whether they are present at the point of overload resolution.（这句我怕翻译的不准确，引用原文） 同样我们也可以使用delegatecall()，它与call方法的区别在于，仅仅是代码会执行，而其它方面，如（存储，余额等）都是用的当前的合约的数据。delegatecall()方法的目的是用来执行另一个合约中的库代码。所以开发者需要保证两个合约中的存储变量能兼容，来保证delegatecall()能顺利执行。在homestead阶段之前，仅有一个受限的callcode()方法可用，但callcode未提供对msg.sender，msg.value的访问权限。 上面的这三个方法call()，delegatecall()，callcode()都是底层的消息传递调用，最好仅在万不得已才进行使用，因为他们破坏了Solidity的类型安全。 .gas() 在call(), callcode() 和 delegatecall() 函数下都可以使用， delegatecall()不支持.value() 注解：所有合约都继承了address的成员，因此可以使用this.balance查询余额。callcode不鼓励使用，以后会移除。 警告：上述的函数都是底层的函数，使用时要异常小心。当调用一个未知的，可能是恶意的合约时，当你把控制权交给它，它可能回调回你的合约，所以要准备好在调用返回时，应对你的状态变量可能被恶意篡改的情况。 地址常量（Address Literals）一个能通过地址合法性检查（address checksum test）十六进制常量就会被认为是地址，如0xdCad3a6d3569DF655070DEd06cb7A1b2Ccd1D3AF。而不能通过地址合法性检查的39到41位长的十六进制常量，会提示一个警告，被视为普通的有理数常量。 地址合法性检查定义在EIP-55 合约事例讲解合约事例代码123456789101112131415161718192021222324252627282930313233343536373839404142434445pragma solidity ^0.4.0;contract AddrTest&#123; event logdata(bytes data); function() payable &#123; logdata(msg.data); &#125; function getBalance() returns (uint) &#123; return this.balance; &#125; uint score = 0; function setScore(uint s) public &#123; score = s; &#125; function getScore() returns ( uint)&#123; return score; &#125;&#125;contract CallTest&#123; function deposit() payable &#123; &#125; event logSendEvent(address to, uint value); function transferEther(address towho) payable &#123; towho.transfer(10); logSendEvent(towho, 10); &#125; function callNoFunc(address addr) returns (bool)&#123; return addr.call(\"tinyxiong\", 1234); &#125; function callfunc(address addr) returns (bool)&#123; bytes4 methodId = bytes4(keccak256(\"setScore(uint256)\")); return addr.call(methodId, 100); &#125; function getBalance() returns (uint) &#123; return this.balance; &#125; &#125; 代码运行及讲解代码运行及讲解，请订阅区块链技术查看。 参考文档Solidity官方文档-类型 深入浅出区块链 - 系统学习区块链，打造最好的区块链技术博客。我的知识星球为各位解答区块链技术问题，欢迎加入讨论。","categories":[{"name":"以太坊","slug":"ethereum","permalink":"https://learnblockchain.cn/categories/ethereum/"},{"name":"Solidity","slug":"ethereum/Solidity","permalink":"https://learnblockchain.cn/categories/ethereum/Solidity/"}],"tags":[{"name":"Solidity","slug":"Solidity","permalink":"https://learnblockchain.cn/tags/Solidity/"}]},{"title":"智能合约语言 Solidity 教程系列3 - 函数类型","slug":"solidity_func","date":"2017-12-12T07:25:59.000Z","updated":"2018-03-18T13:55:32.197Z","comments":true,"path":"2017/12/12/solidity_func/","link":"","permalink":"https://learnblockchain.cn/2017/12/12/solidity_func/","excerpt":"Solidity 教程系列第三篇 - Solidity 函数类型介绍。Solidity 系列完整的文章列表请查看分类-Solidity。","text":"Solidity 教程系列第三篇 - Solidity 函数类型介绍。Solidity 系列完整的文章列表请查看分类-Solidity。 写在前面Solidity 是以太坊智能合约编程语言，阅读本文前，你应该对以太坊、智能合约有所了解，如果你还不了解，建议你先看以太坊是什么 本文前半部分是参考Solidity 官方文档（当前最新版本：0.4.20）进行翻译，后半部分函数可见性（ public, external, internal, privite ）深度分析（仅针对专栏订阅用户）。 函数类型（Function Types）函数也是一种类型，且属于值类型。可以将一个函数赋值给一个函数类型的变量。还可以将一个函数作为参数进行传递。也可以在函数调用中返回一个函数。函数类型有两类:内部(internal)和外部(external)函数 内部(internal)函数只能在当前合约内被调用（在当前的代码块内，包括内部库函数，和继承的函数中）。外部(external)函数由地址和函数方法签名两部分组成，可作为外部函数调用的参数，或返回值。 函数类型定义如下：1function (&lt;parameter types&gt;) &#123;internal|external&#125; [pure|constant|view|payable] [returns (&lt;return types&gt;)] 如果函数不需要返回，则省去returns ()函数类型默认是internal， 因此internal可以省去。但以此相反，合约中函数本身默认是public的， 仅仅是当作类型名使用时默认是internal的。 有两个方式访问函数，一种是直接用函数名f, 一种是this.f， 前者用于内部函数，后者用于外部函数。 如果一个函数变量没有初始化，直接调用它将会产生异常。如果delete了一个函数后调用，也会发生同样的异常。 如果外部函数类型在Solidity的上下文环境以外的地方使用，他们会被视为function类型。它会编码为20字节的函数所在地址，和在它之前的4字节的函数方法签名一起作为bytes24类型。合约中的public的函数，可以使用internal和external两种方式来调用。internal访问形式为f, external访问形式为this.f 成员: 属性 selector public (或 external) 函数有一个特殊的成员selector, 它对应一个ABI 函数选择器。 1234567pragma solidity ^0.4.16;contract Selector &#123;function f() public view returns (bytes4) &#123; return this.f.selector;&#125;&#125; 下面的代码显示内部（internal）函数类型的使用： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748pragma solidity ^0.4.16;library ArrayUtils &#123; // internal functions can be used in internal library functions because // they will be part of the same code context function map(uint[] memory self, function (uint) pure returns (uint) f) internal pure returns (uint[] memory r) &#123; r = new uint[](self.length); for (uint i = 0; i &lt; self.length; i++) &#123; r[i] = f(self[i]); &#125; &#125; function reduce( uint[] memory self, function (uint, uint) pure returns (uint) f ) internal pure returns (uint r) &#123; r = self[0]; for (uint i = 1; i &lt; self.length; i++) &#123; r = f(r, self[i]); &#125; &#125; function range(uint length) internal pure returns (uint[] memory r) &#123; r = new uint[](length); for (uint i = 0; i &lt; r.length; i++) &#123; r[i] = i; &#125; &#125;&#125;contract Pyramid &#123; using ArrayUtils for *; function pyramid(uint l) public pure returns (uint) &#123; return ArrayUtils.range(l).map(square).reduce(sum); &#125; function square(uint x) internal pure returns (uint) &#123; return x * x; &#125; function sum(uint x, uint y) internal pure returns (uint) &#123; return x + y; &#125;&#125; 下面的代码显示外部（external）函数类型的使用：1234567891011121314151617181920212223242526272829pragma solidity ^0.4.11;contract Oracle &#123; struct Request &#123; bytes data; function(bytes memory) external callback; &#125; Request[] requests; event NewRequest(uint); function query(bytes data, function(bytes memory) external callback) public &#123; requests.push(Request(data, callback)); NewRequest(requests.length - 1); &#125; function reply(uint requestID, bytes response) public &#123; // Here goes the check that the reply comes from a trusted source requests[requestID].callback(response); &#125;&#125;contract OracleUser &#123; Oracle constant oracle = Oracle(0x1234567); // known contract function buySomething() &#123; oracle.query(\"USD\", this.oracleResponse); &#125; function oracleResponse(bytes response) public &#123; require(msg.sender == address(oracle)); // Use the data &#125;&#125; 函数可见性分析 public - 任意访问 private - 仅当前合约内 internal - 仅当前合约及所继承的合约 external - 仅外部访问（在内部也只能用外部访问方式访问） public 还是 external 最佳实践请订阅区块链技术查看。 参考文档Solidity官方文档-类型 深入浅出区块链 - 系统学习区块链，打造最好的区块链技术博客。我的知识星球为各位解答区块链技术问题，欢迎加入讨论。","categories":[{"name":"以太坊","slug":"ethereum","permalink":"https://learnblockchain.cn/categories/ethereum/"},{"name":"Solidity","slug":"ethereum/Solidity","permalink":"https://learnblockchain.cn/categories/ethereum/Solidity/"}],"tags":[{"name":"Solidity","slug":"Solidity","permalink":"https://learnblockchain.cn/tags/Solidity/"}]},{"title":"比特币如何达成共识 - 最长链的选择","slug":"bitcoin-sonsensus","date":"2017-12-07T08:12:29.000Z","updated":"2018-01-10T08:10:46.597Z","comments":true,"path":"2017/12/07/bitcoin-sonsensus/","link":"","permalink":"https://learnblockchain.cn/2017/12/07/bitcoin-sonsensus/","excerpt":"比特币没有中心机构，几乎所有的完整节点都有一份公共总帐本，那么大家如何达成共识：确认哪一份才是公认权威的总账本呢？","text":"比特币没有中心机构，几乎所有的完整节点都有一份公共总帐本，那么大家如何达成共识：确认哪一份才是公认权威的总账本呢？ 为什么要遵守协议这其实是一个经济问题，在经济活动中的每个人都是自私自利的，追求的是利益的最大化，一个节点工作量只有在其他的节点认同其是有效的（打包的新区块，其他的节点只有验证通过才会加入到区块链中，并在网络上传播），才能够过得收益，而只有遵守规则才会得到其他的节点认同。因此，基于逐利，节点就会自发的遵守协议。共识就是数以万计的独立节点遵守了简单的规则（通过异步交互）自发形成的。 共识：共同遵守的协议规范 去中心化共识在工作量证明一篇，我们了解通过工作量证明来竞争记账，权威的总帐本是怎么达到共识的，没有完全说清楚，今天补上，实际上，比特币的共识由所有节点的4个独立过程相互作用而产生： 每个节点（挖矿节点）依据标准对每个交易进行独立验证 挖矿节点通过完成工作量证明，将交易记录独立打包进新区块 每个节点独立的对新区块进行校验并组装进区块链 每个节点对区块链进行独立选择，在工作量证明机制下选择累计工作量最大的区块链 共识最终目的是保证比特币不停的在工作量最大的区块链上运转，工作量最大的区块链就是权威的公共总帐本。 第1 2 3步在比特币如何挖矿-工作量证明一篇有提到过，下面着重讲第4步。 最长链的选择先来一个定义，把累计了最多难度的区块链。在一般情况下，也是包含最多区块的那个链称为主链每一个（挖矿）节点总是选择并尝试延长主链。 分叉当有两名矿工在几乎在相同的时间内，各自都算得了工作量证明解，便立即传播自己的“获胜”区块到网络中，先是传播给邻近的节点而后传播到整个网络。每个收到有效区块的节点都会将其并入并延长区块链。当这个两个区块传播时，一些节点首先收到#3458A, 一些节点首先收到#3458B，这两个候选区块（通常这两个候选区块会包含几乎相同的交易）都是主链的延伸，分叉就会产生，这时分叉出有竞争关系的两条链，如图：两个块都收到的节点，会把其中有更多工作量的一条会继续作为主链，另一条作为备用链保存（保存是因为备用链将来可能会超过主链难度称为新主链）。 分叉解决收到#3458A的（挖矿）节点，会立刻以这个区块为父区块来产生新的候选区块，并尝试寻找这个候选区块的工作量证明解。同样地，接受#3458B区块的节点会以这个区块为链的顶点开始生成新块，延长这个链（下面称为B链）。这时总会有一方抢先发现工作量证明解并将其传播出去，假设以#3458B为父区块的工作量证明首先解出，如图： 当原本以#3458A为父区块求解的节点在收到#3458B, #3459B之后，会立刻将B链作为主链（因为#3458A为顶点的链已经不是最长链了）继续挖矿。 节点也有可能先收到#3459B，再收到#3458B，收到#3459B时，会被认为是“孤块“（因为还找不到#3459B的父块#3458B）保存在孤块池中，一旦收到父块#3458B时，节点就会将孤块从孤块池中取出，并且连接到它的父区块，让它作为区块链的一部分。 比特币将区块间隔设计为10分钟，是在更快速的交易确认和更低的分叉概率间作出的妥协。更短的区块产生间隔会让交易确认更快地完成，也会导致更加频繁地区块链分叉。与之相对地，长的间隔会减少分叉数量，却会导致更长的确认时间。 深入浅出区块链 - 系统学习区块链，打造最好的区块链技术博客。我的知识星球为各位解答区块链技术问题，欢迎加入讨论。","categories":[{"name":"比特币","slug":"bitcoin","permalink":"https://learnblockchain.cn/categories/bitcoin/"}],"tags":[{"name":"比特币","slug":"比特币","permalink":"https://learnblockchain.cn/tags/比特币/"},{"name":"共识协议","slug":"共识协议","permalink":"https://learnblockchain.cn/tags/共识协议/"}]},{"title":"智能合约语言 Solidity 教程系列1 - 类型介绍","slug":"solidity1","date":"2017-12-05T07:25:59.000Z","updated":"2018-04-12T13:05:37.000Z","comments":true,"path":"2017/12/05/solidity1/","link":"","permalink":"https://learnblockchain.cn/2017/12/05/solidity1/","excerpt":"现在的Solidity中文文档，要么翻译的太烂，要么太旧，决定重新翻译下。尤其点名批评极客学院名为《Solidity官方文档中文版》的翻译，机器翻译的都比它好，大家还是别看了。","text":"现在的Solidity中文文档，要么翻译的太烂，要么太旧，决定重新翻译下。尤其点名批评极客学院名为《Solidity官方文档中文版》的翻译，机器翻译的都比它好，大家还是别看了。 写在前面Solidity是以太坊智能合约编程语言，阅读本文前，你应该对以太坊、智能合约有所了解，如果你还不了解，建议你先看以太坊是什么Solidity教程会是一系列文章，本文是第一篇：介绍Solidity的变量类型。Solidity 系列完整的文章列表请查看分类-Solidity。 本文前半部分是参考Solidity官方文档（当前最新版本：0.4.20）进行翻译，后半部分是结合实际合约代码实例说明类型的使用（仅针对专栏订阅用户）。 类型Solidity是一种静态类型语言，意味着每个变量（本地或状态变量）需要在编译时指定变量的类型（或至少可以推倒出类型）。Solidity提供了一些基本类型可以用来组合成复杂类型。 Solidity类型分为两类： 值类型(Value Type) - 变量在赋值或传参时，总是进行值拷贝。 引用类型(Reference Types) 值类型(Value Type)值类型包含: 布尔类型(Booleans) 整型(Integers) 定长浮点型(Fixed Point Numbers) 定长字节数组(Fixed-size byte arrays) 有理数和整型常量(Rational and Integer Literals) 字符串常量（String literals） 十六进制常量（Hexadecimal literals） 枚举(Enums) 函数类型(Function Types) 地址类型(Address) 地址常量(Address Literals) 函数类型及地址类型(Address)有单独的博文，请点击查看。 布尔类型(Booleans)布尔(bool):可能的取值为常量值true和false。 布尔类型支持的运算符有： ！逻辑非 &amp;&amp; 逻辑与 || 逻辑或 == 等于 != 不等于 注意：运算符&amp;&amp;和||是短路运算符，如f(x)||g(y)，当f(x)为真时，则不会继续执行g(y)。 整型(Integers)int/uint: 表示有符号和无符号不同位数整数。支持关键字uint8 到 uint256 (以8步进)，uint 和 int 默认对应的是 uint256 和 int256。 支持的运算符： 比较运算符： &lt;=, &lt; , ==, !=, &gt;=, &gt; (返回布尔值：true 或 false) 位操作符： &amp;，|，^(异或)，~（位取反） 算术操作符：+，-，一元运算-，一元运算+，，/, %(取余数), **（幂）, &lt;&lt; (左移位), &gt;&gt;(右移位) 说明： 整数除法总是截断的，但如果运算符是字面量（字面量稍后讲)，则不会截断。 整数除0会抛异常。 移位运算的结果的正负取决于操作符左边的数。x &lt;&lt; y 和 x 2**y 是相等， x &gt;&gt; y 和 x / 2**y 是相等的。 不能进行负移位，即操作符右边的数不可以为负数，否则会抛出运行时异常。 注意：Solidity中，右移位是和除等价的，因此右移位一个负数，向下取整时会为0，而不像其他语言里为无限负小数。 定长浮点型（Fixed Point Numbers）注意：定长浮点型 Solidity（发文时）还不完全支持，它可以用来声明变量，但不可以用来赋值。 fixed/ufixed: 表示有符号和无符号的固定位浮点数。关键字为ufixedMxN 和 ufixedMxN。M表示这个类型要占用的位数，以8步进，可为8到256位。N表示小数点的个数，可为0到80之间 支持的运算符： 比较运算符： &lt;=, &lt; , ==, !=, &gt;=, &gt; (返回布尔值：true 或 false) 算术操作符：+，-，一元运算-，一元运算+，，/, %(取余数)注意：它和大多数语言的float和double不一样，*M是表示整个数占用的固定位数，包含整数部分和小数部分。因此用一个小位数（M较小）来表示一个浮点数时，小数部分会几乎占用整个空间。 定长字节数组(Fixed-size byte arrays)关键字有：bytes1, bytes2, bytes3, …, bytes32。（以步长1递增）byte代表bytes1。 支持的运算符： 比较符: &lt;=, &lt;, ==, !=, &gt;=, &gt; (返回bool） 位操作符: &amp;, |, ^ (按位异或)，~（按位取反）, &lt;&lt; (左移位), &gt;&gt; (右移位) 索引（下标）访问: 如果x是bytesI，当0 &lt;= k &lt; I ，则x[k]返回第k个字节（只读）。 移位运算和整数类似，移位运算的结果的正负取决于操作符左边的数，且不能进行负移位。如可以-5&lt;&lt;1, 不可以5&lt;&lt;-1 成员变量：.length：表示这个字节数组的长度（只读）。 变长（动态分配大小）字节数组（Dynamically-sized byte array） bytes:动态分配大小字节数组, 参见Arrays,不是值类型! string:动态分配大小UTF8编码的字符类型,参看Arrays。不是值类型! 根据经验：bytes用来存储任意长度的字节数据，string用来存储任意长度的(UTF-8编码)的字符串数据。如果长度可以确定，尽量使用定长的如byte1到byte32中的一个，因为这样更省空间。 有理数和整型常量(Rational and Integer Literals) 也有人把Literals翻译为字面量 整型常量是有一系列0-9的数字组成，10进制表示，比如：8进制是不存在的，前置0在Solidity中是无效的。 10进制小数常量（Decimal fraction literals）带了一个.， 在.的两边至少有一个数字，有效的表示如:1., .1 和 1.3. 科学符号也支持，基数可以是小数，指数必须是整数， 有效的表示如: 2e10, -2e10, 2e-10, 2.5e1。 数字常量表达式本身支持任意精度，也就是可以不会运算溢出，或除法截断。但当它被转换成对应的非常量类型，或者将他们与非常量进行运算，则不能保证精度了。如：(2*800 + 1) - 2*800的结果为1（uint8整类) ，尽管中间结果已经超过计算机字长。另外：.5 * 8的结果是4，尽管有非整形参与了运算。 只要操作数是整形，整型支持的运算符都适用于整型常量表达式。如果两个操作数是小数，则不允许进行位运算，指数也不能是小数。 注意：Solidity对每一个有理数都有一个数值常量类型。整数常量和有理数常量从属于数字常量。所有的数字常表达式的结果都属于数字常量。所以1 + 2和2 + 1都属于同样的有理数的数字常量3 警告：整数常量除法，在早期的版本中是被截断的，但现在可以被转为有理数了，如5/2的值为 2.5 注意：数字常量表达式，一旦其中含有常量表达式，它就会被转为一个非常量类型。下面代码中表达式的结果将会被认为是一个有理数：12uint128 a = 1;uint128 b = 2.5 + a + 0.5; 上述代码编译不能通过，因为b会被编译器认为是小数型。 字符串常量字符串常量是指由单引号，或双引号引起来的字符串 (“foo” or ‘bar’)。字符串并不像C语言，包含结束符，”foo”这个字符串大小仅为三个字节。和整数常量一样，字符串的长度类型可以是变长的。字符串可以隐式的转换为byte1,…byte32 如果适合，也会转为bytes或string。 字符串常量支持转义字符，比如\\n，\\xNN，\\uNNNN。其中\\xNN表示16进制值，最终转换合适的字节。而\\uNNNN表示Unicode编码值，最终会转换为UTF8的序列。 十六进制常量（Hexadecimal literals）十六进制常量，以关键字hex打头，后面紧跟用单或双引号包裹的字符串，内容是十六进制字符串，如hex”001122ff”。它的值会用二进制来表示。 十六进制常量和字符串常量类似，也可以转换为字节数组。 枚举（Enums）在Solidity中，枚举可以用来自定义类型。它可以显示的转换与整数进行转换，但不能进行隐式转换。显示的转换会在运行时检查数值范围，如果不匹配，将会引起异常。枚举类型应至少有一名成员。下面是一个枚举的例子：123456789101112131415161718192021222324pragma solidity ^0.4.0;contract test &#123; enum ActionChoices &#123; GoLeft, GoRight, GoStraight, SitStill &#125; ActionChoices choice; ActionChoices constant defaultChoice = ActionChoices.GoStraight; function setGoStraight() &#123; choice = ActionChoices.GoStraight; &#125; // Since enum types are not part of the ABI, the signature of &quot;getChoice&quot; // will automatically be changed to &quot;getChoice() returns (uint8)&quot; // for all matters external to Solidity. The integer type used is just // large enough to hold all enum values, i.e. if you have more values, // `uint16` will be used and so on. function getChoice() returns (ActionChoices) &#123; return choice; &#125; function getDefaultChoice() returns (uint) &#123; return uint(defaultChoice); &#125;&#125; 代码实例通过合约代码实例说明类型的使用，请订阅区块链技术查看。 参考文档Solidity官方文档-类型 深入浅出区块链 - 系统学习区块链，打造最好的区块链技术博客。我的知识星球为各位解答区块链技术问题，欢迎加入讨论。","categories":[{"name":"以太坊","slug":"ethereum","permalink":"https://learnblockchain.cn/categories/ethereum/"},{"name":"Solidity","slug":"ethereum/Solidity","permalink":"https://learnblockchain.cn/categories/ethereum/Solidity/"}],"tags":[{"name":"Solidity手册","slug":"Solidity手册","permalink":"https://learnblockchain.cn/tags/Solidity手册/"}]},{"title":"Geth 控制台使用及 Web3.js 使用实战","slug":"geth_cmd_short","date":"2017-12-01T11:41:53.000Z","updated":"2018-01-10T08:11:01.433Z","comments":true,"path":"2017/12/01/geth_cmd_short/","link":"","permalink":"https://learnblockchain.cn/2017/12/01/geth_cmd_short/","excerpt":"在开发以太坊去中心化应用，免不了和以太坊进行交互，那就离不开Web3。Geth 控制台（REPL）实现了所有的web3 API及Admin API，使用好 Geth 就是必修课。结合Geth命令用法阅读效果更佳。","text":"在开发以太坊去中心化应用，免不了和以太坊进行交互，那就离不开Web3。Geth 控制台（REPL）实现了所有的web3 API及Admin API，使用好 Geth 就是必修课。结合Geth命令用法阅读效果更佳。 写在前面阅读本文之前，你需要对以太坊（区块链）有初步的了解，如果你不知道以太坊是什么，请先阅读以太坊是什么。如果你在我的小专栏之外的地方阅读到本文，你可能只能阅读本文的节选，阅读完整全文请订阅小专栏区块链技术 geth控制台初探 - 启动、退出安装参考智能合约开发环境搭建最简单启动方式如下：1$ geth console geth控制台启动成功之后，可以看到&gt;提示符。退出输入exit geth 日志控制重定向日志到文件使用geth console启动是，会在当前的交互界面下时不时出现日志。可以使用以下方式把日志输出到文件。1$ geth console 2&gt;&gt;geth.log 可以新开一个命令行终端输入以下命令查看日志：1$ tail -f geth.log 重定向另一个终端也可以把日志重定向到另一个终端，先在想要看日志的终端输入：1$ tty 就可以获取到终端编号，如：/dev/ttys003然后另一个终端使用：1$ geth console 2&gt;&gt; /dev/ttys003 启动geth, 这是日志就输出到另一个终端。如果不想看到日志还可以重定向到空终端：1$ geth console 2&gt;&gt; /dev/null 日志级别控制使用–verbosity可以控制日志级别，如不想看到日志还可以使用：1$ geth --verbosity 0 console 启动一个开发模式测试节点1geth --datadir /home/xxx/testNet --dev console 技巧：如果我们经常使用一个方式来启动，可以把命令存为一个bash脚本。~/bin你可以放一些常用的脚本，并把~/bin加入到环境变量PATH里。 连接geth节点另外一个启动geth的方法是连接到一个geth节点：123$ geth attach ipc:/some/custom/path$ geth attach http://191.168.1.1:8545$ geth attach ws://191.168.1.1:8546 如连接刚刚打开的开发模式节点使用：1geth attach ipc:testNet/geth.ipc 更多内容请前往区块链技术小专栏查看全文链接。深入浅出区块链 - 系统学习区块链，打造最好的区块链技术博客。我的知识星球为各位解答区块链技术问题，欢迎加入讨论。","categories":[{"name":"以太坊","slug":"ethereum","permalink":"https://learnblockchain.cn/categories/ethereum/"},{"name":"geth","slug":"ethereum/geth","permalink":"https://learnblockchain.cn/categories/ethereum/geth/"}],"tags":[{"name":"Geth使用","slug":"Geth使用","permalink":"https://learnblockchain.cn/tags/Geth使用/"},{"name":"Web3.js","slug":"Web3-js","permalink":"https://learnblockchain.cn/tags/Web3-js/"}]},{"title":"以太坊客户端Geth命令用法-参数详解","slug":"geth_cmd_options","date":"2017-11-29T03:51:52.000Z","updated":"2018-01-10T08:10:52.556Z","comments":true,"path":"2017/11/29/geth_cmd_options/","link":"","permalink":"https://learnblockchain.cn/2017/11/29/geth_cmd_options/","excerpt":"Geth在以太坊智能合约开发中最常用的工具（必备开发工具），一个多用途的命令行工具。熟悉Geth可以让我们有更好的效率，大家可收藏起来作为Geth命令用法手册。 本文主要是对geth help的翻译，基于最新的geth 1.7.3-stable版本。","text":"Geth在以太坊智能合约开发中最常用的工具（必备开发工具），一个多用途的命令行工具。熟悉Geth可以让我们有更好的效率，大家可收藏起来作为Geth命令用法手册。 本文主要是对geth help的翻译，基于最新的geth 1.7.3-stable版本。 如果你还不知道geth是什么，请先阅读入门篇：以太坊是什么。更多geth实战使用方法请参考Geth控制台使用实战及Web3.js使用以下开始正文。 命令用法geth [选项] 命令 [命令选项] [参数…] 版本：1.7.3-stable 命令:account 管理账户 attach 启动交互式JavaScript环境（连接到节点） bug 上报bug Issues console 启动交互式JavaScript环境 copydb 从文件夹创建本地链 dump Dump（分析）一个特定的块存储 dumpconfig 显示配置值 export 导出区块链到文件 import 导入一个区块链文件 init 启动并初始化一个新的创世纪块 js 执行指定的JavaScript文件(多个) license 显示许可信息 makecache 生成ethash验证缓存(用于测试) makedag 生成ethash 挖矿DAG(用于测试) monitor 监控和可视化节点指标 removedb 删除区块链和状态数据库 version 打印版本号 wallet 管理Ethereum预售钱包 help,h 显示一个命令或帮助一个命令列表 ETHEREUM选项:--config value TOML 配置文件 --datadir “xxx” 数据库和keystore密钥的数据目录 --keystore keystore存放目录(默认在datadir内) --nousb 禁用监控和管理USB硬件钱包 --networkid value 网络标识符(整型, 1=Frontier, 2=Morden (弃用), 3=Ropsten, 4=Rinkeby) (默认: 1) --testnet Ropsten网络:预先配置的POW(proof-of-work)测试网络 --rinkeby Rinkeby网络: 预先配置的POA(proof-of-authority)测试网络 --syncmode &quot;fast&quot; 同步模式 (&quot;fast&quot;, &quot;full&quot;, or &quot;light&quot;) --ethstats value 上报ethstats service URL (nodename:secret@host:port) --identity value 自定义节点名 --lightserv value 允许LES请求时间最大百分比(0 – 90)(默认值:0) --lightpeers value 最大LES client peers数量(默认值:20) --lightkdf 在KDF强度消费时降低key-derivation RAM&amp;CPU使用 开发者（模式）选项:--dev 使用POA共识网络，默认预分配一个开发者账户并且会自动开启挖矿。 --dev.period value 开发者模式下挖矿周期 (0 = 仅在交易时) (默认: 0) ETHASH 选项:--ethash.cachedir ethash验证缓存目录(默认 = datadir目录内) --ethash.cachesinmem value 在内存保存的最近的ethash缓存个数 (每个缓存16MB ) (默认: 2) --ethash.cachesondisk value 在磁盘保存的最近的ethash缓存个数 (每个缓存16MB) (默认: 3) --ethash.dagdir &quot;&quot; 存ethash DAGs目录 (默认 = 用户hom目录) --ethash.dagsinmem value 在内存保存的最近的ethash DAGs 个数 (每个1GB以上) (默认: 1) --ethash.dagsondisk value 在磁盘保存的最近的ethash DAGs 个数 (每个1GB以上) (默认: 2) 交易池选项:--txpool.nolocals 为本地提交交易禁用价格豁免 --txpool.journal value 本地交易的磁盘日志：用于节点重启 (默认: &quot;transactions.rlp&quot;) --txpool.rejournal value 重新生成本地交易日志的时间间隔 (默认: 1小时) --txpool.pricelimit value 加入交易池的最小的gas价格限制(默认: 1) --txpool.pricebump value 价格波动百分比（相对之前已有交易） (默认: 10) --txpool.accountslots value 每个帐户保证可执行的最少交易槽数量 (默认: 16) --txpool.globalslots value 所有帐户可执行的最大交易槽数量 (默认: 4096) --txpool.accountqueue value 每个帐户允许的最多非可执行交易槽数量 (默认: 64) --txpool.globalqueue value 所有帐户非可执行交易最大槽数量 (默认: 1024) --txpool.lifetime value 非可执行交易最大入队时间(默认: 3小时) 性能调优的选项:--cache value 分配给内部缓存的内存MB数量，缓存值(最低16 mb /数据库强制要求)(默认:128) --trie-cache-gens value 保持在内存中产生的trie node数量(默认:120) 帐户选项:--unlock value 需解锁账户用逗号分隔 --password value 用于非交互式密码输入的密码文件 API和控制台选项:--rpc 启用HTTP-RPC服务器 --rpcaddr value HTTP-RPC服务器接口地址(默认值:“localhost”) --rpcport value HTTP-RPC服务器监听端口(默认值:8545) --rpcapi value 基于HTTP-RPC接口提供的API --ws 启用WS-RPC服务器 --wsaddr value WS-RPC服务器监听接口地址(默认值:“localhost”) --wsport value WS-RPC服务器监听端口(默认值:8546) --wsapi value 基于WS-RPC的接口提供的API --wsorigins value websockets请求允许的源 --ipcdisable 禁用IPC-RPC服务器 --ipcpath 包含在datadir里的IPC socket/pipe文件名(转义过的显式路径) --rpccorsdomain value 允许跨域请求的域名列表(逗号分隔)(浏览器强制) --jspath loadScript JavaScript加载脚本的根路径(默认值:“.”) --exec value 执行JavaScript语句(只能结合console/attach使用) --preload value 预加载到控制台的JavaScript文件列表(逗号分隔) 网络选项:--bootnodes value 用于P2P发现引导的enode urls(逗号分隔)(对于light servers用v4+v5代替) --bootnodesv4 value 用于P2P v4发现引导的enode urls(逗号分隔) (light server, 全节点) --bootnodesv5 value 用于P2P v5发现引导的enode urls(逗号分隔) (light server, 轻节点) --port value 网卡监听端口(默认值:30303) --maxpeers value 最大的网络节点数量(如果设置为0，网络将被禁用)(默认值:25) --maxpendpeers value 最大尝试连接的数量(如果设置为0，则将使用默认值)(默认值:0) --nat value NAT端口映射机制 (any|none|upnp|pmp|extip:&lt;IP&gt;) (默认: “any”) --nodiscover 禁用节点发现机制(手动添加节点) --v5disc 启用实验性的RLPx V5(Topic发现)机制 --nodekey value P2P节点密钥文件 --nodekeyhex value 十六进制的P2P节点密钥(用于测试) 矿工选项:--mine 打开挖矿 --minerthreads value 挖矿使用的CPU线程数量(默认值:8) --etherbase value 挖矿奖励地址(默认=第一个创建的帐户)(默认值:“0”) --targetgaslimit value 目标gas限制：设置最低gas限制（低于这个不会被挖？） (默认值:“4712388”) --gasprice value 挖矿接受交易的最低gas价格 --extradata value 矿工设置的额外块数据(默认=client version) GAS价格选项:--gpoblocks value 用于检查gas价格的最近块的个数 (默认: 10) --gpopercentile value 建议gas价参考最近交易的gas价的百分位数，(默认: 50) 虚拟机的选项:--vmdebug 记录VM及合约调试信息 日志和调试选项:--metrics 启用metrics收集和报告 --fakepow 禁用proof-of-work验证 --verbosity value 日志详细度:0=silent, 1=error, 2=warn, 3=info, 4=debug, 5=detail (default: 3) --vmodule value 每个模块详细度:以 &lt;pattern&gt;=&lt;level&gt;的逗号分隔列表 (比如 eth/*=6,p2p=5) --backtrace value 请求特定日志记录堆栈跟踪 (比如 “block.go:271”) --debug 突出显示调用位置日志(文件名及行号) --pprof 启用pprof HTTP服务器 --pprofaddr value pprof HTTP服务器监听接口(默认值:127.0.0.1) --pprofport value pprof HTTP服务器监听端口(默认值:6060) --memprofilerate value 按指定频率打开memory profiling (默认:524288) --blockprofilerate value 按指定频率打开block profiling (默认值:0) --cpuprofile value 将CPU profile写入指定文件 --trace value 将execution trace写入指定文件 WHISPER实验选项:--shh 启用Whisper --shh.maxmessagesize value 可接受的最大的消息大小 (默认值: 1048576) --shh.pow value 可接受的最小的POW (默认值: 0.2) 弃用选项：--fast 开启快速同步 --light 启用轻客户端模式 其他选项:–help, -h 显示帮助 版权：Copyright 2013-2017 The go-ethereum Authors 翻译说明 有些参数翻译可能有不准确的地方，请大家指正。 原文会尽量随geth升级保持更新，原始链接：https://learnblockchain.cn/2017/11/29/geth_cmd_options/ 深入浅出区块链 - 系统学习区块链，打造最好的区块链技术博客。我的知识星球为各位解答区块链技术问题，欢迎加入讨论。","categories":[{"name":"以太坊","slug":"ethereum","permalink":"https://learnblockchain.cn/categories/ethereum/"},{"name":"geth","slug":"ethereum/geth","permalink":"https://learnblockchain.cn/categories/ethereum/geth/"}],"tags":[{"name":"Geth命令用法","slug":"Geth命令用法","permalink":"https://learnblockchain.cn/tags/Geth命令用法/"},{"name":"Geth命令参数详解","slug":"Geth命令参数详解","permalink":"https://learnblockchain.cn/tags/Geth命令参数详解/"},{"name":"Geth手册","slug":"Geth手册","permalink":"https://learnblockchain.cn/tags/Geth手册/"}]},{"title":"智能合约开发环境搭建及Hello World合约","slug":"init-env","date":"2017-11-24T11:41:53.000Z","updated":"2018-06-15T08:47:26.255Z","comments":true,"path":"2017/11/24/init-env/","link":"","permalink":"https://learnblockchain.cn/2017/11/24/init-env/","excerpt":"如果你对于以太坊智能合约开发还没有概念（本文会假设你已经知道这些概念），建议先阅读入门篇。就先学习任何编程语言一样，入门的第一个程序都是Hello World。今天我们来一步一步从搭建以太坊智能合约开发环境开始，讲解智能合约的Hello World如何编写。","text":"如果你对于以太坊智能合约开发还没有概念（本文会假设你已经知道这些概念），建议先阅读入门篇。就先学习任何编程语言一样，入门的第一个程序都是Hello World。今天我们来一步一步从搭建以太坊智能合约开发环境开始，讲解智能合约的Hello World如何编写。 开发环境搭建Solidity安装强烈建议新手使用Remix -Solidity IDE来进行开发。Remix 是一个基于浏览器的Solidity，就可以不用安装Solidity，本文的Hello World教程也将基于Remix Solidity IDE来进行。 如果你想自己安装请参考Solidity安装指引。 更新，开发环境搭建还可以看另一篇文章: 搭建智能合约开发环境Remix IDE及使用。 geth 安装Mac下安装命令如下：其他平台参考：geth官方安装指引12brew tap ethereum/ethereumbrew install ethereum brew 是 Mac 下的包管理工具，和Ubuntu里的apt-get类似 安装完以后，就是把geth控制台启动。 启动环境在入门篇讲过，geth是一个以太坊客户端，现在利用geth\b启动一个以太坊（开发者）网络节点。 1geth --datadir testNet --dev console 2&gt;&gt; test.log 执行命名后，会进入geth控制台，这时光标停在一个向右的箭头处，像这样： 命令参数说明（更多命令详解可阅读Geth命令用法-参数详解篇）:–dev 启用开发者网络（模式），开发者网络会使用POA共识，默认预分配一个开发者账户并且会自动开启挖矿。–datadir 后面的参数是区块数据及秘钥存放目录。第一次输入命令后，它会放在当前目录下新建一个testNet目录来存放数据。console 进入控制台2&gt;&gt; test.log 表示把控制台日志输出到test.log文件 为了更好的理解，建议新开一个命令行终端，实时显示日志：1tail -f test.log 准备账户部署智能合约需要一个外部账户，我们先来看看分配的开发者账户，在控制台使用以下命令查看账户：1&gt; eth.accounts 回车后，返回一个账户数组，里面有一个默认账户，如： 也可以使用personal.listAccounts查看账户， 再来看一下账户里的余额，使用一下命令：1&gt; eth.getBalance(eth.accounts[0]) eth.accounts[0]表示账户列表第一个账户回车后，可以看到大量的余额，如：1.15792089237316195423570985008687907853269… e+77 开发者账户因余额太多，如果用这个账户来部署合约时会无法看到余额变化，为了更好的体验完整的过程，这里选择创建一个新的账户。 创建账户使用以下命令创建账户：1&gt; personal.newAccount(&quot;TinyXiong&quot;) TinyXiong为新账户的密码，回车后，返回一个新账户。 这时我们查看账户列表：1&gt; eth.accounts 可以看到账户数组你包含两个账户，新账户在第二个（索引为1）位置。 现在看看账户的余额：12&gt; eth.getBalance(eth.accounts[1])0 回车后，返回的是0，新账户是0。结果如： 给新账户转账我们知道没有余额的账户是没法部署合约的，那我们就从默认账户转1以太币给新账户，使用以下命令（请使用你自己eth.accounts对应输出的账户）：1eth.sendTransaction(&#123;from: &apos;0xb0ebe17ef0e96b5c525709c0a1ede347c66bd391&apos;, to: &apos;0xf280facfd60d61f6fd3f88c9dee4fb90d0e11dfc&apos;, value: web3.toWei(1, &quot;ether&quot;)&#125;) 在打开的tail -f test.log日志终端里，可以同时看到挖矿记录再次查看新账户余额，可以新账户有1个以太币 解锁账户在部署合约前需要先解锁账户（就像银行转账要输入密码一样），使用以下命令：1personal.unlockAccount(eth.accounts[1],&quot;TinyXiong&quot;); “TinyXiong” 是之前创建账户时的密码解锁成功后，账户就准备完毕啦，接下来就是编写合约代码。 编写合约代码现在我们来开始编写第一个智能合约代码，solidity代码如下： 123456789101112pragma solidity ^0.4.18;contract hello &#123; string greeting; function hello(string _greeting) public &#123; greeting = _greeting; &#125; function say() constant public returns (string) &#123; return greeting; &#125;&#125; 简单解释下，我们定义了一个名为hello的合约，在合约初始化时保存了一个字符串（我们会传入hello world），每次调用say返回字符串。把这段代码写(拷贝)到Browser-Solidity，如果没有错误，点击Details获取部署代码，如： 在弹出的对话框中找到WEB3DEPLOY部分，点拷贝，粘贴到编辑器后，修改初始化字符串为hello world。 solidity在博文写作时（2017/11/24），版本为0.4.18，solidity发展非常快，solidity版本之间有可能不能兼容，这是你可以在Browser-Solidity的Settings里选择对应的编译器版本。Browser-Solidity也不停的更新中，截图可能和你看到的界面不一样。 部署合约Browser-Solidity生成的代码，拷贝到编辑器里修改后的代码如下： 1234567891011121314var _greeting = \"Hello World\" ;var helloContract = web3.eth.contract([&#123;\"constant\":true,\"inputs\":[],\"name\":\"say\",\"outputs\":[&#123;\"name\":\"\",\"type\":\"string\"&#125;],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"&#125;,&#123;\"inputs\":[&#123;\"name\":\"_greeting\",\"type\":\"string\"&#125;],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"&#125;]);var hello = helloContract.new( _greeting, &#123; from: web3.eth.accounts[1], data: '0x6060604052341561000f57600080fd5b6040516102b83803806102b8833981016040528080518201919050508060009080519060200190610041929190610048565b50506100ed565b828054600181600116156101000203166002900490600052602060002090601f016020900481019282601f1061008957805160ff19168380011785556100b7565b828001600101855582156100b7579182015b828111156100b657825182559160200191906001019061009b565b5b5090506100c491906100c8565b5090565b6100ea91905b808211156100e65760008160009055506001016100ce565b5090565b90565b6101bc806100fc6000396000f300606060405260043610610041576000357c0100000000000000000000000000000000000000000000000000000000900463ffffffff168063954ab4b214610046575b600080fd5b341561005157600080fd5b6100596100d4565b6040518080602001828103825283818151815260200191508051906020019080838360005b8381101561009957808201518184015260208101905061007e565b50505050905090810190601f1680156100c65780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b6100dc61017c565b60008054600181600116156101000203166002900480601f0160208091040260200160405190810160405280929190818152602001828054600181600116156101000203166002900480156101725780601f1061014757610100808354040283529160200191610172565b820191906000526020600020905b81548152906001019060200180831161015557829003601f168201915b5050505050905090565b6020604051908101604052806000815250905600a165627a7a723058204a5577bb3ad30e02f7a3bdd90eedcc682700d67fc8ed6604d38bb739c0655df90029', gas: '4700000' &#125;, function (e, contract)&#123; console.log(e, contract); if (typeof contract.address !== 'undefined') &#123; console.log('Contract mined! address: ' + contract.address + ' transactionHash: ' + contract.transactionHash); &#125; &#125;); 第1行：修改字符串为Hello World第2行：修改合约变量名第3行：修改合约实例变量名，之后可以直接用实例调用函数。第6行：修改部署账户为新账户索引，即使用新账户来部署合约。第8行：准备付的gas费用，IDE已经帮我们预估好了。第9行：设置部署回调函数。 拷贝回geth控制台里，回车后，看到输出如：1Contract mined! address: 0x79544078dcd9d560ec3f6eff0af42a9fc84c7d19 transactionHash: 0xe2caab22102e93434888a0b8013a7ae7e804b132e4a8bfd2318356f6cf0480b3 说明合约已经部署成功。 在打开的tail -f test.log日志终端里，可以同时看到挖矿记录 现在我们查看下新账户的余额：1&gt; eth.getBalance(eth.accounts[1]) 是不是比之前转账的余额少呀！ 运行合约12&gt; hello.say()&quot;Hello World&quot; 输出Hello World，我们第一个合约Hello World，成功运行了。 运行截图如下： 本文会随geth，solidity语言版本升级保持更新，查看本文原始链接：https://learnblockchain.cn/2017/11/24/init-env/ 第一个合约的意义更重要的是体验智能合约开发流程，对于初学者一些可以选择先放弃一些细节，开发流程打通之后，可以增强信心进行下一步的学习。有问题就加入深入浅出区块链群一起来交流吧。 深入浅出区块链 - 系统学习区块链，打造最好的区块链技术博客。我的知识星球为各位解答区块链技术问题，欢迎加入讨论。","categories":[{"name":"以太坊","slug":"ethereum","permalink":"https://learnblockchain.cn/categories/ethereum/"}],"tags":[{"name":"环境","slug":"环境","permalink":"https://learnblockchain.cn/tags/环境/"},{"name":"geth安装","slug":"geth安装","permalink":"https://learnblockchain.cn/tags/geth安装/"},{"name":"第一个智能合约","slug":"第一个智能合约","permalink":"https://learnblockchain.cn/tags/第一个智能合约/"}]},{"title":"以太坊是什么 - 以太坊开发入门指南","slug":"whatiseth","date":"2017-11-20T03:51:52.000Z","updated":"2018-07-19T09:52:55.358Z","comments":true,"path":"2017/11/20/whatiseth/","link":"","permalink":"https://learnblockchain.cn/2017/11/20/whatiseth/","excerpt":"很多同学已经跃跃欲试投入到区块链开发队伍当中来，可是又感觉无从下手，本文将基于以太坊平台，以通俗的方式介绍以太坊开发中涉及的各晦涩的概念，轻松带大家入门。","text":"很多同学已经跃跃欲试投入到区块链开发队伍当中来，可是又感觉无从下手，本文将基于以太坊平台，以通俗的方式介绍以太坊开发中涉及的各晦涩的概念，轻松带大家入门。 写在前面阅读本文前，你应该大概了解区块链是什么，如果你还不了解，欢迎订阅专栏：区块链技术指引你从头开始学区块链技术。 以太坊是什么以太坊（Ethereum）是一个建立在区块链技术之上， 去中心化应用平台。它允许任何人在平台中建立和使用通过区块链技术运行的去中心化应用。 对这句话不理解的同学，姑且可以理解为以太坊是区块链里的Android，它是一个开发平台，让我们就可以像基于Android Framework一样基于区块链技术写应用。 在没有以太坊之前，写区块链应用是这样的：拷贝一份比特币代码，然后去改底层代码如加密算法，共识机制，网络协议等等（很多山寨币就是这样，改改就出来一个新币）。以太坊平台对底层区块链技术进行了封装，让区块链应用开发者可以直接基于以太坊平台进行开发，开发者只要专注于应用本身的开发，从而大大降低了难度。 目前围绕以太坊已经形成了一个较为完善的开发生态圈：有社区的支持，有很多开发框架、工具可以选择。 智能合约什么是智能合约以太坊上的程序称之为智能合约， 它是代码和数据(状态)的集合。 智能合约可以理解为在区块链上可以自动执行的（由消息驱动的）、以代码形式编写的合同（特殊的交易）。 智能合约英文是Smart Contract，和人工智能（ AI:Artificial Intelligence ）的智能没有关系，最早尼克萨博在95年就提出智能合约的概念，它的概念很简单，就是将法律条文写成可执行代码。当时并没有区块链，不过智能合约与区块链最配，我们知道合同都是要一式两份、三或四份，不能控制在某一方手中，这也就是去中心化。 在比特币脚本中，我们讲到过比特币的交易是可以编程的，但是比特币脚本有很多的限制，能够编写的程序也有限，而以太坊则更加完备（在计算机科学术语中，称它为是“图灵完备的”），让我们就像使用任何高级语言一样来编写几乎可以做任何事情的程序（智能合约）。 智能合约非常适合对信任、安全和持久性要求较高的应用场景，比如：数字货币、数字资产、投票、保险、金融应用、预测市场、产权所有权管理、物联网、点对点交易等等。目前除数字货币之外，真正落地的应用还不多（就像移动平台刚开始出来一样），相信1到3年内，各种杀手级会慢慢出现。 编程语言：Solidity智能合约的官方推荐的编程语言是Solidity，文件扩展名以.sol结尾。Solidity语言和JavaScript很相似，用它来开发合约并编译成以太坊虚拟机字节代码。 还有Viper，Serpent，LLL及Bamboo，建议大家还是使用Solidity。更新：Serpent官方已经不再推荐，建议Serpent的用户转换到Viper，他们都是类Python语言。 Browser-Solidity是一个浏览器的Solidity IDE, 大家可以点进去看看，以后我们更多文章介绍Solidity这个语言。 运行环境：EVMEVM（Ethereum Virtual Machine）以太坊虚拟机是以太坊中智能合约的运行环境。 Solidity之于EVM，就像之于跟JVM的关系一样，这样大家就容易理解了。以太坊虚拟机是一个隔离的环境，外部无法接触到在EVM内部运行的代码。 而EVM运行在以太坊节点上，当我们把合约部署到以太坊网络上之后，合约就可以在以太坊网络中运行了。 合约的编译以太坊虚拟机上运行的是合约的字节码形式，需要我们在部署之前先对合约进行编译，可以选择Browser-Solidity Web IDE或solc编译器。 合约的部署在以太坊上开发应用时，常常要使用到以太坊客户端（钱包）。平时我们在开发中，一般不接触到客户端或钱包的概念，它是什么呢？ 以太坊客户端（钱包）以太坊客户端，其实我们可以把它理解为一个开发者工具，它提供账户管理、挖矿、转账、智能合约的部署和执行等等功能。 EVM是由以太坊客户端提供的 Geth是典型的开发以太坊时使用的客户端，基于Go语言开发。 Geth提供了一个交互式命令控制台，通过命令控制台中包含了以太坊的各种功能（API）。Geth的使用我们之后会有文章介绍，这里大家先有个概念。 \bGeth控制台和Chrome浏览器开发者工具里的面的控制台是类似的，不过Geth控制台是跑在终端里。相对于Geth，Mist则是图形化操作界面的以太坊客户端。 如何部署智能合约的部署是指把合约字节码发布到区块链上，并使用一个特定的地址来标示这个合约，这个地址称为合约账户。 以太坊中有两类账户： 外部账户该类账户被私钥控制（由人控制），没有关联任何代码。 合约账户该类账户被它们的合约代码控制且有代码与之关联。 和比特币使用UTXO的设计不一样，以太坊使用更为简单的账户概念。两类账户对于EVM来说是一样的。 外部账户与合约账户的区别和关系是这样的：一个外部账户可以通过创建和用自己的私钥来对交易进行签名，来发送消息给另一个外部账户或合约账户。在两个外部账户之间传送消息是价值转移的过程。但从外部账户到合约账户的消息会激活合约账户的代码，允许它执行各种动作（比如转移代币，写入内部存储，挖出一个新代币，执行一些运算，创建一个新的合约等等）。只有当外部账户发出指令时，合同账户才会执行相应的操作。 合约部署就是将编译好的合约字节码通过外部账号发送交易的形式部署到以太坊区块链上（由实际矿工出块之后，才真正部署成功）。 运行合约部署之后，当需要调用这个智能合约的方法时只需要向这个合约账户发送消息（交易）即可，通过消息触发后智能合约的代码就会在EVM中执行了。 Gas和云计算相似，占用区块链的资源（不管是简单的转账交易，还是合约的部署和执行）同样需要付出相应的费用（天下没有免费的午餐对不对!）。以太坊上用Gas机制来计费，Gas也可以认为是一个工作量单位，智能合约越复杂（计算步骤的数量和类型，占用的内存等），用来完成运行就需要越多Gas。任何特定的合约所需的运行合约的Gas数量是固定的，由合约的复杂度决定。而Gas价格由运行合约的人在提交运行合约请求的时候规定，以确定他愿意为这次交易愿意付出的费用：Gas价格（用以太币计价） * Gas数量。 Gas的目的是限制执行交易所需的工作量，同时为执行支付费用。当EVM执行交易时，Gas将按照特定规则被逐渐消耗，无论执行到什么位置，一旦Gas被耗尽，将会触发异常。当前调用帧所做的所有状态修改都将被回滚， 如果执行结束还有Gas剩余，这些Gas将被返还给发送账户。 如果没有这个限制，就会有人写出无法停止（如：死循环）的合约来阻塞网络。 因此实际上（把前面的内容串起来），我们需要一个有以太币余额的外部账户，来发起一个交易（普通交易或部署、运行一个合约），运行时，矿工收取相应的工作量费用。 以太坊网络有些着急的同学要问了，没有以太币，要怎么进行智能合约的开发？可以选择以下方式： 选择以太坊官网测试网络Testnet测试网络中，我们可以很容易获得免费的以太币，缺点是需要发很长时间初始化节点。 使用私有链创建自己的以太币私有测试网络，通常也称为私有链，我们可以用它来作为一个测试环境来开发、调试和测试智能合约。通过上面提到的Geth很容易就可以创建一个属于自己的测试网络，以太币想挖多少挖多少，也免去了同步正式网络的整个区块链数据。 使用开发者网络(模式)相比私有链，开发者网络(模式)下，会自动分配一个有大量余额的开发者账户给我们使用。 使用模拟环境另一个创建测试网络的方法是使用testrpc，testrpc是在本地使用内存模拟的一个以太坊环境，对于开发调试来说，更方便快捷。而且testrpc可以在启动时帮我们创建10个存有资金的测试账户。进行合约开发时，可以在testrpc中测试通过后，再部署到Geth节点中去。 更新：testrpc 现在已经并入到Truffle 开发框架中，现在名字是Ganache CLI。 Dapp：去中心化的应用程序以太坊社区把基于智能合约的应用称为去中心化的应用程序(Decentralized App)。如果我们把区块链理解为一个不可篡改的数据库，智能合约理解为和数据库打交道的程序，那就很容易理解Dapp了，一个Dapp不单单有智能合约，比如还需要有一个友好的用户界面和其他的东西。 TruffleTruffle是Dapp开发框架，他可以帮我们处理掉大量无关紧要的小事情，让我们可以迅速开始写代码-编译-部署-测试-打包DApp这个流程。 总结我们现在来总结一下，以太坊是平台，它让我们方便的使用区块链技术开发去中心化的应用，在这个应用中，使用Solidity来编写和区块链交互的智能合约，合约编写好后之后，我们需要用以太坊客户端用一个有余额的账户去部署及运行合约（使用Truffle框架可以更好的帮助我们做这些事情了）。为了开发方便，我们可以用Geth或testrpc来搭建一个测试网络。 注：本文中为了方便大家理解，对一些概念做了类比，有些严格来不是准确，不过我也认为对于初学者，也没有必要把每一个概念掌握的很细致和准确，学习是一个逐步深入的过程，很多时候我们会发现，过一段后，我们会对同一个东西有不一样的理解。 本文完，这些概念你都明白了么？现在你可以开始开发了，看看智能合约开发环境搭建及Hello World合约 深入浅出区块链 - 系统学习区块链，打造最好的区块链技术博客。我的知识星球为各位解答区块链技术问题，欢迎加入讨论，作为星友福利，星友可加入区块链技术交流群，群内已经聚集了300多位区块链技术牛人和爱好者。","categories":[{"name":"以太坊","slug":"ethereum","permalink":"https://learnblockchain.cn/categories/ethereum/"}],"tags":[{"name":"以太坊概念","slug":"以太坊概念","permalink":"https://learnblockchain.cn/tags/以太坊概念/"},{"name":"以太坊入门","slug":"以太坊入门","permalink":"https://learnblockchain.cn/tags/以太坊入门/"},{"name":"ethereum","slug":"ethereum","permalink":"https://learnblockchain.cn/tags/ethereum/"}]},{"title":"非对称加密技术- RSA算法数学原理分析","slug":"asy-encryption","date":"2017-11-15T02:53:27.000Z","updated":"2018-02-08T12:22:22.000Z","comments":true,"path":"2017/11/15/asy-encryption/","link":"","permalink":"https://learnblockchain.cn/2017/11/15/asy-encryption/","excerpt":"非对称加密技术，在现在网络中，有非常广泛应用。加密技术更是数字货币的基础。 所谓非对称，就是指该算法需要一对密钥，使用其中一个（公钥）加密，则需要用另一个（私钥）才能解密。但是对于其原理大部分同学应该都是一知半解，今天就来分析下经典的非对称加密算法 - RSA算法。通过本文的分析，可以更好的理解非对称加密原理，可以让我们更好的使用非对称加密技术。","text":"非对称加密技术，在现在网络中，有非常广泛应用。加密技术更是数字货币的基础。 所谓非对称，就是指该算法需要一对密钥，使用其中一个（公钥）加密，则需要用另一个（私钥）才能解密。但是对于其原理大部分同学应该都是一知半解，今天就来分析下经典的非对称加密算法 - RSA算法。通过本文的分析，可以更好的理解非对称加密原理，可以让我们更好的使用非对称加密技术。 题外话:本博客一直有打算写一系列文章通俗的密码学，昨天给站点上https, 因其中使用了RSA算法，就查了一下，发现现在网上介绍RSA算法的文章都写的太难理解了，反正也准备写密码学，就先写RSA算法吧，下面开始正文。 RSA算法原理RSA算法的基于这样的数学事实：两个大质数相乘得到的大数难以被因式分解。如：有很大质数p跟q，很容易算出N，使得 N = p * q，但给出N, 比较难找p q（没有很好的方式， 只有不停的尝试） 这其实也是单向函数的概念 下面来看看数学演算过程： 选取两个大质数p，q，计算N = p q 及 φ ( N ) = φ (p) φ (q) = (p-1) * (q-1) 三个数学概念：质数(prime numbe)：又称素数，为在大于1的自然数中，除了1和它本身以外不再有其他因数。互质关系：如果两个正整数，除了1以外，没有其他公因子，我们就称这两个数是互质关系（coprime）。φ(N)：叫做欧拉函数，是指任意给定正整数N，在小于等于N的正整数之中，有多少个与N构成互质关系。 如果n是质数，则 φ(n)=n-1。如果n可以分解成两个互质的整数之积， φ(n) = φ(p1p2) = φ(p1)φ(p2)。即积的欧拉函数等于各个因子的欧拉函数之积。 选择一个大于1 小于φ(N)的数e，使得 e 和 φ(N)互质 e其实是1和φ(N)之前的一个质数 计算d，使得de=1 mod φ(N) 等价于方程式 ed-1 = k φ(N) 求一组解。 d 称为e的模反元素，e 和 φ(N)互质就肯定存在d。 模反元素是指如果两个正整数a和n互质，那么一定可以找到整数b，使得ab被n除的余数是1，则b称为a的模反元素。可根据欧拉定理证明模反元素存在，欧拉定理是指若n,a互质，则：a^φ(n) ≡ 1(mod n) 及 a^φ(n) = a * a^（φ(n) - 1）， 可得a的 φ(n)-1 次方，就是a的模反元素。 (N, e)封装成公钥，(N, d)封装成私钥。假设m为明文，加密就是算出密文c: m^e mod N = c (明文m用公钥e加密并和随机数N取余得到密文c)解密则是： c^d mod N = m (密文c用密钥解密并和随机数N取余得到明文m) 私钥解密这个是可以证明的，这里不展开了。 加解密步骤具体还是来看看步骤，举个例子，假设Alice和Bob又要相互通信。 Alice 随机取大质数P1=53，P2=59，那N=53*59=3127，φ(N)=3016 取一个e=3，计算出d=2011。 只将N=3127，e=3 作为公钥传给Bob（公钥公开） 假设Bob需要加密的明文m=89，c = 89^3 mod 3127=1394，于是Bob传回c=1394。 （公钥加密过程） Alice使用c^d mod N = 1394^2011 mod 3127，就能得到明文m=89。 （私钥解密过程） 假如攻击者能截取到公钥n=3127，e=3及密文c=1394，是仍然无法不通过d来进行密文解密的。 安全性分析那么，有无可能在已知n和e的情况下，推导出d？123 1. ed≡1 (mod φ(n))。只有知道e和φ(n)，才能算出d。 2. φ(n)=(p-1)(q-1)。只有知道p和q，才能算出φ(n)。 3. n=pq。只有将n因数分解，才能算出p和q。 如果n可以被因数分解，d就可以算出，因此RSA安全性建立在N的因式分解上。大整数的因数分解，是一件非常困难的事情。只要密钥长度足够长，用RSA加密的信息实际上是不能被解破的。 补充模运算规则 模运算加减法： (a + b) mod p = (a mod p + b mod p) mod p (a - b) mod p = (a mod p - b mod p) mod p 模运算乘法： (a b) mod p = (a mod p b mod p) mod p 模运算幂 a ^ b mod p = ((a mod p)^b) mod p 深入浅出区块链 - 系统学习区块链，打造最好的区块链技术博客。我的知识星球为各位解答区块链技术问题，欢迎加入讨论。","categories":[{"name":"密码学","slug":"cryptography","permalink":"https://learnblockchain.cn/categories/cryptography/"}],"tags":[{"name":"非对称加密","slug":"非对称加密","permalink":"https://learnblockchain.cn/tags/非对称加密/"},{"name":"数学","slug":"数学","permalink":"https://learnblockchain.cn/tags/数学/"},{"name":"RSA算法","slug":"RSA算法","permalink":"https://learnblockchain.cn/tags/RSA算法/"}]},{"title":"比特币脚本及交易分析 - 智能合约雏形","slug":"bitcoin-script","date":"2017-11-10T09:05:33.000Z","updated":"2018-02-08T12:24:30.318Z","comments":true,"path":"2017/11/10/bitcoin-script/","link":"","permalink":"https://learnblockchain.cn/2017/11/10/bitcoin-script/","excerpt":"大家都有转过账，每笔交易是这样的：张三账上减￥200，李四账上加￥200。在比特币区块链中，交易不是这么简单，\b\b交易实际是通过脚本来完成，以承载更多的功能个，这也是为什么比特币被称为是一种“可编程的货币”。本文就来分析一下交易是如何实现可编程的。","text":"大家都有转过账，每笔交易是这样的：张三账上减￥200，李四账上加￥200。在比特币区块链中，交易不是这么简单，\b\b交易实际是通过脚本来完成，以承载更多的功能个，这也是为什么比特币被称为是一种“可编程的货币”。本文就来分析一下交易是如何实现可编程的。 未花费的交易输出(UTXO)先引入一个概念：未花费的交易输出——UTXO（Unspent Transaction Output） 其实比特币的交易都是基于UTXO上的，即交易的输入是之前交易未花费的输出，这笔交易的输出可以被当做下一笔新交易的输入。 挖矿奖励属于一个特殊的交易（称为coinbase交易），可以没有输入。UTXO是交易的基本单元，不能再分割。在比特币没有余额概念，只有分散到区块链里的UTXO 随着钱从一个地址被移动到另一个地址的同时形成了一条所有权链，像这样： 比特币脚本比特币交易是首先要提供一个用于解锁UTXO（用私钥去匹配锁定脚本）的脚本（常称为解锁脚本：Signature script)，这也叫交易输入，交易的输出则是指向一个脚本（称为锁定脚本：PubKey script），这个脚本表达了：谁的签名（签名是常见形式，\b并不一定必须是签名）能匹配这个输出地址，钱就支付给谁。 每一个比特币节点会通过同时执行这解锁和锁定脚本（不是当前的锁定脚本，是指上一个交易的锁定脚本）来验证一笔交易，脚本组合结果为真，则为有效交易。 当解锁版脚本与锁定版脚本的设定条件相匹配时，执行组合有效脚本时才会显示结果为真 如最为常见类型的比特币交易脚本（支付到公钥哈希：P2PKH（Pay-to-Public-Key-Hash））组合是这样： 常见交易脚本验证过程比特币交易脚本语言是一种基于逆波兰表示法的基于栈的执行语言（不知道逆波兰和栈的同学去翻大学数据结构课本，你也可跳过这个部分）。 比特币脚本语言包含基本算数计算、基本逻辑(比如if…then)、报错以及返回结果和一些加密指令，不支持循环。想了解更多语言细节可参考:比特币脚本 脚本语言通过从左至右地处理每个项目的方式执行脚本。 下面用两个图说明下常见类型的比特币交易脚本验证执行过程：上图为解锁脚本运行过程（主要是入栈）上图为锁定脚本运行过程（主要是出栈），最后的结果为真，说明交易有效。 交易分析实际上比特币的交易被设计为可以纳入多个输入和输出。 交易结构我们来看看完整的交易结构， 交易的锁定时间定义了能被加到区块链里的最早的交易时间。在大多数交易里，它被设置成0，用来表示立即执行。如果锁定时间不是0并且小于5亿，就被视为区块高度，意指在这个指定的区块高度之前，该交易不会被包含在区块链里。如果锁定时间大于5亿，则它被当作是一个Unix纪元时间戳（从1970年1月1日以来的秒数），并且在这个指定时间之前，该交易不会被包含在区块链里。 交易的数据结构没有交易费的字段，交易费通过所有输入的总和，以及所有输出的总和之间的差来表示，即： 交易费 = 求和（所有输入） - 求和（所有输出） 交易输入结构刚刚我们提过输入需要提供一个解锁脚本，现在来看看一个交易的输入结构： 我们结合整个交易的结构里看输入结构就是这样子： 交易输出结构刚刚我们提过输出是指向一个解锁脚本，具体交易的输出结构为：我们结合整个交易的结构里看输出结构就是这样子： 交易哈希计算在比特币区块结构Merkle 树及简单支付验证分析 讲到区块结构，区块结构包含多个交易的哈希。那么交易哈希是怎么计算的呢？ 交易结构各字段序列化为字节数组 把字节数组拼接为支付串 对支付串计算两次SHA256 得到交易hash 了解详情可进一步参考如何计算交易Hash?及如何创建Hash? 现在是不是对完整的交易到区块有了更清晰的认识。 智能合约雏形 - 应用场景说明由于交易是通过脚本来实现，脚本语言可以表达出无数的条件变种。 比特币的脚本目前常用的主要分为两种，一种是常见的P2PKH（支付给公钥哈希），另一种是P2SH（Pay-to-Script-Hash支付脚本哈希）。P2SH支付中，锁定脚本被密码学哈希所取代，当一笔交易试图支付UTXO时，要解锁支付脚本，它必须含有与哈希相匹配的脚本。 这里不展开技术细节，下面说明一些应用场景，以便大家有更直观的认识。 多重签名应用合伙经营中，如只有一半以上的的股东同意签名就可以进行支付，可为公司治理提供管控便利，同时也能有效防范盗窃、挪用和遗失。 用于担保和争端调解，一个买家想和他不认识或不信任的某人交易，在一般情况交易正常进行时，买家不想任何第三方参与。那交易双方可以发起支付，但如果交易出现问题时，那第三方就可以根据裁定，使用自己的签名和裁定认可的一方共同签名来兑现这笔交易。 保证合同保证合同是建造公众商品时的集资办法，公众商品是指一旦建成，任何人都可以免费享受到好处。标准的例子是灯塔，所有人都认同应该建造一个，但是对于个人航海者来说灯塔太贵了，灯塔同时也会方便其他航海者。一个解决方案是向所有人集资，只有当筹集的资金超过所需的建造成本时，每个人才真正付钱，如果集资款不足，则谁都不用付钱。 依靠预言假如老人想让他孙子继承遗产，继承时间是在他死后或者在孙子年满18岁时（也是一个带锁定时间交易），无论哪个条件先满足，他的孙子都可以得到遗产。因为比特币节点可依靠预言对死亡条件进行判断，预言是指具有密钥对的服务器，当用户自定义的表达式被证明是真的，它能按照要求对交易签名。 相信随着区块链的普及，会对未来的交易模式和商业结构带来巨大的影响。不过由于比特币的脚本语言不是图灵完备的，交易模式依旧有限，以太坊就是为解决这一问题而出现，后面我们会有大量介绍以太坊的文章。 参考文献 &amp; 补充阅读 精通比特币 廖雪峰的深入理解比特币交易的脚本 比特币合同 深入浅出区块链 - 系统学习区块链，打造最好的区块链技术博客。我的知识星球为各位解答区块链技术问题，欢迎加入讨论。","categories":[{"name":"比特币","slug":"bitcoin","permalink":"https://learnblockchain.cn/categories/bitcoin/"}],"tags":[{"name":"比特币脚本","slug":"比特币脚本","permalink":"https://learnblockchain.cn/tags/比特币脚本/"},{"name":"交易结构","slug":"交易结构","permalink":"https://learnblockchain.cn/tags/交易结构/"}]},{"title":"比特币区块结构Merkle树及简单支付验证分析","slug":"merkle","date":"2017-11-09T02:03:36.000Z","updated":"2018-01-10T08:11:16.136Z","comments":true,"path":"2017/11/09/merkle/","link":"","permalink":"https://learnblockchain.cn/2017/11/09/merkle/","excerpt":"在比特币网络中，不是每个节点都有能力储存完整的区块链数据，受限于存储空间的的限制，很多节点是以SPV（Simplified Payment Verification简单支付验证）钱包接入比特币网络，通过简单支付验证可以在不必存储完整区块链下对交易进行验证，本文将分析区块结构Merkle树及如何进行交易验证。","text":"在比特币网络中，不是每个节点都有能力储存完整的区块链数据，受限于存储空间的的限制，很多节点是以SPV（Simplified Payment Verification简单支付验证）钱包接入比特币网络，通过简单支付验证可以在不必存储完整区块链下对交易进行验证，本文将分析区块结构Merkle树及如何进行交易验证。 区块结构在工作量证明中出现过一个区块信息截图： 细心的同学一定已经在里面发现了很多未讲的其他信息，如：时间戳，版本号，交易次数，二进制哈希树根(Merkle根)等。 我们来看看一个区块结构到底是怎样的： 如上图（下文称：区块结构图）所示：每个数据区块包含区块头和区块体。区块头封装了当前版本号、前一区块哈希值、当前区块PoW要求的随机数(Nonce)、时间戳、以及Merkle根信息。区块体则包括当前区块经过验证的、 区块创建过程中生成的所有交易记录。这些记录通过 Merkle树的哈希过程生成唯一的Merkle根并记入区块头. 区块哈希值实际上并不包含在区块的数据结构里，其实区块打包时只有区块头被用于计算哈希（从网络被接收时由每个节点计算出来），常说的区块哈希值实际是区块头哈希值，它可以用来唯一、明确地标识一个区块。 区块头是80字节，而平均每个交易至少是250字节，而且平均每个区块包含2000个交易。因此，包含完整交易的区块比区块头的4千倍还要大。SPV节点只下载区块头，不下载包含在每个区块中的交易信息。这样的不含交易信息的区块链，大小只有完整区块链的几千分之1，那SPV节点是如何验证交易的呢？ 哈希验证上面先留一个引子，先来回顾下哈希函数，记账原理我们知道原始信息任何微小的变化都会哈希完全不同的哈希值。 简单文件验证我们通常用哈希来检验下载的文件是否完整，我经常看到这样的下载页面：可以看到下载链接后面提供了一个MD5（MD5也是一种Hash算法），这样我们可以在下载之后对文件计算MD5，如果MD5与提供的MD5相等，说明文件有没有被损坏，这个验证过程相信大家都能理解。 多点文件验证(哈希列表)现在复杂度提高一点，在P2P网络中下载时，会把大文件切成小文件，同时从多个机器上下载数据，这个时候怎么验证数据呢？ 以BT下载为例，在下载真正的数据之前，我们会先下载一个哈希列表的（每个下小块计算出一个哈希），如果有一个小块数据在传输过程中损坏了，那我只要重新下载这一个数据块就行了，这时有一个问题就出现了，那么多的哈希，怎么保证它们本身(哈希列表中的哈希值)都是正确地呢？ 答案是把每个小块数据的哈希值拼到一起，然后对这个长字符串在作一次哈希运算，得到哈希列表的根哈希。只要根哈希校对比一样就说明验哈希列表是正确的，再通过哈希列表校验小数据块，如果所有的小数据块验证通过则说明大文件没有被损坏。 Merkle\b树验证交易的过程和文件验证很相似，可以人为每个交易是一个小数据块，但比特币使用Merkle\b树的方式进行验证，相对于哈希列表，Merkle树是一种哈希二叉树，它的明显的一个好处是可以单独拿出一个分支来（作为一个小树）对部分数据进行校验，更加高效。 我们回看下上面的区块结构图，区块体就包含这样一个Merkle\b树,Merkle树被用来归纳一个区块中的所有交易。 每个叶子节点是每个交易信息的哈希，往上对相邻的两个哈希合并成字符串再哈希，继续类似的操作直到只剩下顶部的一个节点，即Merkle根，存入区块头。 因为Merkle树是二叉树，所以它需要偶数个叶子节点。如果仅有奇数个交易需要归纳，那最后的交易就会被复制一份以构成偶数个叶子节点，这种偶数个叶子节点的树也被称为平衡树。 简化支付验证SPV节点不保存所有交易也不会下载整个区块，仅仅保存区块头，我们来看看它是如何对交易数据进行验证的。 假如要验证区块结构图中交易6，SPV节点会通过向相邻节点索要（通过Merkleblock消息）包括从交易6哈希值沿Merkle树上溯至区块头根哈希处的哈希序列 (即哈希节点6, 5, 56, 78, 5678, 1234 1~8 - 称为认证路径) 来确认交易的存在性和正确性。（在N个交易组成的区块中确认任一交易只需要计算log2(N)个字节的哈希值，非常快速高效） 大家明白了吗？ 深入浅出区块链 - 系统学习区块链，打造最好的区块链技术博客。我的知识星球为各位解答区块链技术问题，欢迎加入讨论。","categories":[{"name":"比特币","slug":"bitcoin","permalink":"https://learnblockchain.cn/categories/bitcoin/"}],"tags":[{"name":"比特币","slug":"比特币","permalink":"https://learnblockchain.cn/tags/比特币/"},{"name":"区块结构","slug":"区块结构","permalink":"https://learnblockchain.cn/tags/区块结构/"},{"name":"Merkle树","slug":"Merkle树","permalink":"https://learnblockchain.cn/tags/Merkle树/"},{"name":"SPV简单支付验证","slug":"SPV简单支付验证","permalink":"https://learnblockchain.cn/tags/SPV简单支付验证/"}]},{"title":"分析比特币网络：一种去中心化、点对点的网络架构","slug":"bitcoin-p2p","date":"2017-11-07T03:25:30.000Z","updated":"2018-01-10T08:10:25.198Z","comments":true,"path":"2017/11/07/bitcoin-p2p/","link":"","permalink":"https://learnblockchain.cn/2017/11/07/bitcoin-p2p/","excerpt":"比特币采用了基于互联网的点对点（P2P：peer-to-peer）分布式网络架构。比特币网络可以认为是按照比特币P2P协议运行的一系列节点的集合。本文来分析下比特币网络，了解它跟传统中心化网络的区别，以及比特币网络是如何发现相邻节点的。","text":"比特币采用了基于互联网的点对点（P2P：peer-to-peer）分布式网络架构。比特币网络可以认为是按照比特币P2P协议运行的一系列节点的集合。本文来分析下比特币网络，了解它跟传统中心化网络的区别，以及比特币网络是如何发现相邻节点的。 中心化网络为了更好的理解P2P网络，我们先来看看传统的中心化模型： 这是一种典型的星型（“中心化”）结构，我们常见B/S及C/S网络架构就是这种模型，C1 、C2 、C3等之间没法直接的连接，C节点如果要连接必须要通过中心化S节点做为桥梁。中心化节点充当服务者、中介作用，比如我们没有办法把资金直接从一个人转移给另一个人，必须通过银行这个中介。 P2P网络P2P网络是指位于同一网络中的每台计算机都彼此对等，各个节点共同提供网络服务，不存在任何“特殊”节点，每个网络节点以扁平（flat）的拓扑结构相互连通。 对比中心化网络，在P2P网络中不存在任何服务端（server）、中央化的服务。P2P网络的节点之间交互连接、协同，每个节点在对外提供服务的同时也使用网络中其他节点所提供的服务，每个节点即是服务端又是客户端。P2P网络模型除应用于比特币网络，使用广泛的BT下载就是基于P2P网络。 P2P网络不仅仅去除了中心化带来的风险（中心化可能作恶），还可以提高传输的效率。（中心化网络当能也有优点） 如何发现节点既然每个网络节点都是平等的（是指在网络层面上节点是平等的，但各节点在功能上可以有不同的分工, 如钱包节点、挖矿节点等），不存在任何“特殊”中心节点，那么当新的网络节点启动后，它是如何跟其他的节点建立连接，从而加入到比特币网络呢？ 在中心化网络中，新加入的节点只要连接“特殊”的中心节点就可以加入网络。 为了能够加入到比特币网络，比特币客户端会做一下几件事情： 节点会记住它最近成功连接的网络节点，当重新启动后它可以迅速与先前的对等节点网络重新建立连接。 节点会在失去已有连接时尝试发现新节点。 当建立一个或多个连接后，节点将一条包含自身IP地址消息发送给其相邻节点。相邻节点再将此消息依次转发给它们各自的相邻节点，从而保证节点信息被多个节点所接收、保证连接更稳定。 新接入的节点可以向它的相邻节点发送获取地址getaddr消息，要求它们返回其已知对等节点的IP地址列表。节点可以找到需连接到的对等节点。 在节点启动时，可以给节点指定一个正活跃节点IP, 如果没有，客户端也维持一个列表，列出了那些长期稳定运行的节点。这样的节点也被称为种子节点（其实和BT下载的种子文件道理是一样的），就可以通过种子节点来快速发现网络中的其他节点。 节点通信简述比特币节点通常采用TCP协议、使用8333端口与相邻节点建立连接, 建立连接时也会有认证“握手”的通信过程，用来确定协议版本，软件版本，节点IP，区块高度等。 当节点连接到相邻节点后，接着就开始跟相邻节点同步区块链数据（轻量级钱包应用其实不会同步所有区块数据），节点们会交换一个getblocks消息，它包含本地区块链最顶端的哈希值。如果某个节点识别出它接收到的哈希值并不属于顶端区块，而是属于一个非顶端区块的旧区块，就说其自身的本地区块链比其他节点的区块链更长，并告诉其他节点需要补充区块，其他节点发送getdata消息来请求区块，验证后更新到本地区块链中。 深入浅出区块链 - 系统学习区块链，打造最好的区块链技术博客我的知识星球为各位解答区块链技术问题，欢迎加入讨论。","categories":[{"name":"比特币","slug":"bitcoin","permalink":"https://learnblockchain.cn/categories/bitcoin/"}],"tags":[{"name":"p2p","slug":"p2p","permalink":"https://learnblockchain.cn/tags/p2p/"},{"name":"去中心化","slug":"去中心化","permalink":"https://learnblockchain.cn/tags/去中心化/"},{"name":"比特币网络","slug":"比特币网络","permalink":"https://learnblockchain.cn/tags/比特币网络/"}]},{"title":"比特币如何挖矿（挖矿原理）-工作量证明","slug":"bitcoin-pow","date":"2017-11-04T08:12:29.000Z","updated":"2018-04-11T14:40:08.227Z","comments":true,"path":"2017/11/04/bitcoin-pow/","link":"","permalink":"https://learnblockchain.cn/2017/11/04/bitcoin-pow/","excerpt":"在区块链记账原理 一篇，我们了解到记账是把交易记录、交易时间、账本序号、上一个Hash值等信息计算Hash打包的过程。我们知道所有的计算和存贮是需要消耗计算机资源的，既然要付出成本，那节点为什么还要参与记账呢？在中本聪（比特币之父）的设计里，完成记账的节点可以获得系统给与的一定数量的比特币奖励，这个奖励的过程也就是比特币的发行过程，因此大家形象的把记账称为“挖矿”，本文将详细讨论这个过程。","text":"在区块链记账原理 一篇，我们了解到记账是把交易记录、交易时间、账本序号、上一个Hash值等信息计算Hash打包的过程。我们知道所有的计算和存贮是需要消耗计算机资源的，既然要付出成本，那节点为什么还要参与记账呢？在中本聪（比特币之父）的设计里，完成记账的节点可以获得系统给与的一定数量的比特币奖励，这个奖励的过程也就是比特币的发行过程，因此大家形象的把记账称为“挖矿”，本文将详细讨论这个过程。 记账工作由于记账是有奖励的，每次记账都可以给自己凭空增加一定数量的个比特币（当前是12.5比特币，博文写作时每个比特币是4万人民币以上，大家可以算算多少钱），因此就出现大家争相记账，大家一起记账就会引起问题：出现记账不一致的问题，比特币系统引入工作量证明来解决这个问题，规则如下： 一段时间内（10分钟左右，具体时间会与密码学难题难度相互影响）只有一人可以记账成功 通过解决密码学难题（即工作量证明）竞争获得唯一记账权 其他节点复制记账结果 不过在进行工作量证明之前，记账节点会做进行如下准备工作： 收集广播中还没有被记录账本的原始交易信息 检查每个交易信息中付款地址有没有足够的余额 验证交易是否有正确的签名 把验证通过的交易信息进行打包记录 添加一个奖励交易：给自己的地址增加12.5比特币 如果节点争夺记账权成功的话，就可以得到12.5比特币的奖励。 工作量证明区块链记账原理我们了解到，每次记账的时候会把上一个块的Hash值和当前的账页信息一起作为原始信息进行Hash。如果仅仅是这样，显然每个人都可以很轻松的完成记账。为了保证10分钟左右只有一个人可以记账，就必须要提高记账的难度，使得Hash的结果必须以若干个0开头。同是为了满足这个条件，在进行Hash时引入一个随机数变量。用伪代码表示一下：1Hash(上一个Hash值，交易记录集) = 456635BCD 1Hash(上一个Hash值，交易记录集，随机数) = 0000aFD635BCD 我们知道改变Hash的原始信息的任何一部分，Hash值也会随之不断的变化，因此在运算Hash时，不断的改变随机数的值，总可以找的一个随机数使的Hash的结果以若干个0开头（下文把这个过程称为猜谜），率先找到随机数的节点就获得此次记账的唯一记账权。 计算量分析（这部分可选阅读）我们简单分析下记账难度有多大，Hash值是由数字和大小写字母构成的字符串，每一位有62种可能性（可能为26个大写字母、26个小写字母，10个数字中任一个），假设任何一个字符出现的概率是均等的，那么第一位为0的概率是1/62（其他位出现什么字符先不管），理论上需要尝试62次Hash运算才会出现一次第一位为0的情况，如果前两2位为0，就得尝试62的平方次Hash运算，以n个0开头就需要尝试62的n次方次运算。我们结合当前实际区块#493050信息来看看： 注：数据来源于https://blockchain.info我们可以看到Hash值以18个0开头，理论上需要尝试62的18次方次，这个数是非常非常巨大的，我已经算不清楚了，应该是亿亿级别以上了。如此大的计算量需要投入大量的计算设备、电力等，目前应该没有单矿工独立参与挖矿了，基本都是由矿工联合起来组成矿池进行挖矿（矿池里的矿工按算力百分比来分收益）。 从经济的角度讲，只有挖矿还有收益（比特币价格不断上涨也让收益变大），就会有新的矿工加入，从而加剧竞争，提高算力难度，挖矿就需要耗费更多的运算和电力，相互作用引起最终成本会接近收益。 题外话：国内由于电力成本较低，相对收益更高，中国的算力占整个网络的一半以上 验证在节点成功找到满足的Hash值之后，会马上对全网进行广播打包区块，网络的节点收到广播打包区块，会立刻对其进行验证。 如果验证通过，则表明已经有节点成功解迷，自己就不再竞争当前区块打包，而是选择接受这个区块，记录到自己的账本中，然后进行下一个区块的竞争猜谜。网络中只有最快解谜的区块，才会添加的账本中，其他的节点进行复制，这样就保证了整个账本的唯一性。 假如节点有任何的作弊行为，都会导致网络的节点验证不通过，直接丢弃其打包的区块，这个区块就无法记录到总账本中，作弊的节点耗费的成本就白费了，因此在巨大的挖矿成本下，也使得矿工自觉自愿的遵守比特币系统的共识协议，也就确保了整个系统的安全。 进阶阅读比特币区块结构Merkle树及简单支付验证分析，可以详细了解区块结构如何验证交易。 说明矿工的收益其实不仅仅包含新发行的12.5比特币奖励，同时还有交易费收益（本文忽略一些细节是为了让主干更清晰）。 有兴趣的同学可以看看图中区块都包含了那些信息，红箭头标示出的是本文涉及的信息。 本文中有提到共识协议，比特币共识协议主要是由工作量证明和最长链机制 两部分组成，请阅读比特币如何达成共识 - 最长链的选择。 深入浅出区块链 - 系统学习区块链，打造最好的区块链技术博客我的知识星球为各位解答区块链技术问题，欢迎加入讨论。","categories":[{"name":"比特币","slug":"bitcoin","permalink":"https://learnblockchain.cn/categories/bitcoin/"}],"tags":[{"name":"比特币","slug":"比特币","permalink":"https://learnblockchain.cn/tags/比特币/"},{"name":"挖矿","slug":"挖矿","permalink":"https://learnblockchain.cn/tags/挖矿/"},{"name":"工作量证明","slug":"工作量证明","permalink":"https://learnblockchain.cn/tags/工作量证明/"},{"name":"共识机制","slug":"共识机制","permalink":"https://learnblockchain.cn/tags/共识机制/"}]},{"title":"比特币所有权及隐私问题-非对称加密应用","slug":"bitcoin-own","date":"2017-11-02T09:19:29.000Z","updated":"2018-03-17T14:01:01.949Z","comments":true,"path":"2017/11/02/bitcoin-own/","link":"","permalink":"https://learnblockchain.cn/2017/11/02/bitcoin-own/","excerpt":"比特币系统是如何确定某个账户的比特币是属于谁的？谁可以支付这个账户比特币？ 如果你对这个问题还不是很明白，那就一起来看看吧。","text":"比特币系统是如何确定某个账户的比特币是属于谁的？谁可以支付这个账户比特币？ 如果你对这个问题还不是很明白，那就一起来看看吧。 银行系统我们先来回顾下现实的银行系统： 首先我们需要把我们的个人信息（如身份证）给银行，银行给我们开立相对应的账户，银行在开户的时候确立了对账户的所有权。 进行支付的时候，银行对交易双方完成转账（银行在开户的时候已经知道我们对应的账户）。 同时银行会对账户信息进行保密（这点其实不能保证）。 匿名账本那么比特币如何在没有第三方银行的参与下，在确保隐私的同时如何确定账户所有权的呢？ 实际上比特币的账户是用地址来表示，账本上不显示个人信息，转账是把比特币从一个地址转移到另一个地址。转账记录如这样：12345&#123; \"付款地址\"：\"2A39CBa2390FDe\" \"收款地址\"：\"AAC9CBa239aFcc\" \"金额\"：\"0.2btc\"&#125; 接下来问题就变为了 谁有权用某个地址进行付款。 支付和所有权 实际是同一个问题，如果此比特币只有我可以用来支付，那么说明我拥有所有权 地址与私钥比特币的解决方案是，谁拥有某个地址的私钥(如果完全没有加密概念的人，可以简单的把私钥当作密码)，谁就能用这个地址进行支付。（所以私钥一定保管好，如果私钥泄漏，比特币就可能丢失） 比特币地址和私钥是一个非对称的关系，私钥经过一系列运算（其中有两次Hash）之后，可以得到地址, 但是无法从地址反推得到私钥。1234地址： 2A39CBa2390FDe私钥： sdgHsdniNIhdsgaKIhkgnakgaihNKHIskdgalHash(Hash(fun(sdgHsdniNIhdsgaKIhkgnakgaihNKHIskdgal))) -&gt; 2A39CBa2390FDe 银行系统银行账号和密码是完全独立的，无法互相推导，转出时需要同时验证账号和密码 还是上面交易的例子：12345&#123; \"付款地址\"：\"2A39CBa2390FDe\", \"收款地址\"：\"AAC9CBa239aFcc\", \"金额\"：\"0.2btc\"&#125; 只有拥有地址2A39CBa2390FDe的私钥才能进行支付。 非对称加密技术这个时候问题就变为了，如何证明你拥有某个地址的私钥（在不泄漏私钥的情况下）。 对交易信息进行签名实际在签名之前，会先对交易信息进行Hash运算得到摘要信息，然后对摘要信息进行签名。过程大概是这样：1.对交易进行hash， 得到一个摘要信息（Hash值） 12345hash(&apos; &#123;&quot;付款地址&quot;：&quot;2A39CBa2390FDe&quot;, &quot;收款地址&quot;：&quot;AAC9CBa239aFcc&quot;, &quot;金额&quot;：&quot;0.2btc&quot; &#125;&apos;) -&gt; 8aDB23CDEA6 2.用私钥对交易摘要进行签名（付款方在安全的环境下进行，以避免私钥泄密）, 用代码表示大概是这样。1234#参数1为交易摘要#参数2为私钥#返回签名信息sign(\"8aDB23CDEA6\", \"J78sknJhidhLIqdngalket\") -&gt; \"3cdferdadgadg\" 广播在签名运算之后，付款节点就开始在全网进行广播：我支付了0.2btc到AAC9CBa239aFcc,签名信息是3cdferdadgadg，你们来确认一下吧。 广播过程实际上是发信息到相连的其它节点，其它节点在验证通过后再转发到与之相连的节点，这样的扩散过程。 广播的信息包含了交易原始信息和签名信息 验证其它节点在收到广播信息之后，会验证签名信息是不是付款方用私钥对交易原始信息签名产生的，如果验证通过说明确实是付款方本人发出的交易，说明交易有效，才会记录到账本中去。（实际还会验证付款账号有没有足够的余额，我们暂时忽略这点）验证过程实际是签名过程的逆运算，用代码表示大概过程是这样的： 1234#参数1为签名信息#参数2为付款方地址#返回交易摘要verify(\"3cdferdadgadg\", \"2A39CBa2390FDe\") -&gt; \"8aDB23CDEA6\" 如果验证输出的信息和原始交易信息的hash一致，则验证通过，记录账本，用代码表示大概是这样： 12345678if(verify(\"3cdferdadgadg\", \"2A39CBa2390FDe\") == hash('&#123;\"付款地址\"：\"2A39CBa2390FDe\", \"收款地址\"：\"AAC9CBa239aFcc\", \"金额\"：\"0.2btc\"&#125;')) : # \b\b写入账本 # 广播else: # donothing 大家可以理解为付款地址为公钥，签名过程即为用私钥对交易摘要的加密过程，验证过程为用公钥解密的过程(为方便大家理解，严格来讲是不准确的)。 补充说明上面为了更好的理解，我对一些信息进行了简化。 比特币系统使用了椭圆曲线签名算法，算法的私钥由32个字节随机数组成，通过私钥可以计算出公钥，公钥经过一序列哈希算法和编码算法得到比特币地址，地址也可以理解为公钥的摘要。 深入浅出区块链 - 系统学习区块链，打造最好的区块链技术博客我的知识星球为各位解答区块链技术问题，欢迎加入讨论。","categories":[{"name":"比特币","slug":"bitcoin","permalink":"https://learnblockchain.cn/categories/bitcoin/"}],"tags":[{"name":"非对称加密","slug":"非对称加密","permalink":"https://learnblockchain.cn/tags/非对称加密/"},{"name":"比特币","slug":"比特币","permalink":"https://learnblockchain.cn/tags/比特币/"},{"name":"所有权问题","slug":"所有权问题","permalink":"https://learnblockchain.cn/tags/所有权问题/"},{"name":"隐私问题","slug":"隐私问题","permalink":"https://learnblockchain.cn/tags/隐私问题/"}]},{"title":"用Python从零开始创建区块链","slug":"build_blockchain_by_python","date":"2017-10-27T02:15:28.000Z","updated":"2018-01-10T08:14:07.764Z","comments":true,"path":"2017/10/27/build_blockchain_by_python/","link":"","permalink":"https://learnblockchain.cn/2017/10/27/build_blockchain_by_python/","excerpt":"本文主要内容翻译自Learn Blockchains by Building One\b本文原始链接,转载请注明出处。作者认为最快的学习区块链的方式是自己创建一个，本文就跟随作者用Python来创建一个区块链。","text":"本文主要内容翻译自Learn Blockchains by Building One\b本文原始链接,转载请注明出处。作者认为最快的学习区块链的方式是自己创建一个，本文就跟随作者用Python来创建一个区块链。 对数字货币的崛起感到新奇的我们，并且想知道其背后的技术——区块链是怎样实现的。 但是完全搞懂区块链并非易事，我喜欢在实践中学习，通过写代码来学习技术会掌握得更牢固。通过构建一个区块链可以加深对区块链的理解。 准备工作本文要求读者对Python有基本的理解，能读写基本的Python，并且需要对HTTP请求有基本的了解。 我们知道区块链是由区块的记录构成的不可变、有序的链结构，记录可以是交易、文件或任何你想要的数据，重要的是它们是通过哈希值（hashes）链接起来的。 如果你还不是很了解哈希，可以查看这篇文章 环境准备环境准备，确保已经安装Python3.6+, pip , Flask, requests安装方法：1pip install Flask==0.12.2 requests==2.18.4 同时还需要一个HTTP客户端，比如Postman，cURL或其它客户端。 参考源代码（原代码在我翻译的时候，无法运行，我fork了一份，修复了其中的错误，并添加了翻译，感谢star） 开始创建Blockchain新建一个文件 blockchain.py，本文所有的代码都写在这一个文件中，可以随时参考源代码 Blockchain类首先创建一个Blockchain类，在构造函数中创建了两个列表，一个用于储存区块链，一个用于储存交易。 以下是Blockchain类的框架：12345678910111213141516171819202122class Blockchain(object): def __init__(self): self.chain = [] self.current_transactions = [] def new_block(self): # Creates a new Block and adds it to the chain pass def new_transaction(self): # Adds a new transaction to the list of transactions pass @staticmethod def hash(block): # Hashes a Block pass @property def last_block(self): # Returns the last Block in the chain pass Blockchain类用来管理链条，它能存储交易，加入新块等，下面我们来进一步完善这些方法。 块结构每个区块包含属性：索引（index），Unix时间戳（timestamp），交易列表（transactions），工作量证明（稍后解释）以及前一个区块的Hash值。 以下是一个区块的结构：12345678910111213block = &#123; 'index': 1, 'timestamp': 1506057125.900785, 'transactions': [ &#123; 'sender': \"8527147fe1f5426f9dd545de4b27ee00\", 'recipient': \"a77f5cdfa2934df3954a5c7c7da5df1f\", 'amount': 5, &#125; ], 'proof': 324984774000, 'previous_hash': \"2cf24dba5fb0a30e26e83b2ac5b9e29e1b161e5c1fa7425e73043362938b9824\"&#125; 到这里，区块链的概念就清楚了，每个新的区块都包含上一个区块的Hash，这是关键的一点，它保障了区块链不可变性。如果攻击者破坏了前面的某个区块，那么后面所有区块的Hash都会变得不正确。不理解的话，慢慢消化，可参考区块链记账原理 加入交易接下来我们需要添加一个交易，来完善下new_transaction方法12345678910111213141516171819class Blockchain(object): ... def new_transaction(self, sender, recipient, amount): \"\"\" 生成新交易信息，信息将加入到下一个待挖的区块中 :param sender: &lt;str&gt; Address of the Sender :param recipient: &lt;str&gt; Address of the Recipient :param amount: &lt;int&gt; Amount :return: &lt;int&gt; The index of the Block that will hold this transaction \"\"\" self.current_transactions.append(&#123; 'sender': sender, 'recipient': recipient, 'amount': amount, &#125;) return self.last_block['index'] + 1 方法向列表中添加一个交易记录，并返回该记录将被添加到的区块(下一个待挖掘的区块)的索引，等下在用户提交交易时会有用。 创建新块当Blockchain实例化后，我们需要构造一个创世块（没有前区块的第一个区块），并且给它加上一个工作量证明。每个区块都需要经过工作量证明，俗称挖矿，稍后会继续讲解。 为了构造创世块，我们还需要完善new_block(), new_transaction() 和hash() 方法： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566import hashlibimport jsonfrom time import timeclass Blockchain(object): def __init__(self): self.current_transactions = [] self.chain = [] # Create the genesis block self.new_block(previous_hash=1, proof=100) def new_block(self, proof, previous_hash=None): \"\"\" 生成新块 :param proof: &lt;int&gt; The proof given by the Proof of Work algorithm :param previous_hash: (Optional) &lt;str&gt; Hash of previous Block :return: &lt;dict&gt; New Block \"\"\" block = &#123; 'index': len(self.chain) + 1, 'timestamp': time(), 'transactions': self.current_transactions, 'proof': proof, 'previous_hash': previous_hash or self.hash(self.chain[-1]), &#125; # Reset the current list of transactions self.current_transactions = [] self.chain.append(block) return block def new_transaction(self, sender, recipient, amount): \"\"\" 生成新交易信息，信息将加入到下一个待挖的区块中 :param sender: &lt;str&gt; Address of the Sender :param recipient: &lt;str&gt; Address of the Recipient :param amount: &lt;int&gt; Amount :return: &lt;int&gt; The index of the Block that will hold this transaction \"\"\" self.current_transactions.append(&#123; 'sender': sender, 'recipient': recipient, 'amount': amount, &#125;) return self.last_block['index'] + 1 @property def last_block(self): return self.chain[-1] @staticmethod def hash(block): \"\"\" 生成块的 SHA-256 hash值 :param block: &lt;dict&gt; Block :return: &lt;str&gt; \"\"\" # We must make sure that the Dictionary is Ordered, or we'll have inconsistent hashes block_string = json.dumps(block, sort_keys=True).encode() return hashlib.sha256(block_string).hexdigest() 通过上面的代码和注释可以对区块链有直观的了解，接下来我们看看区块是怎么挖出来的。 理解工作量证明新的区块依赖工作量证明算法（PoW）来构造。PoW的目标是找出一个符合特定条件的数字，这个数字很难计算出来，但容易验证。这就是工作量证明的核心思想。 为了方便理解，举个例子： 假设一个整数 x 乘以另一个整数 y 的积的 Hash 值必须以 0 结尾，即 hash(x * y) = ac23dc…0。设变量 x = 5，求 y 的值？ 用Python实现如下： 123456from hashlib import sha256x = 5y = 0 # y未知while sha256(f'&#123;x*y&#125;'.encode()).hexdigest()[-1] != \"0\": y += 1print(f'The solution is y = &#123;y&#125;') 结果是y=21. 因为：1hash(5 * 21) = 1253e9373e...5e3600155e860 在比特币中，使用称为Hashcash的工作量证明算法，它和上面的问题很类似。矿工们为了争夺创建区块的权利而争相计算结果。通常，计算难度与目标字符串需要满足的特定字符的数量成正比，矿工算出结果后，会获得比特币奖励。当然，在网络上非常容易验证这个结果。 实现工作量证明让我们来实现一个相似PoW算法，规则是：寻找一个数 p，使得它与前一个区块的 proof 拼接成的字符串的 Hash 值以 4 个零开头。 12345678910111213141516171819202122232425262728293031323334353637import hashlibimport jsonfrom time import timefrom uuid import uuid4class Blockchain(object): ... def proof_of_work(self, last_proof): \"\"\" 简单的工作量证明: - 查找一个 p' 使得 hash(pp') 以4个0开头 - p 是上一个块的证明, p' 是当前的证明 :param last_proof: &lt;int&gt; :return: &lt;int&gt; \"\"\" proof = 0 while self.valid_proof(last_proof, proof) is False: proof += 1 return proof @staticmethod def valid_proof(last_proof, proof): \"\"\" 验证证明: 是否hash(last_proof, proof)以4个0开头? :param last_proof: &lt;int&gt; Previous Proof :param proof: &lt;int&gt; Current Proof :return: &lt;bool&gt; True if correct, False if not. \"\"\" guess = f'&#123;last_proof&#125;&#123;proof&#125;'.encode() guess_hash = hashlib.sha256(guess).hexdigest() return guess_hash[:4] == \"0000\" 衡量算法复杂度的办法是修改零开头的个数。使用4个来用于演示，你会发现多一个零都会大大增加计算出结果所需的时间。 现在Blockchain类基本已经完成了，接下来使用HTTP requests来进行交互。 Blockchain作为API接口我们将使用Python Flask框架，这是一个轻量Web应用框架，它方便将网络请求映射到 Python函数，现在我们来让Blockchain运行在基于Flask web上。 我们将创建三个接口： /transactions/new 创建一个交易并添加到区块 /mine 告诉服务器去挖掘新的区块 /chain 返回整个区块链 创建节点我们的“Flask服务器”将扮演区块链网络中的一个节点。我们先添加一些框架代码： 1234567891011121314151617181920212223242526272829303132333435363738394041import hashlibimport jsonfrom textwrap import dedentfrom time import timefrom uuid import uuid4from flask import Flaskclass Blockchain(object): ...# Instantiate our Nodeapp = Flask(__name__)# Generate a globally unique address for this nodenode_identifier = str(uuid4()).replace('-', '')# Instantiate the Blockchainblockchain = Blockchain()@app.route('/mine', methods=['GET'])def mine(): return \"We'll mine a new Block\" @app.route('/transactions/new', methods=['POST'])def new_transaction(): return \"We'll add a new transaction\"@app.route('/chain', methods=['GET'])def full_chain(): response = &#123; 'chain': blockchain.chain, 'length': len(blockchain.chain), &#125; return jsonify(response), 200if __name__ == '__main__': app.run(host='0.0.0.0', port=5000) 简单的说明一下以上代码： 第15行: 创建一个节点. 第18行: 为节点创建一个随机的名字. 第21行: 实例Blockchain类. 第24–26行: 创建/mine GET接口。 第28–30行: 创建/transactions/new POST接口,可以给接口发送交易数据. 第32–38行: 创建 /chain 接口, 返回整个区块链。 第40–41行: 服务运行在端口5000上. 发送交易发送到节点的交易数据结构如下：12345&#123; \"sender\": \"my address\", \"recipient\": \"someone else's address\", \"amount\": 5&#125; 之前已经有添加交易的方法，基于接口来添加交易就很简单了 123456789101112131415161718192021222324import hashlibimport jsonfrom textwrap import dedentfrom time import timefrom uuid import uuid4from flask import Flask, jsonify, request...@app.route('/transactions/new', methods=['POST'])def new_transaction(): values = request.get_json() # Check that the required fields are in the POST'ed data required = ['sender', 'recipient', 'amount'] if not all(k in values for k in required): return 'Missing values', 400 # Create a new Transaction index = blockchain.new_transaction(values['sender'], values['recipient'], values['amount']) response = &#123;'message': f'Transaction will be added to Block &#123;index&#125;'&#125; return jsonify(response), 201 挖矿挖矿正是神奇所在，它很简单，做了一下三件事： 计算工作量证明PoW 通过新增一个交易授予矿工（自己）一个币 构造新区块并将其添加到链中 123456789101112131415161718192021222324252627282930313233343536import hashlibimport jsonfrom time import timefrom uuid import uuid4from flask import Flask, jsonify, request...@app.route('/mine', methods=['GET'])def mine(): # We run the proof of work algorithm to get the next proof... last_block = blockchain.last_block last_proof = last_block['proof'] proof = blockchain.proof_of_work(last_proof) # 给工作量证明的节点提供奖励. # 发送者为 \"0\" 表明是新挖出的币 blockchain.new_transaction( sender=\"0\", recipient=node_identifier, amount=1, ) # Forge the new Block by adding it to the chain block = blockchain.new_block(proof) response = &#123; 'message': \"New Block Forged\", 'index': block['index'], 'transactions': block['transactions'], 'proof': block['proof'], 'previous_hash': block['previous_hash'], &#125; return jsonify(response), 200 注意交易的接收者是我们自己的服务器节点，我们做的大部分工作都只是围绕Blockchain类方法进行交互。到此，我们的区块链就算完成了，我们来实际运行下 运行区块链你可以使用cURL 或Postman 去和API进行交互 启动server:12$ python blockchain.py* Runing on http://127.0.0.1:5000/ (Press CTRL+C to quit) 让我们通过请求 http://localhost:5000/mine 来进行挖矿 通过post请求，添加一个新交易 如果不是使用Postman，则用一下的cURL语句也是一样的：12345$ curl -X POST -H \"Content-Type: application/json\" -d '&#123; \"sender\": \"d4ee26eee15148ee92c6cd394edd974e\", \"recipient\": \"someone-other-address\", \"amount\": 5&#125;' \"http://localhost:5000/transactions/new\" 在挖了两次矿之后，就有3个块了，通过请求 http://localhost:5000/chain 可以得到所有的块信息。 1234567891011121314151617181920212223242526272829303132333435363738&#123; \"chain\": [ &#123; \"index\": 1, \"previous_hash\": 1, \"proof\": 100, \"timestamp\": 1506280650.770839, \"transactions\": [] &#125;, &#123; \"index\": 2, \"previous_hash\": \"c099bc...bfb7\", \"proof\": 35293, \"timestamp\": 1506280664.717925, \"transactions\": [ &#123; \"amount\": 1, \"recipient\": \"8bbcb347e0634905b0cac7955bae152b\", \"sender\": \"0\" &#125; ] &#125;, &#123; \"index\": 3, \"previous_hash\": \"eff91a...10f2\", \"proof\": 35089, \"timestamp\": 1506280666.1086972, \"transactions\": [ &#123; \"amount\": 1, \"recipient\": \"8bbcb347e0634905b0cac7955bae152b\", \"sender\": \"0\" &#125; ] &#125; ], \"length\": 3&#125; 一致性（共识）我们已经有了一个基本的区块链可以接受交易和挖矿。但是区块链系统应该是分布式的。既然是分布式的，那么我们究竟拿什么保证所有节点有同样的链呢？这就是一致性问题，我们要想在网络上有多个节点，就必须实现一个一致性的算法。 注册节点在实现一致性算法之前，我们需要找到一种方式让一个节点知道它相邻的节点。每个节点都需要保存一份包含网络中其它节点的记录。因此让我们新增几个接口： /nodes/register 接收URL形式的新节点列表 /nodes/resolve 执行一致性算法，解决任何冲突，确保节点拥有正确的链 我们修改下Blockchain的init函数并提供一个注册节点方法：1234567891011121314151617181920...from urllib.parse import urlparse...class Blockchain(object): def __init__(self): ... self.nodes = set() ... def register_node(self, address): \"\"\" Add a new node to the list of nodes :param address: &lt;str&gt; Address of node. Eg. 'http://192.168.0.5:5000' :return: None \"\"\" parsed_url = urlparse(address) self.nodes.add(parsed_url.netloc) 我们用 set 来储存节点，这是一种避免重复添加节点的简单方法。 实现共识算法前面提到，冲突是指不同的节点拥有不同的链，为了解决这个问题，规定最长的、有效的链才是最终的链，换句话说，网络中有效最长链才是实际的链。 我们使用一下的算法，来达到网络中的共识12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667...import requestsclass Blockchain(object) ... def valid_chain(self, chain): \"\"\" Determine if a given blockchain is valid :param chain: &lt;list&gt; A blockchain :return: &lt;bool&gt; True if valid, False if not \"\"\" last_block = chain[0] current_index = 1 while current_index &lt; len(chain): block = chain[current_index] print(f'&#123;last_block&#125;') print(f'&#123;block&#125;') print(\"\\n-----------\\n\") # Check that the hash of the block is correct if block['previous_hash'] != self.hash(last_block): return False # Check that the Proof of Work is correct if not self.valid_proof(last_block['proof'], block['proof']): return False last_block = block current_index += 1 return True def resolve_conflicts(self): \"\"\" 共识算法解决冲突 使用网络中最长的链. :return: &lt;bool&gt; True 如果链被取代, 否则为False \"\"\" neighbours = self.nodes new_chain = None # We're only looking for chains longer than ours max_length = len(self.chain) # Grab and verify the chains from all the nodes in our network for node in neighbours: response = requests.get(f'http://&#123;node&#125;/chain') if response.status_code == 200: length = response.json()['length'] chain = response.json()['chain'] # Check if the length is longer and the chain is valid if length &gt; max_length and self.valid_chain(chain): max_length = length new_chain = chain # Replace our chain if we discovered a new, valid chain longer than ours if new_chain: self.chain = new_chain return True return False 第一个方法 valid_chain() 用来检查是否是有效链，遍历每个块验证hash和proof. 第2个方法 resolve_conflicts() 用来解决冲突，遍历所有的邻居节点，并用上一个方法检查链的有效性， 如果发现有效更长链，就替换掉自己的链 让我们添加两个路由，一个用来注册节点，一个用来解决冲突。12345678910111213141516171819202122232425262728293031323334@app.route('/nodes/register', methods=['POST'])def register_nodes(): values = request.get_json() nodes = values.get('nodes') if nodes is None: return \"Error: Please supply a valid list of nodes\", 400 for node in nodes: blockchain.register_node(node) response = &#123; 'message': 'New nodes have been added', 'total_nodes': list(blockchain.nodes), &#125; return jsonify(response), 201@app.route('/nodes/resolve', methods=['GET'])def consensus(): replaced = blockchain.resolve_conflicts() if replaced: response = &#123; 'message': 'Our chain was replaced', 'new_chain': blockchain.chain &#125; else: response = &#123; 'message': 'Our chain is authoritative', 'chain': blockchain.chain &#125; return jsonify(response), 200 你可以在不同的机器运行节点，或在一台机机开启不同的网络端口来模拟多节点的网络，这里在同一台机器开启不同的端口演示，在不同的终端运行一下命令，就启动了两个节点：http://localhost:5000 和 http://localhost:5001 12pipenv run python blockchain.pypipenv run python blockchain.py -p 5001 然后在节点2上挖两个块，确保是更长的链，然后在节点1上访问接口/nodes/resolve ,这时节点1的链会通过共识算法被节点2的链取代。 好啦，你可以邀请朋友们一起来测试你的区块链 深入浅出区块链 - 系统学习区块链，打造最好的区块链技术博客。我的知识星球为各位解答区块链技术问题，欢迎加入讨论。","categories":[{"name":"其他","slug":"other","permalink":"https://learnblockchain.cn/categories/other/"}],"tags":[{"name":"python","slug":"python","permalink":"https://learnblockchain.cn/tags/python/"},{"name":"创建区块链","slug":"创建区块链","permalink":"https://learnblockchain.cn/tags/创建区块链/"},{"name":"翻译","slug":"翻译","permalink":"https://learnblockchain.cn/tags/翻译/"}]},{"title":"区块链记账原理","slug":"whatbc","date":"2017-10-25T15:26:04.000Z","updated":"2018-01-10T08:12:11.881Z","comments":true,"path":"2017/10/25/whatbc/","link":"","permalink":"https://learnblockchain.cn/2017/10/25/whatbc/","excerpt":"区块链(1.0)是一个基于密码学安全的分布式账本，是一个方便验证，不可篡改的账本。 通常认为与智能合约相结合的区块链为区块链2.0, 如以太坊是典型的区块链2.0 很多人只了解过比特币，不知道区块链，比特币实际是一个使用了区块链技术的应用，只是比特币当前太热，把区块链技术的光芒给掩盖了。区块链才是未来，期望各位开发人员少关心币价，多关心技术。 本文将讲解区块链1.0技术是如何实现的。","text":"区块链(1.0)是一个基于密码学安全的分布式账本，是一个方便验证，不可篡改的账本。 通常认为与智能合约相结合的区块链为区块链2.0, 如以太坊是典型的区块链2.0 很多人只了解过比特币，不知道区块链，比特币实际是一个使用了区块链技术的应用，只是比特币当前太热，把区块链技术的光芒给掩盖了。区块链才是未来，期望各位开发人员少关心币价，多关心技术。 本文将讲解区块链1.0技术是如何实现的。 哈希函数在讲区块链记账之前，先说明一下哈希函数。哈希函数：Hash(原始信息) = 摘要信息原始信息可以是任意的信息, hash之后会得到一个简短的摘要信息 哈希函数有几个特点: 同样的原始信息用同一个哈希函数总能得到相同的摘要信息 原始信息任何微小的变化都会哈希出面目全非的摘要信息 从摘要信息无法逆向推算出原始信息 举例说明：Hash(张三借给李四100万，利息1%，1年后还本息 …..) = AC4635D34DEF账本上记录了AC4635D34DEF这样一条记录。 可以看出哈希函数有4个作用： 简化信息很好理解，哈希后的信息变短了。 标识信息可以使用AC4635D34DEF来标识原始信息，摘要信息也称为原始信息的id。 隐匿信息账本是AC4635D34DEF这样一条记录，原始信息被隐匿。 验证信息假如李四在还款时欺骗说，张三只借给李四10万，双方可以用AC4635D34DEF来验证原始信息 哈希函数的这4个作用在区块链技术里有广泛的运用。（哈希函数是一组函数或算法，以后会发文章专门介绍哈希） 区块链记账方法假设有一个账页序号为0的账页交易记录如下: 账号 入账 出账 余额 备注说明 王二 100 190 收到xxx货款 张三 100 30 xxxx 李四 120 90 170 xxxx 记账时间为：2017-10-22 10:22:02 区块链在记账是会把账页信息（包含序号、记账时间、交易记录）作为原始信息进行Hash, 得到一个Hash值，如：787635ACD, 用函数表示为：1Hash(序号0、记账时间、交易记录) = 787635ACD 账页信息和Hash值组合在一起就构成了第一个区块。 比特币系统里约10分钟记一次账，即每个区块生成时间大概间隔10分钟 在记第2个账页的时候，会把上一个块的Hash值和当前的账页信息一起作为原始信息进行Hash,即： 1Hash(上一个Hash值、序号1、记账时间、交易记录) = 456635BCD 这样第2个区块不仅包含了本账页信息，还间接的包含了第一个区块的信息。依次按照此方法继续记账，则最新的区块总是间接包含了所有之前的账页信息。 所有这些区块组合起来就形成了区块链，这样的区块链就构成了一个便于验证（只要验证最后一个区块的Hash值就相当于验证了整个账本），不可更改（任何一个交易信息的更改，会让所有之后的区块的Hash值发生变化，这样在验证时就无法通过）的总账本。 记账有成本，想了解节点为什么要记账，请看这篇：在比特币如何挖矿-工作量证明 深入浅出区块链系统学习区块链，打造最好的区块链技术博客。我的知识星球为各位解答区块链技术问题，欢迎加入讨论。","categories":[{"name":"比特币","slug":"bitcoin","permalink":"https://learnblockchain.cn/categories/bitcoin/"}],"tags":[{"name":"区块链","slug":"区块链","permalink":"https://learnblockchain.cn/tags/区块链/"},{"name":"原理","slug":"原理","permalink":"https://learnblockchain.cn/tags/原理/"},{"name":"哈希","slug":"哈希","permalink":"https://learnblockchain.cn/tags/哈希/"},{"name":"如何记账","slug":"如何记账","permalink":"https://learnblockchain.cn/tags/如何记账/"}]},{"title":"比特币是什么","slug":"whatisbitcoin","date":"2017-10-23T14:36:05.000Z","updated":"2018-01-10T08:12:16.979Z","comments":true,"path":"2017/10/23/whatisbitcoin/","link":"","permalink":"https://learnblockchain.cn/2017/10/23/whatisbitcoin/","excerpt":"对于比特币也许一千个人有一千种理解。本文作为入门篇（写给完全没有了解过比特币概念的新手，老手可忽略），我尽量用简单易懂的语言来介绍比特币。 到底什么是比特币，它到底是怎么运行的呢。","text":"对于比特币也许一千个人有一千种理解。本文作为入门篇（写给完全没有了解过比特币概念的新手，老手可忽略），我尽量用简单易懂的语言来介绍比特币。 到底什么是比特币，它到底是怎么运行的呢。 比特币是什么 比特币是一种基于分布式网络的数字货币。比特币系统（广义的比特币）则是用来构建这种数字货币的网络系统，是一个分布式的点对点网络系统。 本文主要讲解狭义的比特币概念。 数字货币是什么凯恩斯在《货币论》上讲，货币可以承载债务，价格的一般等价物。货币的本质是等价物，它可以是任何东西，如：一张纸，一个数字，只要人们认可它的价值。人民币，美元等作为国家信用货币，其价值由国家主权背书。而数字货币是一种不依赖信用和实物的新型货币，它的价值由大家的共识决定。比特币就是一种数字货币。（我们在网银，微信，支付宝的金额，准确来讲，它是信用货币的数字化，不是数字货币，不过央行也在研究比特币，准备发行数字货币） 运行原理大家知道，在银行系统的数据库里记录着跟我们身份id对应的财产，下文称这样的记录为账本，如张三的卡10月1日转入1w, 余额10w。比特币系统也同样有这样的账本，不同银行由单一的组织负责记录,比特币的记账由所有运行系统的人（即节点，可以简单理解为一台电脑）共同参与记录，每个节点都保存（同步）一份完整的账本。同时使用简单多数原则，来保证账本的一致性。举个例子：如果有人在自己电脑上把自己的余额从1万改为1百万，他这个账本和大多数人的账本不一致，就会被比特币系统认为是无效的。 比特币使用区块链技术来支撑整个系统的运行，有兴趣的同学，可以详细阅读下这几篇博文： 区块链记账原理 比特币所有权问题 比特币如何挖矿 还可进阶阅读：分析比特币网络：一种去中心化、点对点的网络架构，可以详细了解比特币网络。比特币区块结构Merkle树及简单支付验证分析，可以详细了解区块结构如何验证交易。 深入浅出区块链 - 系统学习区块链，打造最好的区块链技术博客。我的知识星球为各位解答区块链技术问题，欢迎加入讨论。","categories":[{"name":"比特币","slug":"bitcoin","permalink":"https://learnblockchain.cn/categories/bitcoin/"}],"tags":[{"name":"比特币","slug":"比特币","permalink":"https://learnblockchain.cn/tags/比特币/"}]},{"title":"前言-如何学习区块链","slug":"前言","date":"2017-10-20T07:03:36.000Z","updated":"2017-12-07T09:36:53.000Z","comments":true,"path":"2017/10/20/前言/","link":"","permalink":"https://learnblockchain.cn/2017/10/20/前言/","excerpt":"区块链未来3到5年应该会出现行业井喷式发展，相应所需的人才必定水涨船高，每一个开发人员都不应该错过这样的机会。区块链涉及的技术很多，很多开发人员看了一些资料后，感觉好像懂了，又好像没懂。如何系统的学习区块链技术，是很多想从事区块链开发的程序员的问题，我们来一起讨论下，希望可以帮助更多的人掌握区块链开发技术。","text":"区块链未来3到5年应该会出现行业井喷式发展，相应所需的人才必定水涨船高，每一个开发人员都不应该错过这样的机会。区块链涉及的技术很多，很多开发人员看了一些资料后，感觉好像懂了，又好像没懂。如何系统的学习区块链技术，是很多想从事区块链开发的程序员的问题，我们来一起讨论下，希望可以帮助更多的人掌握区块链开发技术。 确定方向从事区块链开发也有很多方向，如:区块链应用开发人员、区块链架构师、底层核心开发、共识算法研究等等。 方向不同，需要学习的内容就不一样，如果做基于区块链应用开发，只需要了解一门编程语言（nodejs, Go, Python, C++ 等）, 大概了解区块链的原理，不一定要深入，当能理解越深入开发应用就越顺。如果做区块链基础开发，就需要了解加密算法，P2P通信，共识算法等等。 投入时间学习-动手实践由于区块链涉及的技术很多，可以相对各个技术有一个概念了解，再逐步深入原理。 当你在学习了解概念的时候，必定会产生很多疑问， 例如我们经常可以看到一句： 比特币的共识机制是通过工作量证明（POW）来实现的。就有了新疑问:什么是工作量证明，进一步了解，它是通过验证的一个特定结果，就能确认参与者完成了相应的工作量（不理解没关系，可以简单为，张三考试考了100分，就确认张三肯定好好学习了）。这时又有了新的疑问，比特币在验证什么样的结果，这时你又需要了解密码学和Hash。 逐步深入的过程也是解答疑问的过程，需要我们善用Google搜索。 如果觉得已进理解一个概念或原理时，可以尝试动手实现它，如在理解挖矿后，可以写代码模拟挖矿过程。 学习是一个长期的过期，没有捷径，必须得多读书，读代码，写代码。 学习资源介绍下面是一些学习资源的介绍，相信对大家有帮助 比特币:一种点对点的电子现金系统-英文 比特币:一种点对点的电子现金系统-中文 以太坊白皮书-英文 以太坊白皮书-中文 区块链技术指南-电子书 区块链开发指南-纸书 比特币 - 官网 以太坊 - github 超级账本Hyperledger ETHFANS - 社区 深入浅出区块链","categories":[{"name":"其他","slug":"other","permalink":"https://learnblockchain.cn/categories/other/"}],"tags":[{"name":"如何学习","slug":"如何学习","permalink":"https://learnblockchain.cn/tags/如何学习/"}]}]}